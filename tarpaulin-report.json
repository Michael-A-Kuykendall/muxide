{"files":[{"path":["C:","\\","Users","micha","repos","muxide","examples","write_fixture_video.rs"],"content":"use muxide::api::{Muxer, MuxerConfig, MuxerStats};\r\nuse std::{env, fs::File, io::Write, path::PathBuf};\r\n\r\nfn read_hex_bytes(contents: &str) -> Vec<u8> {\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\nfn main() -> Result<(), Box<dyn std::error::Error>> {\r\n    // Writes a tiny MP4 using the repository's test fixtures.\r\n    // Usage: cargo run --example write_fixture_video -- out.mp4\r\n\r\n    let out_path: PathBuf = env::args_os()\r\n        .nth(1)\r\n        .map(PathBuf::from)\r\n        .unwrap_or_else(|| PathBuf::from(\"out.mp4\"));\r\n\r\n    let frame0 = read_hex_bytes(include_str!(\"../fixtures/video_samples/frame0_key.264\"));\r\n    let frame1 = read_hex_bytes(include_str!(\"../fixtures/video_samples/frame1_p.264\"));\r\n    let frame2 = read_hex_bytes(include_str!(\"../fixtures/video_samples/frame2_p.264\"));\r\n\r\n    let file = File::create(&out_path)?;\r\n    let config = MuxerConfig::new(640, 480, 30.0);\r\n    let mut muxer = Muxer::new(file, config)?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.write_video(1.0 / 30.0, &frame1, false)?;\r\n    muxer.write_video(2.0 / 30.0, &frame2, false)?;\r\n\r\n    let stats: MuxerStats = muxer.finish_with_stats()?;\r\n\r\n    let mut stderr = std::io::stderr();\r\n    writeln!(\r\n        &mut stderr,\r\n        \"wrote {} video frames, {:.3}s, {} bytes -> {}\",\r\n        stats.video_frames,\r\n        stats.duration_secs,\r\n        stats.bytes_written,\r\n        out_path.display()\r\n    )?;\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","src","api.rs"],"content":"/// Public API definitions for the Muxide crate.\n///\n/// This module contains the types and traits that form the public contract\n/// for users of the crate.  Concrete implementations live in private\n/// modules.  The API defined here intentionally exposes only the\n/// capabilities promised by the charter and contract documents.  It does\n/// not contain any implementation details.\nuse crate::muxer::mp4::{Mp4AudioTrack, Mp4VideoTrack, Mp4Writer, Mp4WriterError, MEDIA_TIMESCALE};\nuse std::fmt;\nuse std::io::Write;\n\n/// Enumeration of supported video codecs for the initial version.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum VideoCodec {\n    /// H.264/AVC video codec.  Only the AVC Annex B stream format is\n    /// currently supported.  B‑frames are not permitted in v0.\n    H264,\n    /// H.265/HEVC video codec. Annex B stream format with VPS/SPS/PPS.\n    /// Requires first keyframe to contain VPS, SPS, and PPS NALs.\n    H265,\n    /// AV1 video codec. OBU (Open Bitstream Unit) stream format.\n    /// Requires first keyframe to contain Sequence Header OBU.\n    Av1,\n}\n\n/// Enumeration of supported audio codecs for the initial version.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum AudioCodec {\n    /// AAC (Advanced Audio Coding) with ADTS framing.  Only AAC LC is\n    /// expected to work in v0.\n    Aac,\n    /// Opus audio codec. Raw Opus packets (no container framing).\n    /// Sample rate is always 48kHz per Opus spec.\n    Opus,\n    /// No audio.  Use this variant when only video is being muxed.\n    None,\n}\n\n/// High-level muxer configuration intended for simple integrations (e.g. CrabCamera).\n#[derive(Debug, Clone)]\npub struct MuxerConfig {\n    pub width: u32,\n    pub height: u32,\n    pub framerate: f64,\n    pub audio: Option<AudioTrackConfig>,\n    pub metadata: Option<Metadata>,\n    pub fast_start: bool,\n}\n\n/// Metadata to embed in the MP4 file (title, creation time, etc.)\n#[derive(Debug, Clone, Default)]\npub struct Metadata {\n    /// Title of the recording (appears in media players)\n    pub title: Option<String>,\n    /// Creation timestamp in seconds since Unix epoch (1970-01-01)\n    pub creation_time: Option<u64>,\n}\n\nimpl Metadata {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn with_title(mut self, title: impl Into<String>) -> Self {\n        self.title = Some(title.into());\n        self\n    }\n\n    pub fn with_creation_time(mut self, unix_timestamp: u64) -> Self {\n        self.creation_time = Some(unix_timestamp);\n        self\n    }\n\n    /// Set creation time to current system time\n    pub fn with_current_time(mut self) -> Self {\n        use std::time::{SystemTime, UNIX_EPOCH};\n        if let Ok(duration) = SystemTime::now().duration_since(UNIX_EPOCH) {\n            self.creation_time = Some(duration.as_secs());\n        }\n        self\n    }\n}\n\nimpl MuxerConfig {\n    pub fn new(width: u32, height: u32, framerate: f64) -> Self {\n        Self {\n            width,\n            height,\n            framerate,\n            audio: None,\n            metadata: None,\n            fast_start: true,  // Default ON for web compatibility\n        }\n    }\n\n    pub fn with_audio(mut self, codec: AudioCodec, sample_rate: u32, channels: u16) -> Self {\n        if codec == AudioCodec::None {\n            self.audio = None;\n        } else {\n            self.audio = Some(AudioTrackConfig {\n                codec,\n                sample_rate,\n                channels,\n            });\n        }\n        self\n    }\n\n    pub fn with_metadata(mut self, metadata: Metadata) -> Self {\n        self.metadata = Some(metadata);\n        self\n    }\n\n    pub fn with_fast_start(mut self, enabled: bool) -> Self {\n        self.fast_start = enabled;\n        self\n    }\n}\n\n/// Summary statistics returned when finishing a mux.\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct MuxerStats {\n    pub video_frames: u64,\n    pub audio_frames: u64,\n    pub duration_secs: f64,\n    pub bytes_written: u64,\n}\n\n/// Builder for constructing a new muxer instance.\n///\n/// The builder follows a fluent API pattern: each method returns a\n/// modified builder, allowing method chaining.  Only the configuration\n/// necessary for the initial v0 release is included.  Additional\n/// configuration (such as B‑frame support, fragmented MP4 or other\n/// containers) will be added in future slices.\npub struct MuxerBuilder<Writer> {\n    /// The underlying writer to which container data will be written.\n    writer: Writer,\n    /// Optional video configuration.\n    video: Option<(VideoCodec, u32, u32, f64)>,\n    /// Optional audio configuration.\n    audio: Option<(AudioCodec, u32, u16)>,\n    /// Metadata to embed in the output file.\n    metadata: Option<Metadata>,\n    /// Whether to enable fast-start (moov before mdat).\n    fast_start: bool,\n}\n\nimpl<Writer> MuxerBuilder<Writer> {\n    /// Create a new builder for the given output writer.\n    pub fn new(writer: Writer) -> Self {\n        Self {\n            writer,\n            video: None,\n            audio: None,\n            metadata: None,\n            fast_start: true,  // Default ON for web compatibility\n        }\n    }\n\n    /// Configure the video track.\n    pub fn video(mut self, codec: VideoCodec, width: u32, height: u32, framerate: f64) -> Self {\n        self.video = Some((codec, width, height, framerate));\n        self\n    }\n\n    /// Configure the audio track.\n    pub fn audio(mut self, codec: AudioCodec, sample_rate: u32, channels: u16) -> Self {\n        self.audio = Some((codec, sample_rate, channels));\n        self\n    }\n\n    /// Set metadata to embed in the output file (title, creation time, etc.)\n    pub fn with_metadata(mut self, metadata: Metadata) -> Self {\n        self.metadata = Some(metadata);\n        self\n    }\n\n    /// Enable or disable fast-start mode (moov before mdat).\n    /// Default is `true` for web streaming compatibility.\n    pub fn with_fast_start(mut self, enabled: bool) -> Self {\n        self.fast_start = enabled;\n        self\n    }\n\n    /// Finalise the builder and produce a `Muxer` instance.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if required configuration is missing or invalid.\n    pub fn build(self) -> Result<Muxer<Writer>, MuxerError>\n    where\n        Writer: Write,\n    {\n        // In v0, we perform minimal validation: video configuration must be\n        // present.  Future releases may relax this to allow audio‑only\n        // streams.\n        let (codec, width, height, framerate) = self.video.ok_or(MuxerError::MissingVideoConfig)?;\n        let video_track = VideoTrackConfig {\n            codec,\n            width,\n            height,\n            framerate,\n        };\n\n        let audio_track = self.audio.and_then(|(codec, sample_rate, channels)| {\n            if codec == AudioCodec::None {\n                None\n            } else {\n                Some(AudioTrackConfig {\n                    codec,\n                    sample_rate,\n                    channels,\n                })\n            }\n        });\n\n        let mut writer = Mp4Writer::new(self.writer, video_track.codec);\n        if let Some(audio) = &audio_track {\n            writer.enable_audio(Mp4AudioTrack {\n                sample_rate: audio.sample_rate,\n                channels: audio.channels,\n                codec: audio.codec,\n            });\n        }\n\n        Ok(Muxer {\n            writer,\n            video_track,\n            audio_track,\n            metadata: self.metadata,\n            fast_start: self.fast_start,\n            first_video_pts: None,\n            last_video_pts: None,\n            last_video_dts: None,\n            last_audio_pts: None,\n            video_frame_count: 0,\n            audio_frame_count: 0,\n            finished: false,\n        })\n    }\n}\n\n/// Configuration for a video track.\n#[derive(Debug, Clone)]\npub struct VideoTrackConfig {\n    /// Video codec.\n    pub codec: VideoCodec,\n    /// Width in pixels.\n    pub width: u32,\n    /// Height in pixels.\n    pub height: u32,\n    /// Frame rate (frames per second).\n    pub framerate: f64,\n}\n\n/// Configuration for an audio track.\n#[derive(Debug, Clone)]\npub struct AudioTrackConfig {\n    /// Audio codec.\n    pub codec: AudioCodec,\n    /// Sample rate (Hz).\n    pub sample_rate: u32,\n    /// Number of audio channels.\n    pub channels: u16,\n}\n\n/// Opaque muxer type.  Users interact with this type to write frames\n/// into the container.  Implementation details are hidden in a private\n/// module.\npub struct Muxer<Writer> {\n    writer: Mp4Writer<Writer>,\n    video_track: VideoTrackConfig,\n    audio_track: Option<AudioTrackConfig>,\n    metadata: Option<Metadata>,\n    fast_start: bool,\n    first_video_pts: Option<f64>,\n    last_video_pts: Option<f64>,\n    last_video_dts: Option<f64>,\n    last_audio_pts: Option<f64>,\n    video_frame_count: u64,\n    audio_frame_count: u64,\n    finished: bool,\n}\n\n/// Error type for builder validation and runtime errors.\n///\n/// All errors include context to help diagnose issues. Error messages are designed\n/// to be educational—they explain what went wrong and how to fix it.\n#[derive(Debug)]\npub enum MuxerError {\n    /// Video configuration is missing.  In v0, a video track is required.\n    MissingVideoConfig,\n    /// Low-level IO error while writing the container.\n    Io(std::io::Error),\n    /// The muxer has already been finished.\n    AlreadyFinished,\n    /// Video `pts` must be non-negative.\n    NegativeVideoPts {\n        pts: f64,\n        frame_index: u64,\n    },\n    /// Audio `pts` must be non-negative.\n    NegativeAudioPts {\n        pts: f64,\n        frame_index: u64,\n    },\n    /// Audio was written but no audio track was configured.\n    AudioNotConfigured,\n    /// Audio sample is empty.\n    EmptyAudioFrame {\n        frame_index: u64,\n    },\n    /// Video sample is empty.\n    EmptyVideoFrame {\n        frame_index: u64,\n    },\n    /// Video timestamps must be strictly increasing.\n    NonIncreasingVideoPts {\n        prev_pts: f64,\n        curr_pts: f64,\n        frame_index: u64,\n    },\n    /// Audio timestamps must be non-decreasing.\n    DecreasingAudioPts {\n        prev_pts: f64,\n        curr_pts: f64,\n        frame_index: u64,\n    },\n    /// Audio may not precede the first video frame.\n    AudioBeforeFirstVideo {\n        audio_pts: f64,\n        first_video_pts: Option<f64>,\n    },\n    /// The first video frame must be a keyframe.\n    FirstVideoFrameMustBeKeyframe,\n    /// The first video frame must include SPS/PPS (H.264/H.265).\n    FirstVideoFrameMissingSpsPps,\n    /// The first AV1 keyframe must include a Sequence Header OBU.\n    FirstAv1FrameMissingSequenceHeader,\n    /// Audio sample is not a valid ADTS frame.\n    InvalidAdts {\n        frame_index: u64,\n    },\n    /// Audio sample is not a valid Opus packet.\n    InvalidOpusPacket {\n        frame_index: u64,\n    },\n    /// DTS must be monotonically increasing.\n    NonIncreasingDts {\n        prev_dts: f64,\n        curr_dts: f64,\n        frame_index: u64,\n    },\n}\n\nimpl From<std::io::Error> for MuxerError {\n    fn from(err: std::io::Error) -> Self {\n        MuxerError::Io(err)\n    }\n}\n\nimpl fmt::Display for MuxerError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            MuxerError::MissingVideoConfig => {\n                write!(f, \"missing video configuration: call .video() on MuxerBuilder before .build()\")\n            }\n            MuxerError::Io(err) => write!(f, \"IO error: {}\", err),\n            MuxerError::AlreadyFinished => {\n                write!(f, \"muxer already finished: cannot write frames after calling finish()\")\n            }\n            MuxerError::NegativeVideoPts { pts, frame_index } => {\n                write!(f, \"video frame {} has negative PTS ({:.3}s): timestamps must be >= 0.0\", \n                       frame_index, pts)\n            }\n            MuxerError::NegativeAudioPts { pts, frame_index } => {\n                write!(f, \"audio frame {} has negative PTS ({:.3}s): timestamps must be >= 0.0\",\n                       frame_index, pts)\n            }\n            MuxerError::AudioNotConfigured => {\n                write!(f, \"audio track not configured: call .audio() on MuxerBuilder to enable audio\")\n            }\n            MuxerError::EmptyAudioFrame { frame_index } => {\n                write!(f, \"audio frame {} is empty: ADTS frames must contain data\", frame_index)\n            }\n            MuxerError::EmptyVideoFrame { frame_index } => {\n                write!(f, \"video frame {} is empty: video samples must contain NAL units\", frame_index)\n            }\n            MuxerError::NonIncreasingVideoPts { prev_pts, curr_pts, frame_index } => {\n                write!(f, \"video frame {} has PTS {:.3}s which is not greater than previous PTS {:.3}s: \\\n                          video timestamps must strictly increase. For B-frames, use write_video_with_dts()\",\n                       frame_index, curr_pts, prev_pts)\n            }\n            MuxerError::DecreasingAudioPts { prev_pts, curr_pts, frame_index } => {\n                write!(f, \"audio frame {} has PTS {:.3}s which is less than previous PTS {:.3}s: \\\n                          audio timestamps must not decrease\",\n                       frame_index, curr_pts, prev_pts)\n            }\n            MuxerError::AudioBeforeFirstVideo { audio_pts, first_video_pts } => {\n                match first_video_pts {\n                    Some(v) => write!(f, \"audio PTS {:.3}s arrives before first video PTS {:.3}s: \\\n                                         write video frames first, or ensure audio PTS >= video PTS\",\n                                      audio_pts, v),\n                    None => write!(f, \"audio frame arrived before any video frame: \\\n                                       write at least one video frame before writing audio\"),\n                }\n            }\n            MuxerError::FirstVideoFrameMustBeKeyframe => {\n                write!(f, \"first video frame must be a keyframe (IDR): \\\n                          set is_keyframe=true and ensure the frame contains an IDR NAL unit\")\n            }\n            MuxerError::FirstVideoFrameMissingSpsPps => {\n                write!(f, \"first video frame must contain SPS and PPS NAL units: \\\n                          prepend SPS (NAL type 7) and PPS (NAL type 8) to the first keyframe\")\n            }\n            MuxerError::FirstAv1FrameMissingSequenceHeader => {\n                write!(f, \"first AV1 frame must contain a Sequence Header OBU: \\\n                          ensure the first keyframe includes OBU type 1 (SEQUENCE_HEADER)\")\n            }\n            MuxerError::InvalidAdts { frame_index } => {\n                write!(f, \"audio frame {} is not valid ADTS: ensure the frame starts with 0xFFF sync word\",\n                       frame_index)\n            }\n            MuxerError::InvalidOpusPacket { frame_index } => {\n                write!(f, \"audio frame {} is not a valid Opus packet: ensure the frame has valid TOC byte\",\n                       frame_index)\n            }\n            MuxerError::NonIncreasingDts { prev_dts, curr_dts, frame_index } => {\n                write!(f, \"video frame {} has DTS {:.3}s which is not greater than previous DTS {:.3}s: \\\n                          DTS (decode timestamps) must strictly increase\",\n                       frame_index, curr_dts, prev_dts)\n            }\n        }\n    }\n}\n\nimpl std::error::Error for MuxerError {}\n\n// Placeholder for future implementation.  The actual encoding logic will\n// live in a private `muxer` module.  For now we provide stub methods\n// returning errors.  These stubs ensure that the API compiles and can be\n// used by downstream code while implementation proceeds in later slices.\nimpl<Writer: Write> Muxer<Writer> {\n    /// Convenience constructor for config-driven integrations.\n    pub fn new(writer: Writer, config: MuxerConfig) -> Result<Self, MuxerError> {\n        let mut builder = MuxerBuilder::new(writer).video(\n            VideoCodec::H264,\n            config.width,\n            config.height,\n            config.framerate,\n        );\n        if let Some(audio) = config.audio {\n            builder = builder.audio(audio.codec, audio.sample_rate, audio.channels);\n        }\n        let mut muxer = builder.build()?;\n        muxer.metadata = config.metadata;\n        muxer.fast_start = config.fast_start;\n        Ok(muxer)\n    }\n\n    /// Write a video frame to the container.\n    ///\n    /// `pts` is the presentation timestamp in seconds.  Frames must\n    /// be supplied in strictly increasing PTS order.  The `data` slice\n    /// contains the encoded frame bitstream in Annex B format (for H.264).\n    ///\n    /// For streams with B-frames (where PTS != DTS), use `write_video_with_dts()` instead.\n    pub fn write_video(\n        &mut self,\n        pts: f64,\n        data: &[u8],\n        is_keyframe: bool,\n    ) -> Result<(), MuxerError> {\n        if self.finished {\n            return Err(MuxerError::AlreadyFinished);\n        }\n        \n        let frame_index = self.video_frame_count;\n        \n        // Reject empty frames - they cause playback issues\n        if data.is_empty() {\n            return Err(MuxerError::EmptyVideoFrame { frame_index });\n        }\n        \n        // Validate PTS is non-negative\n        if pts < 0.0 {\n            return Err(MuxerError::NegativeVideoPts { pts, frame_index });\n        }\n        \n        // Validate PTS is strictly increasing\n        if let Some(prev) = self.last_video_pts {\n            if pts <= prev {\n                return Err(MuxerError::NonIncreasingVideoPts {\n                    prev_pts: prev,\n                    curr_pts: pts,\n                    frame_index,\n                });\n            }\n        }\n        \n        let scaled_pts = (pts * MEDIA_TIMESCALE as f64).round();\n        let pts_units = scaled_pts as u64;\n        \n        if self.first_video_pts.is_none() {\n            self.first_video_pts = Some(pts);\n        }\n        \n        self.writer\n            .write_video_sample(pts_units, data, is_keyframe)\n            .map_err(|e| self.convert_mp4_error(e, frame_index))?;\n        \n        self.last_video_pts = Some(pts);\n        self.video_frame_count += 1;\n        Ok(())\n    }\n\n    /// Write a video frame with explicit decode timestamp for B-frame support.\n    ///\n    /// - `pts` is the presentation timestamp in seconds (display order)\n    /// - `dts` is the decode timestamp in seconds (decode order)\n    /// \n    /// For streams with B-frames, PTS and DTS may differ. The only constraint is that\n    /// DTS must be strictly monotonically increasing (frames must be fed in decode order).\n    ///\n    /// Example GOP: I P B B where decode order is I,P,B,B but display order is I,B,B,P\n    /// - I: DTS=0, PTS=0\n    /// - P: DTS=1, PTS=3 (decoded second, displayed fourth)\n    /// - B: DTS=2, PTS=1 (decoded third, displayed second)\n    /// - B: DTS=3, PTS=2 (decoded fourth, displayed third)\n    pub fn write_video_with_dts(\n        &mut self,\n        pts: f64,\n        dts: f64,\n        data: &[u8],\n        is_keyframe: bool,\n    ) -> Result<(), MuxerError> {\n        if self.finished {\n            return Err(MuxerError::AlreadyFinished);\n        }\n        \n        let frame_index = self.video_frame_count;\n        \n        // Reject empty frames - they cause playback issues\n        if data.is_empty() {\n            return Err(MuxerError::EmptyVideoFrame { frame_index });\n        }\n        \n        // Validate PTS is non-negative\n        if pts < 0.0 {\n            return Err(MuxerError::NegativeVideoPts { pts, frame_index });\n        }\n        \n        // Validate DTS is non-negative\n        if dts < 0.0 {\n            return Err(MuxerError::NegativeVideoPts { pts: dts, frame_index });\n        }\n        \n        // Note: PTS can be less than DTS for B-frames (displayed before their decode position)\n        // This is valid and expected for B-frame streams.\n        \n        // Validate DTS is strictly increasing\n        if let Some(prev_dts) = self.last_video_dts {\n            if dts <= prev_dts {\n                return Err(MuxerError::NonIncreasingDts {\n                    prev_dts,\n                    curr_dts: dts,\n                    frame_index,\n                });\n            }\n        }\n        \n        let scaled_pts = (pts * MEDIA_TIMESCALE as f64).round();\n        let pts_units = scaled_pts as u64;\n        let scaled_dts = (dts * MEDIA_TIMESCALE as f64).round();\n        let dts_units = scaled_dts as u64;\n        \n        if self.first_video_pts.is_none() {\n            self.first_video_pts = Some(pts);\n        }\n        \n        self.writer\n            .write_video_sample_with_dts(pts_units, dts_units, data, is_keyframe)\n            .map_err(|e| self.convert_mp4_error(e, frame_index))?;\n        \n        self.last_video_pts = Some(pts);\n        self.last_video_dts = Some(dts);\n        self.video_frame_count += 1;\n        Ok(())\n    }\n    \n    /// Convert internal Mp4WriterError to MuxerError with context\n    fn convert_mp4_error(&self, err: Mp4WriterError, frame_index: u64) -> MuxerError {\n        match err {\n            Mp4WriterError::NonIncreasingTimestamp => MuxerError::NonIncreasingVideoPts {\n                prev_pts: self.last_video_pts.unwrap_or(0.0),\n                curr_pts: 0.0, // We don't have access here, but validation above catches this\n                frame_index,\n            },\n            Mp4WriterError::FirstFrameMustBeKeyframe => MuxerError::FirstVideoFrameMustBeKeyframe,\n            Mp4WriterError::FirstFrameMissingSpsPps => MuxerError::FirstVideoFrameMissingSpsPps,\n            Mp4WriterError::FirstFrameMissingSequenceHeader => MuxerError::FirstAv1FrameMissingSequenceHeader,\n            Mp4WriterError::InvalidAdts => MuxerError::InvalidAdts { frame_index },\n            Mp4WriterError::InvalidOpusPacket => MuxerError::InvalidOpusPacket { frame_index },\n            Mp4WriterError::AudioNotEnabled => MuxerError::AudioNotConfigured,\n            Mp4WriterError::DurationOverflow => MuxerError::Io(std::io::Error::new(\n                std::io::ErrorKind::InvalidData,\n                \"duration overflow\",\n            )),\n            Mp4WriterError::AlreadyFinalized => MuxerError::AlreadyFinished,\n        }\n    }\n\n    /// Write an audio frame to the container.\n    ///\n    /// `pts` is the presentation timestamp in seconds.  The `data` slice\n    /// contains the encoded audio frame (an AAC ADTS frame).\n    /// Audio timestamps must be non-decreasing and must not precede the first video frame.\n    pub fn write_audio(&mut self, pts: f64, data: &[u8]) -> Result<(), MuxerError> {\n        if self.finished {\n            return Err(MuxerError::AlreadyFinished);\n        }\n        if self.audio_track.is_none() {\n            return Err(MuxerError::AudioNotConfigured);\n        }\n        \n        let frame_index = self.audio_frame_count;\n        \n        // Validate PTS is non-negative\n        if pts < 0.0 {\n            return Err(MuxerError::NegativeAudioPts { pts, frame_index });\n        }\n        \n        // Validate frame is not empty\n        if data.is_empty() {\n            return Err(MuxerError::EmptyAudioFrame { frame_index });\n        }\n        \n        // Validate PTS is non-decreasing\n        if let Some(prev) = self.last_audio_pts {\n            if pts < prev {\n                return Err(MuxerError::DecreasingAudioPts {\n                    prev_pts: prev,\n                    curr_pts: pts,\n                    frame_index,\n                });\n            }\n        }\n        \n        // Validate audio doesn't precede first video\n        if let Some(first_video) = self.first_video_pts {\n            if pts < first_video {\n                return Err(MuxerError::AudioBeforeFirstVideo {\n                    audio_pts: pts,\n                    first_video_pts: Some(first_video),\n                });\n            }\n        } else {\n            return Err(MuxerError::AudioBeforeFirstVideo {\n                audio_pts: pts,\n                first_video_pts: None,\n            });\n        }\n\n        let scaled_pts = (pts * MEDIA_TIMESCALE as f64).round();\n        let pts_units = scaled_pts as u64;\n        \n        self.writer.write_audio_sample(pts_units, data)\n            .map_err(|e| self.convert_mp4_error(e, frame_index))?;\n        \n        self.last_audio_pts = Some(pts);\n        self.audio_frame_count += 1;\n        Ok(())\n    }\n\n    /// Finalise the container and flush any buffered data.\n    ///\n    /// In the current slice this writes the `ftyp`/`moov` boxes, resulting\n    /// in a minimal MP4 header that can be inspected by the slice 02 tests.\n    pub fn finish_in_place(&mut self) -> Result<(), MuxerError> {\n        self.finish_in_place_with_stats().map(|_| ())\n    }\n\n    /// Finalise the container and return muxing statistics.\n    pub fn finish_in_place_with_stats(&mut self) -> Result<MuxerStats, MuxerError> {\n        if self.finished {\n            return Err(MuxerError::AlreadyFinished);\n        }\n        let params = Mp4VideoTrack {\n            width: self.video_track.width,\n            height: self.video_track.height,\n        };\n        self.writer.finalize(&params, self.metadata.as_ref(), self.fast_start)?;\n        self.finished = true;\n\n        let video_frames = self.writer.video_sample_count();\n        let audio_frames = self.writer.audio_sample_count();\n        let duration_ticks = self.writer.max_end_pts().unwrap_or(0);\n        let duration_secs = duration_ticks as f64 / MEDIA_TIMESCALE as f64;\n        let bytes_written = self.writer.bytes_written();\n\n        Ok(MuxerStats {\n            video_frames,\n            audio_frames,\n            duration_secs,\n            bytes_written,\n        })\n    }\n\n    pub fn finish(mut self) -> Result<(), MuxerError> {\n        self.finish_in_place()\n    }\n\n    /// Finalise the container and return muxing statistics.\n    pub fn finish_with_stats(mut self) -> Result<MuxerStats, MuxerError> {\n        self.finish_in_place_with_stats()\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":4179340454199820292}},{"line":162,"address":[],"length":0,"stats":{"Line":4179340454199820296}},{"line":163,"address":[],"length":0,"stats":{"Line":12538021362599460888}},{"line":164,"address":[],"length":0,"stats":{"Line":4179340454199820296}},{"line":168,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":169,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":170,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":174,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":176,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":181,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":182,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":183,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":191,"address":[],"length":0,"stats":{"Line":4179340454199820296}},{"line":198,"address":[],"length":0,"stats":{"Line":10808639105689190432}},{"line":206,"address":[],"length":0,"stats":{"Line":13546827679130451973}},{"line":207,"address":[],"length":0,"stats":{"Line":1008806316530991109}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":1008806316530991109}},{"line":211,"address":[],"length":0,"stats":{"Line":2017612633061982218}},{"line":212,"address":[],"length":0,"stats":{"Line":1008806316530991109}},{"line":213,"address":[],"length":0,"stats":{"Line":1008806316530991109}},{"line":218,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":219,"address":[],"length":0,"stats":{"Line":6196953087261802496}},{"line":220,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":221,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":222,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":223,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":227,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":228,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":229,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":230,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":231,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":232,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":233,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":234,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":235,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":236,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":237,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":238,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":239,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":365,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":374,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":391,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":401,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":410,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":414,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":418,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":421,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":422,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":430,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":446,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":447,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":448,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":449,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":450,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":451,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":453,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":457,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":458,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":459,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":469,"address":[],"length":0,"stats":{"Line":5980780305148018696}},{"line":475,"address":[],"length":0,"stats":{"Line":5980780305148018696}},{"line":476,"address":[],"length":0,"stats":{"Line":72057594037928045}},{"line":479,"address":[],"length":0,"stats":{"Line":11817445422220181302}},{"line":482,"address":[],"length":0,"stats":{"Line":11817445422220181302}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":5908722711110090651}},{"line":488,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":492,"address":[],"length":0,"stats":{"Line":7998392938210000694}},{"line":493,"address":[],"length":0,"stats":{"Line":2233785415175765915}},{"line":494,"address":[],"length":0,"stats":{"Line":360287970189639688}},{"line":495,"address":[],"length":0,"stats":{"Line":720575940379279376}},{"line":496,"address":[],"length":0,"stats":{"Line":360287970189639688}},{"line":497,"address":[],"length":0,"stats":{"Line":360287970189639688}},{"line":502,"address":[],"length":0,"stats":{"Line":16212958658533785273}},{"line":503,"address":[],"length":0,"stats":{"Line":10808639105689190182}},{"line":505,"address":[],"length":0,"stats":{"Line":14339461213547659047}},{"line":506,"address":[],"length":0,"stats":{"Line":3530822107858468865}},{"line":509,"address":[],"length":0,"stats":{"Line":5404319552844595091}},{"line":510,"address":[],"length":0,"stats":{"Line":3170534137668828748}},{"line":511,"address":[],"length":0,"stats":{"Line":8646911284551352219}},{"line":513,"address":[],"length":0,"stats":{"Line":4755801206503243659}},{"line":514,"address":[],"length":0,"stats":{"Line":4755801206503243659}},{"line":515,"address":[],"length":0,"stats":{"Line":4755801206503243659}},{"line":531,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":538,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":545,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":556,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":563,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":564,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":565,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":566,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":567,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":568,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":573,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":574,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":575,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":576,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":578,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":579,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":582,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":583,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":584,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":586,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":587,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":588,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":589,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":593,"address":[],"length":0,"stats":{"Line":792633534417207300}},{"line":594,"address":[],"length":0,"stats":{"Line":792633534417207300}},{"line":596,"address":[],"length":0,"stats":{"Line":8}},{"line":600,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":601,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":602,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":620,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":630,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":631,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":635,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":636,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":640,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":641,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":642,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":643,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":644,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":645,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":651,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":652,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":653,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":654,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":655,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":659,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":660,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":661,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":665,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":666,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":668,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":669,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":671,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":672,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":673,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":680,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":681,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":685,"address":[],"length":0,"stats":{"Line":2305843009213693955}},{"line":686,"address":[],"length":0,"stats":{"Line":2305843009213693955}},{"line":687,"address":[],"length":0,"stats":{"Line":72057594037927943}},{"line":690,"address":[],"length":0,"stats":{"Line":2233785415175766012}},{"line":691,"address":[],"length":0,"stats":{"Line":2233785415175766012}},{"line":693,"address":[],"length":0,"stats":{"Line":13402712491054596072}},{"line":694,"address":[],"length":0,"stats":{"Line":2233785415175766012}},{"line":696,"address":[],"length":0,"stats":{"Line":6701356245527298036}},{"line":697,"address":[],"length":0,"stats":{"Line":6701356245527298036}},{"line":698,"address":[],"length":0,"stats":{"Line":8935141660703064048}},{"line":699,"address":[],"length":0,"stats":{"Line":4467570830351532024}},{"line":700,"address":[],"length":0,"stats":{"Line":6701356245527298036}},{"line":702,"address":[],"length":0,"stats":{"Line":2233785415175766012}},{"line":703,"address":[],"length":0,"stats":{"Line":4467570830351532024}},{"line":704,"address":[],"length":0,"stats":{"Line":4467570830351532024}},{"line":705,"address":[],"length":0,"stats":{"Line":2233785415175766012}},{"line":706,"address":[],"length":0,"stats":{"Line":2233785415175766012}},{"line":710,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":711,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":715,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":716,"address":[],"length":0,"stats":{"Line":720575940379279360}}],"covered":175,"coverable":231},{"path":["C:","\\","Users","micha","repos","muxide","src","codec","av1.rs"],"content":"//! AV1 codec configuration extraction.\r\n//!\r\n//! This module provides parsing for AV1 OBU (Open Bitstream Unit) streams\r\n//! to extract configuration needed for MP4 muxing.\r\n//!\r\n//! # Overview\r\n//!\r\n//! AV1 uses OBU (Open Bitstream Unit) framing instead of NAL units.\r\n//! Configuration requires extracting the Sequence Header OBU.\r\n//!\r\n//! # OBU Types\r\n//!\r\n//! | Type | Name | Purpose |\r\n//! |------|------|---------|\r\n//! | 1 | OBU_SEQUENCE_HEADER | Sequence configuration |\r\n//! | 3 | OBU_FRAME_HEADER | Frame metadata |\r\n//! | 6 | OBU_FRAME | Complete frame |\r\n//!\r\n//! # Key Differences from H.264/H.265\r\n//!\r\n//! - No start codes; uses length-prefixed OBUs\r\n//! - OBU header is 1-2 bytes (has_extension flag)\r\n//! - Sizes use LEB128 variable-length encoding\r\n//! - Configuration box is `av1C`\r\n//! - Keyframes are identified by `frame_type == KEY_FRAME` in header\r\n\r\n/// AV1 OBU type constants.\r\npub mod obu_type {\r\n    /// Sequence Header OBU\r\n    pub const SEQUENCE_HEADER: u8 = 1;\r\n    /// Temporal Delimiter OBU\r\n    pub const TEMPORAL_DELIMITER: u8 = 2;\r\n    /// Frame Header OBU\r\n    pub const FRAME_HEADER: u8 = 3;\r\n    /// Tile Group OBU\r\n    pub const TILE_GROUP: u8 = 4;\r\n    /// Metadata OBU\r\n    pub const METADATA: u8 = 5;\r\n    /// Frame OBU (contains header + tile data)\r\n    pub const FRAME: u8 = 6;\r\n    /// Redundant Frame Header OBU\r\n    pub const REDUNDANT_FRAME_HEADER: u8 = 7;\r\n    /// Tile List OBU\r\n    pub const TILE_LIST: u8 = 8;\r\n    /// Padding OBU\r\n    pub const PADDING: u8 = 15;\r\n}\r\n\r\n/// AV1 frame types.\r\npub mod frame_type {\r\n    /// Key frame\r\n    pub const KEY_FRAME: u8 = 0;\r\n    /// Inter frame\r\n    pub const INTER_FRAME: u8 = 1;\r\n    /// Intra-only frame\r\n    pub const INTRA_ONLY_FRAME: u8 = 2;\r\n    /// Switch frame\r\n    pub const SWITCH_FRAME: u8 = 3;\r\n}\r\n\r\n/// AV1 codec configuration.\r\n///\r\n/// Contains the Sequence Header OBU and derived configuration\r\n/// needed to build the av1C box in MP4 containers.\r\n#[derive(Debug, Clone, PartialEq, Eq)]\r\npub struct Av1Config {\r\n    /// Raw Sequence Header OBU bytes (including OBU header)\r\n    pub sequence_header: Vec<u8>,\r\n    /// seq_profile (0-2)\r\n    pub seq_profile: u8,\r\n    /// seq_level_idx\r\n    pub seq_level_idx: u8,\r\n    /// seq_tier (0 or 1)\r\n    pub seq_tier: u8,\r\n    /// high_bitdepth flag\r\n    pub high_bitdepth: bool,\r\n    /// twelve_bit flag (only valid when high_bitdepth is true)\r\n    pub twelve_bit: bool,\r\n    /// monochrome flag\r\n    pub monochrome: bool,\r\n    /// chroma_subsampling_x\r\n    pub chroma_subsampling_x: bool,\r\n    /// chroma_subsampling_y\r\n    pub chroma_subsampling_y: bool,\r\n    /// chroma_sample_position\r\n    pub chroma_sample_position: u8,\r\n}\r\n\r\nimpl Default for Av1Config {\r\n    fn default() -> Self {\r\n        Self {\r\n            sequence_header: Vec::new(),\r\n            seq_profile: 0,\r\n            seq_level_idx: 0,\r\n            seq_tier: 0,\r\n            high_bitdepth: false,\r\n            twelve_bit: false,\r\n            monochrome: false,\r\n            chroma_subsampling_x: true,\r\n            chroma_subsampling_y: true,\r\n            chroma_sample_position: 0,\r\n        }\r\n    }\r\n}\r\n\r\n/// Extract the OBU type from an OBU header byte.\r\n///\r\n/// OBU type is in bits 3-6 of the first byte:\r\n/// `(obu_header >> 3) & 0x0f`\r\n#[inline]\r\npub fn obu_type(header_byte: u8) -> u8 {\r\n    (header_byte >> 3) & 0x0f\r\n}\r\n\r\n/// Check if the OBU header has an extension byte.\r\n#[inline]\r\npub fn obu_has_extension(header_byte: u8) -> bool {\r\n    (header_byte & 0x04) != 0\r\n}\r\n\r\n/// Check if the OBU has a size field.\r\n#[inline]\r\npub fn obu_has_size(header_byte: u8) -> bool {\r\n    (header_byte & 0x02) != 0\r\n}\r\n\r\n/// Read a LEB128 (Little Endian Base 128) encoded unsigned integer.\r\n///\r\n/// Returns (value, bytes_consumed) or None if invalid.\r\npub fn read_leb128(data: &[u8]) -> Option<(u64, usize)> {\r\n    let mut value: u64 = 0;\r\n    let mut shift = 0;\r\n    \r\n    for (i, &byte) in data.iter().take(8).enumerate() {\r\n        value |= ((byte & 0x7F) as u64) << shift;\r\n        if (byte & 0x80) == 0 {\r\n            return Some((value, i + 1));\r\n        }\r\n        shift += 7;\r\n    }\r\n    None\r\n}\r\n\r\n/// Information about a parsed OBU.\r\n#[derive(Debug, Clone)]\r\npub struct ObuInfo {\r\n    /// OBU type\r\n    pub obu_type: u8,\r\n    /// Has extension header\r\n    pub has_extension: bool,\r\n    /// Size of header (1 or 2 bytes)\r\n    pub header_size: usize,\r\n    /// Size of payload (excluding header)\r\n    pub payload_size: usize,\r\n    /// Total size (header + payload)\r\n    pub total_size: usize,\r\n}\r\n\r\n/// Parse an OBU header and return info about the OBU.\r\n///\r\n/// Returns (ObuInfo, header_end_offset) or None if invalid.\r\npub fn parse_obu_header(data: &[u8]) -> Option<ObuInfo> {\r\n    if data.is_empty() {\r\n        return None;\r\n    }\r\n\r\n    let header_byte = data[0];\r\n    \r\n    // Check forbidden bit (must be 0)\r\n    if (header_byte & 0x80) != 0 {\r\n        return None;\r\n    }\r\n\r\n    let obu_type_val = obu_type(header_byte);\r\n    let has_extension = obu_has_extension(header_byte);\r\n    let has_size = obu_has_size(header_byte);\r\n\r\n    let mut header_size = 1;\r\n    \r\n    // Skip extension byte if present\r\n    if has_extension {\r\n        if data.len() < 2 {\r\n            return None;\r\n        }\r\n        header_size = 2;\r\n    }\r\n\r\n    // Parse size if present\r\n    let payload_size = if has_size {\r\n        if data.len() <= header_size {\r\n            return None;\r\n        }\r\n        let (size, leb_len) = read_leb128(&data[header_size..])?;\r\n        header_size += leb_len;\r\n        size as usize\r\n    } else {\r\n        // Without size field, OBU extends to end of data\r\n        data.len().saturating_sub(header_size)\r\n    };\r\n\r\n    Some(ObuInfo {\r\n        obu_type: obu_type_val,\r\n        has_extension,\r\n        header_size,\r\n        payload_size,\r\n        total_size: header_size + payload_size,\r\n    })\r\n}\r\n\r\n/// Iterator over OBUs in AV1 bitstream data.\r\npub struct ObuIter<'a> {\r\n    data: &'a [u8],\r\n    pos: usize,\r\n}\r\n\r\nimpl<'a> ObuIter<'a> {\r\n    pub fn new(data: &'a [u8]) -> Self {\r\n        Self { data, pos: 0 }\r\n    }\r\n}\r\n\r\nimpl<'a> Iterator for ObuIter<'a> {\r\n    type Item = (ObuInfo, &'a [u8]);\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        if self.pos >= self.data.len() {\r\n            return None;\r\n        }\r\n\r\n        let remaining = &self.data[self.pos..];\r\n        let info = parse_obu_header(remaining)?;\r\n        \r\n        if self.pos + info.total_size > self.data.len() {\r\n            return None;\r\n        }\r\n\r\n        let obu_data = &remaining[..info.total_size];\r\n        self.pos += info.total_size;\r\n        Some((info, obu_data))\r\n    }\r\n}\r\n\r\n/// Extract AV1 configuration from bitstream data.\r\n///\r\n/// Searches for the Sequence Header OBU and extracts configuration.\r\npub fn extract_av1_config(data: &[u8]) -> Option<Av1Config> {\r\n    for (info, obu_data) in ObuIter::new(data) {\r\n        if info.obu_type == obu_type::SEQUENCE_HEADER {\r\n            return parse_sequence_header(obu_data, info.header_size);\r\n        }\r\n    }\r\n    None\r\n}\r\n\r\n/// Parse the Sequence Header OBU payload to extract configuration.\r\nfn parse_sequence_header(obu_data: &[u8], header_size: usize) -> Option<Av1Config> {\r\n    let payload = &obu_data[header_size..];\r\n    if payload.is_empty() {\r\n        return None;\r\n    }\r\n\r\n    // Create a bit reader for the payload\r\n    let mut reader = BitReader::new(payload);\r\n\r\n    // seq_profile: 3 bits\r\n    let seq_profile = reader.read_bits(3)? as u8;\r\n\r\n    // still_picture: 1 bit\r\n    let _still_picture = reader.read_bit()?;\r\n\r\n    // reduced_still_picture_header: 1 bit\r\n    let reduced_still_picture_header = reader.read_bit()?;\r\n\r\n    let (seq_level_idx, seq_tier) = if reduced_still_picture_header {\r\n        // seq_level_idx[0]: 5 bits\r\n        (reader.read_bits(5)? as u8, 0u8)\r\n    } else {\r\n        // timing_info_present_flag: 1 bit\r\n        let timing_info_present = reader.read_bit()?;\r\n        if timing_info_present {\r\n            // Skip timing_info\r\n            reader.skip_bits(32)?; // num_units_in_display_tick\r\n            reader.skip_bits(32)?; // time_scale\r\n            let equal_picture_interval = reader.read_bit()?;\r\n            if equal_picture_interval {\r\n                // Skip num_ticks_per_picture_minus_1 (uvlc)\r\n                skip_uvlc(&mut reader)?;\r\n            }\r\n        }\r\n\r\n        // decoder_model_info_present_flag: 1 bit\r\n        let decoder_model_info_present = reader.read_bit()?;\r\n        let mut buffer_delay_length = 0;\r\n        if decoder_model_info_present {\r\n            buffer_delay_length = reader.read_bits(5)? as u8 + 1;\r\n            reader.skip_bits(32)?; // num_units_in_decoding_tick\r\n            reader.skip_bits(5)?;  // buffer_removal_time_length\r\n            reader.skip_bits(5)?;  // frame_presentation_time_length\r\n        }\r\n\r\n        // initial_display_delay_present_flag: 1 bit\r\n        let initial_display_delay_present = reader.read_bit()?;\r\n\r\n        // operating_points_cnt_minus_1: 5 bits\r\n        let op_cnt = reader.read_bits(5)? as usize + 1;\r\n        \r\n        let mut first_seq_level_idx = 0u8;\r\n        let mut first_seq_tier = 0u8;\r\n        \r\n        for i in 0..op_cnt {\r\n            reader.skip_bits(12)?; // operating_point_idc\r\n            let level_idx = reader.read_bits(5)? as u8;\r\n            let tier = if level_idx > 7 {\r\n                reader.read_bit()? as u8\r\n            } else {\r\n                0\r\n            };\r\n            if i == 0 {\r\n                first_seq_level_idx = level_idx;\r\n                first_seq_tier = tier;\r\n            }\r\n            if decoder_model_info_present {\r\n                let decoder_model_present = reader.read_bit()?;\r\n                if decoder_model_present {\r\n                    reader.skip_bits(buffer_delay_length as usize)?; // decoder_buffer_delay\r\n                    reader.skip_bits(buffer_delay_length as usize)?; // encoder_buffer_delay\r\n                    reader.read_bit()?; // low_delay_mode_flag\r\n                }\r\n            }\r\n            if initial_display_delay_present {\r\n                let display_delay_present = reader.read_bit()?;\r\n                if display_delay_present {\r\n                    reader.skip_bits(4)?; // initial_display_delay_minus_1\r\n                }\r\n            }\r\n        }\r\n        (first_seq_level_idx, first_seq_tier)\r\n    };\r\n\r\n    // frame_width_bits_minus_1: 4 bits\r\n    let frame_width_bits = reader.read_bits(4)? as usize + 1;\r\n    // frame_height_bits_minus_1: 4 bits\r\n    let frame_height_bits = reader.read_bits(4)? as usize + 1;\r\n    // max_frame_width_minus_1\r\n    let _max_width = reader.read_bits(frame_width_bits)? + 1;\r\n    // max_frame_height_minus_1\r\n    let _max_height = reader.read_bits(frame_height_bits)? + 1;\r\n\r\n    // For reduced_still_picture_header, frame_id is not present\r\n    let mut frame_id_length = 0;\r\n    if !reduced_still_picture_header {\r\n        let frame_id_numbers_present = reader.read_bit()?;\r\n        if frame_id_numbers_present {\r\n            let delta_frame_id_length = reader.read_bits(4)? as usize + 2;\r\n            frame_id_length = reader.read_bits(3)? as usize + delta_frame_id_length + 1;\r\n            let _ = frame_id_length; // Used later for frame parsing\r\n        }\r\n    }\r\n\r\n    // use_128x128_superblock: 1 bit\r\n    reader.read_bit()?;\r\n    // enable_filter_intra: 1 bit\r\n    reader.read_bit()?;\r\n    // enable_intra_edge_filter: 1 bit\r\n    reader.read_bit()?;\r\n\r\n    // More flags for non-reduced headers\r\n    if !reduced_still_picture_header {\r\n        // enable_interintra_compound: 1 bit\r\n        reader.read_bit()?;\r\n        // enable_masked_compound: 1 bit\r\n        reader.read_bit()?;\r\n        // enable_warped_motion: 1 bit\r\n        reader.read_bit()?;\r\n        // enable_dual_filter: 1 bit\r\n        reader.read_bit()?;\r\n        // enable_order_hint: 1 bit\r\n        let enable_order_hint = reader.read_bit()?;\r\n        if enable_order_hint {\r\n            // enable_jnt_comp: 1 bit\r\n            reader.read_bit()?;\r\n            // enable_ref_frame_mvs: 1 bit\r\n            reader.read_bit()?;\r\n        }\r\n        // seq_choose_screen_content_tools: 1 bit\r\n        let seq_choose_screen_content_tools = reader.read_bit()?;\r\n        let seq_force_screen_content_tools = if seq_choose_screen_content_tools {\r\n            2 // SELECT_SCREEN_CONTENT_TOOLS\r\n        } else {\r\n            reader.read_bit()? as u8\r\n        };\r\n        if seq_force_screen_content_tools > 0 {\r\n            // seq_choose_integer_mv: 1 bit\r\n            let seq_choose_integer_mv = reader.read_bit()?;\r\n            if !seq_choose_integer_mv {\r\n                // seq_force_integer_mv: 1 bit\r\n                reader.read_bit()?;\r\n            }\r\n        }\r\n        if enable_order_hint {\r\n            // order_hint_bits_minus_1: 3 bits\r\n            reader.skip_bits(3)?;\r\n        }\r\n    }\r\n\r\n    // enable_superres: 1 bit\r\n    reader.read_bit()?;\r\n    // enable_cdef: 1 bit\r\n    reader.read_bit()?;\r\n    // enable_restoration: 1 bit\r\n    reader.read_bit()?;\r\n\r\n    // color_config\r\n    let (high_bitdepth, twelve_bit, monochrome, chroma_subsampling_x, chroma_subsampling_y, chroma_sample_position) = parse_color_config(&mut reader, seq_profile)?;\r\n\r\n    // film_grain_params_present: 1 bit\r\n    reader.read_bit()?;\r\n\r\n    Some(Av1Config {\r\n        sequence_header: obu_data.to_vec(),\r\n        seq_profile,\r\n        seq_level_idx,\r\n        seq_tier,\r\n        high_bitdepth,\r\n        twelve_bit,\r\n        monochrome,\r\n        chroma_subsampling_x,\r\n        chroma_subsampling_y,\r\n        chroma_sample_position,\r\n    })\r\n}\r\n\r\n/// Parse color_config from sequence header.\r\nfn parse_color_config(reader: &mut BitReader, seq_profile: u8) -> Option<(bool, bool, bool, bool, bool, u8)> {\r\n    // high_bitdepth: 1 bit\r\n    let high_bitdepth = reader.read_bit()?;\r\n    \r\n    let twelve_bit = if seq_profile == 2 && high_bitdepth {\r\n        reader.read_bit()?\r\n    } else {\r\n        false\r\n    };\r\n\r\n    let bit_depth = if seq_profile == 2 && twelve_bit {\r\n        12\r\n    } else if high_bitdepth {\r\n        10\r\n    } else {\r\n        8\r\n    };\r\n\r\n    let monochrome = if seq_profile == 1 {\r\n        false\r\n    } else {\r\n        reader.read_bit()?\r\n    };\r\n\r\n    // color_description_present_flag: 1 bit\r\n    let color_description_present = reader.read_bit()?;\r\n    let (color_primaries, transfer_characteristics, matrix_coefficients) = if color_description_present {\r\n        let cp = reader.read_bits(8)? as u8;\r\n        let tc = reader.read_bits(8)? as u8;\r\n        let mc = reader.read_bits(8)? as u8;\r\n        (cp, tc, mc)\r\n    } else {\r\n        (2, 2, 2) // Unspecified\r\n    };\r\n\r\n    let (chroma_subsampling_x, chroma_subsampling_y, chroma_sample_position) = if monochrome {\r\n        // color_range: 1 bit\r\n        reader.read_bit()?;\r\n        (true, true, 0)\r\n    } else if color_primaries == 1 && transfer_characteristics == 13 && matrix_coefficients == 0 {\r\n        // sRGB/sYCC\r\n        (false, false, 0)\r\n    } else {\r\n        // color_range: 1 bit\r\n        reader.read_bit()?;\r\n        \r\n        if seq_profile == 0 {\r\n            (true, true, 0)\r\n        } else if seq_profile == 1 {\r\n            (false, false, 0)\r\n        } else {\r\n            if bit_depth == 12 {\r\n                let subsampling_x = reader.read_bit()?;\r\n                let subsampling_y = if subsampling_x {\r\n                    reader.read_bit()?\r\n                } else {\r\n                    false\r\n                };\r\n                (subsampling_x, subsampling_y, 0)\r\n            } else {\r\n                (true, false, 0)\r\n            }\r\n        }\r\n    };\r\n\r\n    let chroma_sample_position = if chroma_subsampling_x && chroma_subsampling_y {\r\n        reader.read_bits(2)? as u8\r\n    } else {\r\n        0\r\n    };\r\n\r\n    // separate_uv_delta_q: 1 bit (if not monochrome)\r\n    if !monochrome {\r\n        reader.read_bit()?;\r\n    }\r\n\r\n    Some((high_bitdepth, twelve_bit, monochrome, chroma_subsampling_x, chroma_subsampling_y, chroma_sample_position))\r\n}\r\n\r\n/// Skip a uvlc (unsigned variable length code) value.\r\nfn skip_uvlc(reader: &mut BitReader) -> Option<()> {\r\n    let mut leading_zeros = 0;\r\n    while !reader.read_bit()? {\r\n        leading_zeros += 1;\r\n        if leading_zeros > 32 {\r\n            return None;\r\n        }\r\n    }\r\n    if leading_zeros > 0 {\r\n        reader.skip_bits(leading_zeros)?;\r\n    }\r\n    Some(())\r\n}\r\n\r\n/// Simple bit reader for parsing AV1 bitstream.\r\nstruct BitReader<'a> {\r\n    data: &'a [u8],\r\n    byte_pos: usize,\r\n    bit_pos: usize,\r\n}\r\n\r\nimpl<'a> BitReader<'a> {\r\n    fn new(data: &'a [u8]) -> Self {\r\n        Self {\r\n            data,\r\n            byte_pos: 0,\r\n            bit_pos: 0,\r\n        }\r\n    }\r\n\r\n    fn read_bit(&mut self) -> Option<bool> {\r\n        if self.byte_pos >= self.data.len() {\r\n            return None;\r\n        }\r\n        let bit = (self.data[self.byte_pos] >> (7 - self.bit_pos)) & 1;\r\n        self.bit_pos += 1;\r\n        if self.bit_pos == 8 {\r\n            self.bit_pos = 0;\r\n            self.byte_pos += 1;\r\n        }\r\n        Some(bit != 0)\r\n    }\r\n\r\n    fn read_bits(&mut self, count: usize) -> Option<u64> {\r\n        if count > 64 {\r\n            return None;\r\n        }\r\n        let mut value = 0u64;\r\n        for _ in 0..count {\r\n            value = (value << 1) | (self.read_bit()? as u64);\r\n        }\r\n        Some(value)\r\n    }\r\n\r\n    fn skip_bits(&mut self, count: usize) -> Option<()> {\r\n        for _ in 0..count {\r\n            self.read_bit()?;\r\n        }\r\n        Some(())\r\n    }\r\n}\r\n\r\n/// Check if the given data contains an AV1 keyframe.\r\n///\r\n/// An AV1 keyframe is identified by a Frame or Frame Header OBU\r\n/// with frame_type == KEY_FRAME.\r\npub fn is_av1_keyframe(data: &[u8]) -> bool {\r\n    for (info, obu_data) in ObuIter::new(data) {\r\n        if info.obu_type == obu_type::FRAME || info.obu_type == obu_type::FRAME_HEADER {\r\n            // Parse frame header to check frame_type\r\n            // First bit after header is show_existing_frame\r\n            let payload = &obu_data[info.header_size..];\r\n            if !payload.is_empty() {\r\n                let mut reader = BitReader::new(payload);\r\n                // show_existing_frame: 1 bit\r\n                if let Some(show_existing) = reader.read_bit() {\r\n                    if show_existing {\r\n                        // This shows an existing frame, not a new keyframe\r\n                        continue;\r\n                    }\r\n                    // frame_type: 2 bits\r\n                    if let Some(frame_type_val) = reader.read_bits(2) {\r\n                        if frame_type_val as u8 == frame_type::KEY_FRAME {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_obu_type_extraction() {\r\n        // OBU type 1 (Sequence Header): (1 << 3) = 8 = 0x08\r\n        let seq_header = 0x08;\r\n        assert_eq!(obu_type(seq_header), 1);\r\n\r\n        // OBU type 6 (Frame): (6 << 3) = 48 = 0x30\r\n        let frame = 0x30;\r\n        assert_eq!(obu_type(frame), 6);\r\n    }\r\n\r\n    #[test]\r\n    fn test_obu_flags() {\r\n        // OBU with extension: bit 2 set\r\n        let with_ext = 0x04;\r\n        assert!(obu_has_extension(with_ext));\r\n        assert!(!obu_has_extension(0x00));\r\n\r\n        // OBU with size: bit 1 set\r\n        let with_size = 0x02;\r\n        assert!(obu_has_size(with_size));\r\n        assert!(!obu_has_size(0x00));\r\n    }\r\n\r\n    #[test]\r\n    fn test_read_leb128() {\r\n        // Single byte: 0x00 = 0\r\n        assert_eq!(read_leb128(&[0x00]), Some((0, 1)));\r\n        \r\n        // Single byte: 0x7F = 127\r\n        assert_eq!(read_leb128(&[0x7F]), Some((127, 1)));\r\n        \r\n        // Two bytes: 0x80 0x01 = 128\r\n        assert_eq!(read_leb128(&[0x80, 0x01]), Some((128, 2)));\r\n        \r\n        // Two bytes: 0xFF 0x01 = 255\r\n        assert_eq!(read_leb128(&[0xFF, 0x01]), Some((255, 2)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_parse_obu_header() {\r\n        // Sequence Header with size = 5\r\n        // Header: 0x0A = OBU type 1, has_size=1\r\n        // Size: 0x05 (LEB128 = 5)\r\n        let data = [0x0A, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00];\r\n        let info = parse_obu_header(&data).unwrap();\r\n        assert_eq!(info.obu_type, 1);\r\n        assert!(!info.has_extension);\r\n        assert_eq!(info.header_size, 2);  // 1 byte header + 1 byte size\r\n        assert_eq!(info.payload_size, 5);\r\n        assert_eq!(info.total_size, 7);\r\n    }\r\n\r\n    #[test]\r\n    fn test_obu_iterator() {\r\n        // Two OBUs: Temporal Delimiter (empty) + Sequence Header (3 bytes)\r\n        // TD: 0x12 (type=2, has_size=1), 0x00 (size=0)\r\n        // SH: 0x0A (type=1, has_size=1), 0x03 (size=3), 0xAA, 0xBB, 0xCC\r\n        let data = [0x12, 0x00, 0x0A, 0x03, 0xAA, 0xBB, 0xCC];\r\n        let obus: Vec<_> = ObuIter::new(&data).collect();\r\n        \r\n        assert_eq!(obus.len(), 2);\r\n        assert_eq!(obus[0].0.obu_type, 2); // Temporal Delimiter\r\n        assert_eq!(obus[1].0.obu_type, 1); // Sequence Header\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_av1_keyframe() {\r\n        // Frame OBU with keyframe\r\n        // Header: 0x32 (type=6, has_size=1)\r\n        // Size: 0x02\r\n        // Payload: show_existing_frame=0, frame_type=0 (KEY_FRAME)\r\n        // First byte of payload: 0b0_00_xxxxx = 0x00 (show_existing=0, frame_type=00)\r\n        let keyframe = [0x32, 0x02, 0x00, 0x00];\r\n        assert!(is_av1_keyframe(&keyframe));\r\n\r\n        // Frame OBU with inter frame\r\n        // Payload: show_existing_frame=0, frame_type=1 (INTER_FRAME)\r\n        // First byte: 0b0_01_xxxxx = 0x20\r\n        let interframe = [0x32, 0x02, 0x20, 0x00];\r\n        assert!(!is_av1_keyframe(&interframe));\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_av1_config_empty() {\r\n        assert!(extract_av1_config(&[]).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_bit_reader() {\r\n        let data = [0b10110100, 0b01100011];\r\n        let mut reader = BitReader::new(&data);\r\n        \r\n        // Read first 4 bits: 1011 = 11\r\n        assert_eq!(reader.read_bits(4), Some(11));\r\n        // Read next 4 bits: 0100 = 4\r\n        assert_eq!(reader.read_bits(4), Some(4));\r\n        // Read next 2 bits: 01 = 1\r\n        assert_eq!(reader.read_bits(2), Some(1));\r\n    }\r\n}\r\n","traces":[{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":112,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":117,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":118,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":123,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":124,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":130,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":131,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":132,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":134,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":135,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":136,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":137,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":139,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":163,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":170,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":175,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":176,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":178,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":181,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":190,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":194,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":195,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":202,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":203,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":204,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":205,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":206,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":217,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":225,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":226,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":227,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":230,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":231,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":233,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":238,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":239,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":246,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":247,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":248,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":249,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":256,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":257,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":258,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":266,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":269,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":272,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":274,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":280,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":293,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":305,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":307,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":308,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":310,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":311,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":312,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":313,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":318,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":319,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":320,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":322,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":341,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":343,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":345,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":347,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":350,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":351,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":352,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":353,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":363,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":365,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":368,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":370,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":372,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":374,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":376,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":378,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":379,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":387,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":392,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":409,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":411,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":414,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":417,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":419,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":420,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":421,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":422,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":423,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":424,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":425,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":426,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":427,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":428,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":429,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":434,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":436,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":438,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":444,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":452,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":459,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":460,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":469,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":480,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":481,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":500,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":507,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":510,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":544,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":545,"address":[],"length":0,"stats":{"Line":11385099857992613888}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":11385099857992613888}},{"line":549,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":550,"address":[],"length":0,"stats":{"Line":6269010681299730432}},{"line":551,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":552,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":554,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":557,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":558,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":562,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":563,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":565,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":568,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":569,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":570,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":572,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":580,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":581,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":582,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":585,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":586,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":587,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":589,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":590,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":596,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":597,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":604,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":169,"coverable":243},{"path":["C:","\\","Users","micha","repos","muxide","src","codec","common.rs"],"content":"//! Common bitstream utilities for start code scanning.\r\n//!\r\n//! Provides shared infrastructure for parsing Annex B formatted bitstreams\r\n//! (H.264, H.265) which use start code delimiters.\r\n\r\n/// Iterator over NAL units in an Annex B bitstream.\r\n///\r\n/// Annex B uses start codes (`0x00 0x00 0x01` or `0x00 0x00 0x00 0x01`) to\r\n/// delimit NAL units. This iterator yields each NAL unit's payload without\r\n/// the start code prefix.\r\n///\r\n/// # Example\r\n///\r\n/// ```\r\n/// use muxide::codec::AnnexBNalIter;\r\n///\r\n/// // Two NAL units with 4-byte start codes\r\n/// let data = [\r\n///     0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1f,  // SPS\r\n///     0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x3c, 0x80,  // PPS\r\n/// ];\r\n///\r\n/// let nals: Vec<_> = AnnexBNalIter::new(&data).collect();\r\n/// assert_eq!(nals.len(), 2);\r\n/// assert_eq!(nals[0][0] & 0x1f, 7);  // SPS NAL type\r\n/// assert_eq!(nals[1][0] & 0x1f, 8);  // PPS NAL type\r\n/// ```\r\npub struct AnnexBNalIter<'a> {\r\n    data: &'a [u8],\r\n    cursor: usize,\r\n}\r\n\r\nimpl<'a> AnnexBNalIter<'a> {\r\n    /// Create a new iterator over NAL units in the given Annex B data.\r\n    #[inline]\r\n    pub fn new(data: &'a [u8]) -> Self {\r\n        Self { data, cursor: 0 }\r\n    }\r\n}\r\n\r\nimpl<'a> Iterator for AnnexBNalIter<'a> {\r\n    type Item = &'a [u8];\r\n\r\n    fn next(&mut self) -> Option<Self::Item> {\r\n        let (start_code_pos, start_code_len) = find_start_code(self.data, self.cursor)?;\r\n        let nal_start = start_code_pos + start_code_len;\r\n        \r\n        // Find the next start code (or end of data)\r\n        let nal_end = match find_start_code(self.data, nal_start) {\r\n            Some((next_pos, _)) => next_pos,\r\n            None => self.data.len(),\r\n        };\r\n        \r\n        self.cursor = nal_end;\r\n        Some(&self.data[nal_start..nal_end])\r\n    }\r\n}\r\n\r\n/// Find the next Annex B start code in the data starting from `from`.\r\n///\r\n/// Returns the position and length of the start code:\r\n/// - 4-byte: `0x00 0x00 0x00 0x01` (length = 4)\r\n/// - 3-byte: `0x00 0x00 0x01` (length = 3)\r\n///\r\n/// 4-byte start codes are checked first to avoid matching `0x00 0x00 0x01`\r\n/// within a `0x00 0x00 0x00 0x01` sequence.\r\n///\r\n/// # Returns\r\n///\r\n/// - `Some((position, length))` if a start code is found\r\n/// - `None` if no start code exists from `from` onwards\r\npub fn find_start_code(data: &[u8], from: usize) -> Option<(usize, usize)> {\r\n    if data.len() < 3 || from >= data.len() {\r\n        return None;\r\n    }\r\n\r\n    let mut i = from;\r\n    while i + 3 <= data.len() {\r\n        // Check 4-byte start code first\r\n        if i + 4 <= data.len()\r\n            && data[i] == 0\r\n            && data[i + 1] == 0\r\n            && data[i + 2] == 0\r\n            && data[i + 3] == 1\r\n        {\r\n            return Some((i, 4));\r\n        }\r\n        // Check 3-byte start code\r\n        if data[i] == 0 && data[i + 1] == 0 && data[i + 2] == 1 {\r\n            return Some((i, 3));\r\n        }\r\n        i += 1;\r\n    }\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_find_start_code_4byte() {\r\n        let data = [0x00, 0x00, 0x00, 0x01, 0x67];\r\n        assert_eq!(find_start_code(&data, 0), Some((0, 4)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_start_code_3byte() {\r\n        let data = [0x00, 0x00, 0x01, 0x67];\r\n        assert_eq!(find_start_code(&data, 0), Some((0, 3)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_start_code_offset() {\r\n        let data = [0xAB, 0xCD, 0x00, 0x00, 0x00, 0x01, 0x67];\r\n        assert_eq!(find_start_code(&data, 0), Some((2, 4)));\r\n        // When starting from position 3, we find the start code at position 3\r\n        // (this is the middle of a 4-byte start code, but also valid as 3-byte)\r\n        assert_eq!(find_start_code(&data, 3), Some((3, 3)));\r\n        assert_eq!(find_start_code(&data, 6), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_find_start_code_none() {\r\n        let data = [0x00, 0x00, 0x02, 0x67];\r\n        assert_eq!(find_start_code(&data, 0), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_annexb_iter_multiple_nals() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x67, 0x42,  // SPS (type 7)\r\n            0x00, 0x00, 0x00, 0x01, 0x68, 0xCE,  // PPS (type 8)\r\n            0x00, 0x00, 0x00, 0x01, 0x65, 0x88,  // IDR (type 5)\r\n        ];\r\n\r\n        let nals: Vec<_> = AnnexBNalIter::new(&data).collect();\r\n        assert_eq!(nals.len(), 3);\r\n        assert_eq!(nals[0], &[0x67, 0x42]);\r\n        assert_eq!(nals[1], &[0x68, 0xCE]);\r\n        assert_eq!(nals[2], &[0x65, 0x88]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_annexb_iter_empty() {\r\n        let data: [u8; 0] = [];\r\n        let nals: Vec<_> = AnnexBNalIter::new(&data).collect();\r\n        assert!(nals.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_annexb_iter_no_start_code() {\r\n        let data = [0x67, 0x42, 0x00, 0x1f];\r\n        let nals: Vec<_> = AnnexBNalIter::new(&data).collect();\r\n        assert!(nals.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_annexb_iter_mixed_start_codes() {\r\n        // Mix of 3-byte and 4-byte start codes\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x67, 0x42,  // 4-byte\r\n            0x00, 0x00, 0x01, 0x68, 0xCE,        // 3-byte\r\n        ];\r\n\r\n        let nals: Vec<_> = AnnexBNalIter::new(&data).collect();\r\n        assert_eq!(nals.len(), 2);\r\n        assert_eq!(nals[0], &[0x67, 0x42]);\r\n        assert_eq!(nals[1], &[0x68, 0xCE]);\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":9799832789158199296}},{"line":44,"address":[],"length":0,"stats":{"Line":7926335344172073076}},{"line":45,"address":[],"length":0,"stats":{"Line":14627691589699371339}},{"line":46,"address":[],"length":0,"stats":{"Line":2738188573441261302}},{"line":49,"address":[],"length":0,"stats":{"Line":4107282860161891953}},{"line":50,"address":[],"length":0,"stats":{"Line":8358680908399640792}},{"line":51,"address":[],"length":0,"stats":{"Line":12826251738751172126}},{"line":54,"address":[],"length":0,"stats":{"Line":1369094286720630651}},{"line":55,"address":[],"length":0,"stats":{"Line":2738188573441261302}},{"line":72,"address":[],"length":0,"stats":{"Line":9727775195120271392}},{"line":73,"address":[],"length":0,"stats":{"Line":10304235947423694162}},{"line":74,"address":[],"length":0,"stats":{"Line":6413125869375586695}},{"line":77,"address":[],"length":0,"stats":{"Line":9223372036854775096}},{"line":78,"address":[],"length":0,"stats":{"Line":4755801206503243992}},{"line":80,"address":[],"length":0,"stats":{"Line":9799832789158201398}},{"line":81,"address":[],"length":0,"stats":{"Line":8070450532247929775}},{"line":82,"address":[],"length":0,"stats":{"Line":6701356245527298881}},{"line":83,"address":[],"length":0,"stats":{"Line":16861477004875137229}},{"line":84,"address":[],"length":0,"stats":{"Line":14843864371813154997}},{"line":86,"address":[],"length":0,"stats":{"Line":14771806777775227053}},{"line":89,"address":[],"length":0,"stats":{"Line":1090}},{"line":90,"address":[],"length":0,"stats":{"Line":9223372036854776218}},{"line":92,"address":[],"length":0,"stats":{"Line":16573246628723425741}},{"line":94,"address":[],"length":0,"stats":{"Line":6701356245527297105}}],"covered":24,"coverable":24},{"path":["C:","\\","Users","micha","repos","muxide","src","codec","h264.rs"],"content":"//! H.264/AVC codec configuration extraction.\r\n//!\r\n//! Provides minimal NAL unit parsing to extract SPS (Sequence Parameter Set)\r\n//! and PPS (Picture Parameter Set) for building the avcC configuration box.\r\n//!\r\n//! # NAL Unit Types\r\n//!\r\n//! | Type | Name | Purpose |\r\n//! |------|------|---------|\r\n//! | 1 | Non-IDR slice | P/B frame data |\r\n//! | 5 | IDR slice | Keyframe (I-frame) |\r\n//! | 7 | SPS | Sequence Parameter Set |\r\n//! | 8 | PPS | Picture Parameter Set |\r\n//!\r\n//! # Input Format\r\n//!\r\n//! Input must be in Annex B format with start codes:\r\n//! ```text\r\n//! [0x00 0x00 0x00 0x01][NAL unit][0x00 0x00 0x00 0x01][NAL unit]...\r\n//! ```\r\n\r\nuse super::common::AnnexBNalIter;\r\n\r\n/// H.264 NAL unit type constants.\r\npub mod nal_type {\r\n    /// Non-IDR coded slice (P/B frame)\r\n    pub const NON_IDR_SLICE: u8 = 1;\r\n    /// IDR coded slice (keyframe)\r\n    pub const IDR_SLICE: u8 = 5;\r\n    /// Sequence Parameter Set\r\n    pub const SPS: u8 = 7;\r\n    /// Picture Parameter Set\r\n    pub const PPS: u8 = 8;\r\n}\r\n\r\n/// AVC (H.264) codec configuration extracted from NAL units.\r\n///\r\n/// Contains the raw SPS and PPS NAL units needed to build the\r\n/// avcC box in MP4 containers.\r\n#[derive(Debug, Clone, PartialEq, Eq)]\r\npub struct AvcConfig {\r\n    /// Sequence Parameter Set NAL unit (without start code)\r\n    pub sps: Vec<u8>,\r\n    /// Picture Parameter Set NAL unit (without start code)\r\n    pub pps: Vec<u8>,\r\n}\r\n\r\nimpl AvcConfig {\r\n    /// Create a new AVC configuration from SPS and PPS data.\r\n    pub fn new(sps: Vec<u8>, pps: Vec<u8>) -> Self {\r\n        Self { sps, pps }\r\n    }\r\n\r\n    /// Extract profile_idc from the SPS.\r\n    ///\r\n    /// Profile indicates the feature set (Baseline=66, Main=77, High=100).\r\n    pub fn profile_idc(&self) -> u8 {\r\n        self.sps.get(1).copied().unwrap_or(66)\r\n    }\r\n\r\n    /// Extract profile_compatibility flags from the SPS.\r\n    pub fn profile_compatibility(&self) -> u8 {\r\n        self.sps.get(2).copied().unwrap_or(0)\r\n    }\r\n\r\n    /// Extract level_idc from the SPS.\r\n    ///\r\n    /// Level indicates max bitrate/resolution (31 = level 3.1 = 720p30).\r\n    pub fn level_idc(&self) -> u8 {\r\n        self.sps.get(3).copied().unwrap_or(31)\r\n    }\r\n}\r\n\r\n/// Default SPS for 640x480 @ Baseline Profile, Level 3.0.\r\n///\r\n/// Used as fallback when no SPS is provided in the stream.\r\n/// Matches the original Muxide default for backwards compatibility.\r\npub const DEFAULT_SPS: &[u8] = &[\r\n    0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11,\r\n];\r\n\r\n/// Default PPS.\r\n///\r\n/// Used as fallback when no PPS is provided in the stream.\r\n/// Matches the original Muxide default for backwards compatibility.\r\npub const DEFAULT_PPS: &[u8] = &[0x68, 0xce, 0x38, 0x80];\r\n\r\n/// Extract AVC configuration (SPS/PPS) from an Annex B keyframe.\r\n///\r\n/// Scans the NAL units in the provided data and extracts the first\r\n/// SPS (type 7) and PPS (type 8) found.\r\n///\r\n/// # Arguments\r\n///\r\n/// * `data` - Annex B formatted data containing at least one keyframe\r\n///\r\n/// # Returns\r\n///\r\n/// - `Some(AvcConfig)` if both SPS and PPS are found\r\n/// - `None` if either SPS or PPS is missing\r\n///\r\n/// # Example\r\n///\r\n/// ```\r\n/// use muxide::codec::h264::extract_avc_config;\r\n///\r\n/// let keyframe = [\r\n///     0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00, 0x1f,  // SPS\r\n///     0x00, 0x00, 0x00, 0x01, 0x68, 0xeb, 0xe3, 0xcb,  // PPS\r\n///     0x00, 0x00, 0x00, 0x01, 0x65, 0x88, 0x84, 0x00,  // IDR slice\r\n/// ];\r\n///\r\n/// let config = extract_avc_config(&keyframe).expect(\"should have config\");\r\n/// assert_eq!(config.sps[0] & 0x1f, 7);  // SPS NAL type\r\n/// assert_eq!(config.pps[0] & 0x1f, 8);  // PPS NAL type\r\n/// ```\r\npub fn extract_avc_config(data: &[u8]) -> Option<AvcConfig> {\r\n    let mut sps: Option<&[u8]> = None;\r\n    let mut pps: Option<&[u8]> = None;\r\n\r\n    for nal in AnnexBNalIter::new(data) {\r\n        if nal.is_empty() {\r\n            continue;\r\n        }\r\n        \r\n        let nal_type = nal[0] & 0x1f;\r\n        \r\n        if nal_type == nal_type::SPS && sps.is_none() {\r\n            sps = Some(nal);\r\n        } else if nal_type == nal_type::PPS && pps.is_none() {\r\n            pps = Some(nal);\r\n        }\r\n        \r\n        // Early exit once we have both\r\n        if sps.is_some() && pps.is_some() {\r\n            break;\r\n        }\r\n    }\r\n\r\n    Some(AvcConfig {\r\n        sps: sps?.to_vec(),\r\n        pps: pps?.to_vec(),\r\n    })\r\n}\r\n\r\n/// Create a default AVC configuration for testing/fallback.\r\n///\r\n/// Returns a valid configuration for 1080p @ High Profile, Level 4.0.\r\npub fn default_avc_config() -> AvcConfig {\r\n    AvcConfig {\r\n        sps: DEFAULT_SPS.to_vec(),\r\n        pps: DEFAULT_PPS.to_vec(),\r\n    }\r\n}\r\n\r\n/// Convert Annex B formatted data to AVCC (length-prefixed) format.\r\n///\r\n/// MP4 containers use AVCC format where each NAL unit is prefixed with\r\n/// its length as a 4-byte big-endian integer, rather than start codes.\r\n///\r\n/// # Arguments\r\n///\r\n/// * `data` - Annex B formatted data with start codes\r\n///\r\n/// # Returns\r\n///\r\n/// AVCC formatted data with 4-byte length prefixes.\r\n///\r\n/// # Example\r\n///\r\n/// ```\r\n/// use muxide::codec::h264::annexb_to_avcc;\r\n///\r\n/// let annexb = [\r\n///     0x00, 0x00, 0x00, 0x01, 0x65, 0x88, 0x84,  // NAL with start code\r\n/// ];\r\n///\r\n/// let avcc = annexb_to_avcc(&annexb);\r\n/// // Result: [0x00, 0x00, 0x00, 0x03, 0x65, 0x88, 0x84]\r\n/// //          ^--- 4-byte length (3)     ^--- NAL data\r\n/// ```\r\npub fn annexb_to_avcc(data: &[u8]) -> Vec<u8> {\r\n    let mut out = Vec::new();\r\n    \r\n    for nal in AnnexBNalIter::new(data) {\r\n        if nal.is_empty() {\r\n            continue;\r\n        }\r\n        let len = nal.len() as u32;\r\n        out.extend_from_slice(&len.to_be_bytes());\r\n        out.extend_from_slice(nal);\r\n    }\r\n\r\n    // Fallback: if no start codes found, treat entire input as single NAL\r\n    if out.is_empty() && !data.is_empty() {\r\n        let len = data.len() as u32;\r\n        out.extend_from_slice(&len.to_be_bytes());\r\n        out.extend_from_slice(data);\r\n    }\r\n\r\n    out\r\n}\r\n\r\n/// Check if the given Annex B data represents a keyframe (IDR slice).\r\n///\r\n/// A keyframe is identified by the presence of an IDR slice NAL unit (type 5).\r\n///\r\n/// # Arguments\r\n///\r\n/// * `data` - Annex B formatted frame data\r\n///\r\n/// # Returns\r\n///\r\n/// `true` if the data contains an IDR slice, `false` otherwise.\r\npub fn is_h264_keyframe(data: &[u8]) -> bool {\r\n    for nal in AnnexBNalIter::new(data) {\r\n        if nal.is_empty() {\r\n            continue;\r\n        }\r\n        let nal_type = nal[0] & 0x1f;\r\n        if nal_type == nal_type::IDR_SLICE {\r\n            return true;\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_extract_avc_config_success() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00, 0x1f,  // SPS (type 7)\r\n            0x00, 0x00, 0x00, 0x01, 0x68, 0xeb, 0xe3, 0xcb,  // PPS (type 8)\r\n            0x00, 0x00, 0x00, 0x01, 0x65, 0x88, 0x84, 0x00,  // IDR (type 5)\r\n        ];\r\n\r\n        let config = extract_avc_config(&data).unwrap();\r\n        assert_eq!(config.sps, &[0x67, 0x64, 0x00, 0x1f]);\r\n        assert_eq!(config.pps, &[0x68, 0xeb, 0xe3, 0xcb]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_avc_config_missing_sps() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x68, 0xeb, 0xe3, 0xcb,  // PPS only\r\n        ];\r\n        assert!(extract_avc_config(&data).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_avc_config_missing_pps() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00, 0x1f,  // SPS only\r\n        ];\r\n        assert!(extract_avc_config(&data).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_avc_config_accessors() {\r\n        let config = AvcConfig::new(\r\n            vec![0x67, 0x64, 0x00, 0x28],  // High profile, level 4.0\r\n            vec![0x68, 0xeb],\r\n        );\r\n        \r\n        assert_eq!(config.profile_idc(), 0x64);  // 100 = High\r\n        assert_eq!(config.profile_compatibility(), 0x00);\r\n        assert_eq!(config.level_idc(), 0x28);    // 40 = Level 4.0\r\n    }\r\n\r\n    #[test]\r\n    fn test_annexb_to_avcc() {\r\n        let annexb = [\r\n            0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00,  // SPS (3 bytes)\r\n            0x00, 0x00, 0x00, 0x01, 0x68, 0xeb,        // PPS (2 bytes)\r\n        ];\r\n\r\n        let avcc = annexb_to_avcc(&annexb);\r\n        \r\n        // First NAL: length 3 + data\r\n        assert_eq!(&avcc[0..4], &[0x00, 0x00, 0x00, 0x03]);\r\n        assert_eq!(&avcc[4..7], &[0x67, 0x64, 0x00]);\r\n        \r\n        // Second NAL: length 2 + data\r\n        assert_eq!(&avcc[7..11], &[0x00, 0x00, 0x00, 0x02]);\r\n        assert_eq!(&avcc[11..13], &[0x68, 0xeb]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_annexb_to_avcc_no_start_codes() {\r\n        // Data without start codes - treated as single NAL\r\n        let data = [0x65, 0x88, 0x84];\r\n        let avcc = annexb_to_avcc(&data);\r\n        \r\n        assert_eq!(&avcc[0..4], &[0x00, 0x00, 0x00, 0x03]);\r\n        assert_eq!(&avcc[4..7], &[0x65, 0x88, 0x84]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_keyframe_idr() {\r\n        let idr_frame = [\r\n            0x00, 0x00, 0x00, 0x01, 0x67, 0x64,  // SPS\r\n            0x00, 0x00, 0x00, 0x01, 0x65, 0x88,  // IDR (type 5)\r\n        ];\r\n        assert!(is_h264_keyframe(&idr_frame));\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_keyframe_non_idr() {\r\n        let p_frame = [\r\n            0x00, 0x00, 0x00, 0x01, 0x41, 0x9a,  // Non-IDR (type 1)\r\n        ];\r\n        assert!(!is_h264_keyframe(&p_frame));\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_keyframe_empty() {\r\n        assert!(!is_h264_keyframe(&[]));\r\n    }\r\n\r\n    #[test]\r\n    fn test_default_avc_config() {\r\n        let config = default_avc_config();\r\n        assert!(!config.sps.is_empty());\r\n        assert!(!config.pps.is_empty());\r\n        assert_eq!(config.sps[0] & 0x1f, nal_type::SPS);\r\n        assert_eq!(config.pps[0] & 0x1f, nal_type::PPS);\r\n    }\r\n}\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":63,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":118,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":119,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":121,"address":[],"length":0,"stats":{"Line":12898309332789100552}},{"line":122,"address":[],"length":0,"stats":{"Line":12538021362599460880}},{"line":123,"address":[],"length":0,"stats":{"Line":18446744073709551608}},{"line":126,"address":[],"length":0,"stats":{"Line":12538021362599460896}},{"line":128,"address":[],"length":0,"stats":{"Line":15348267530078650424}},{"line":129,"address":[],"length":0,"stats":{"Line":3026418949592973320}},{"line":130,"address":[],"length":0,"stats":{"Line":15348267530078650392}},{"line":131,"address":[],"length":0,"stats":{"Line":3026418949592973320}},{"line":135,"address":[],"length":0,"stats":{"Line":6052837899185946672}},{"line":136,"address":[],"length":0,"stats":{"Line":2954361355555045368}},{"line":141,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":142,"address":[],"length":0,"stats":{"Line":6052837899185946592}},{"line":149,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":151,"address":[],"length":0,"stats":{"Line":648518346341351448}},{"line":152,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":182,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":183,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":185,"address":[],"length":0,"stats":{"Line":3098476543630901356}},{"line":186,"address":[],"length":0,"stats":{"Line":4179340454199820504}},{"line":187,"address":[],"length":0,"stats":{"Line":233}},{"line":189,"address":[],"length":0,"stats":{"Line":4179340454199820038}},{"line":190,"address":[],"length":0,"stats":{"Line":15492382718154505865}},{"line":191,"address":[],"length":0,"stats":{"Line":15492382718154505865}},{"line":195,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":196,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":197,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":198,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":201,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":215,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":216,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":217,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":221,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":222,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":225,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":45,"coverable":46},{"path":["C:","\\","Users","micha","repos","muxide","src","codec","h265.rs"],"content":"//! H.265/HEVC codec configuration extraction.\r\n//!\r\n//! Provides NAL unit parsing to extract VPS, SPS, and PPS for building\r\n//! the hvcC configuration box in MP4 containers.\r\n//!\r\n//! # NAL Unit Types (HEVC)\r\n//!\r\n//! | Type | Name | Purpose |\r\n//! |------|------|---------|\r\n//! | 0-9 | VCL | Coded slice segments |\r\n//! | 16-18 | BLA | Broken Link Access |\r\n//! | 19 | IDR_W_RADL | IDR with RADL pictures |\r\n//! | 20 | IDR_N_LP | IDR without leading pictures |\r\n//! | 21 | CRA | Clean Random Access |\r\n//! | 32 | VPS | Video Parameter Set |\r\n//! | 33 | SPS | Sequence Parameter Set |\r\n//! | 34 | PPS | Picture Parameter Set |\r\n//!\r\n//! # Differences from H.264\r\n//!\r\n//! - NAL header is 2 bytes (vs 1 byte in H.264)\r\n//! - NAL type is in bits 1-6 of the first byte: `(byte0 >> 1) & 0x3f`\r\n//! - Requires VPS in addition to SPS/PPS\r\n//! - Configuration box is `hvcC` instead of `avcC`\r\n//!\r\n//! # Input Format\r\n//!\r\n//! Input must be in Annex B format with start codes, same as H.264.\r\n\r\nuse super::common::AnnexBNalIter;\r\n\r\n/// H.265 NAL unit type constants.\r\npub mod nal_type {\r\n    /// Coded slice segment of a BLA picture\r\n    pub const BLA_W_LP: u8 = 16;\r\n    /// Coded slice segment of a BLA picture\r\n    pub const BLA_W_RADL: u8 = 17;\r\n    /// Coded slice segment of a BLA picture\r\n    pub const BLA_N_LP: u8 = 18;\r\n    /// IDR with RADL pictures\r\n    pub const IDR_W_RADL: u8 = 19;\r\n    /// IDR without leading pictures\r\n    pub const IDR_N_LP: u8 = 20;\r\n    /// Clean Random Access picture\r\n    pub const CRA_NUT: u8 = 21;\r\n    /// Video Parameter Set\r\n    pub const VPS: u8 = 32;\r\n    /// Sequence Parameter Set\r\n    pub const SPS: u8 = 33;\r\n    /// Picture Parameter Set\r\n    pub const PPS: u8 = 34;\r\n    /// Access unit delimiter\r\n    pub const AUD: u8 = 35;\r\n    /// End of sequence\r\n    pub const EOS: u8 = 36;\r\n    /// End of bitstream  \r\n    pub const EOB: u8 = 37;\r\n    /// Filler data\r\n    pub const FD: u8 = 38;\r\n    /// Supplemental enhancement information (prefix)\r\n    pub const PREFIX_SEI: u8 = 39;\r\n    /// Supplemental enhancement information (suffix)\r\n    pub const SUFFIX_SEI: u8 = 40;\r\n}\r\n\r\n/// HEVC (H.265) codec configuration.\r\n///\r\n/// Contains VPS, SPS, and PPS NAL units needed to build the\r\n/// hvcC box in MP4 containers.\r\n#[derive(Debug, Clone, PartialEq, Eq)]\r\npub struct HevcConfig {\r\n    /// Video Parameter Set NAL unit (without start code)\r\n    pub vps: Vec<u8>,\r\n    /// Sequence Parameter Set NAL unit (without start code)\r\n    pub sps: Vec<u8>,\r\n    /// Picture Parameter Set NAL unit (without start code)\r\n    pub pps: Vec<u8>,\r\n}\r\n\r\nimpl HevcConfig {\r\n    /// Create a new HEVC configuration from VPS, SPS, and PPS data.\r\n    pub fn new(vps: Vec<u8>, sps: Vec<u8>, pps: Vec<u8>) -> Self {\r\n        Self { vps, sps, pps }\r\n    }\r\n\r\n    /// Extract general_profile_space from the SPS (bits 0-1 of byte 3).\r\n    pub fn general_profile_space(&self) -> u8 {\r\n        self.sps.get(3).map(|b| (b >> 6) & 0x03).unwrap_or(0)\r\n    }\r\n\r\n    /// Extract general_tier_flag from the SPS (bit 2 of byte 3).\r\n    pub fn general_tier_flag(&self) -> bool {\r\n        self.sps.get(3).map(|b| (b >> 5) & 0x01 != 0).unwrap_or(false)\r\n    }\r\n\r\n    /// Extract general_profile_idc from the SPS (bits 3-7 of byte 3).\r\n    pub fn general_profile_idc(&self) -> u8 {\r\n        self.sps.get(3).map(|b| b & 0x1f).unwrap_or(1)\r\n    }\r\n\r\n    /// Extract general_level_idc from the SPS (byte 14).\r\n    /// Level 5.1 = 153, Level 4.0 = 120, Level 3.1 = 93\r\n    pub fn general_level_idc(&self) -> u8 {\r\n        self.sps.get(14).copied().unwrap_or(93)\r\n    }\r\n}\r\n\r\n/// Extract the NAL unit type from an H.265 NAL header.\r\n///\r\n/// H.265 NAL type is in bits 1-6 of the first byte:\r\n/// `(nal_header[0] >> 1) & 0x3f`\r\n#[inline]\r\npub fn hevc_nal_type(nal: &[u8]) -> u8 {\r\n    if nal.is_empty() {\r\n        return 0;\r\n    }\r\n    (nal[0] >> 1) & 0x3f\r\n}\r\n\r\n/// Check if the given NAL type represents a keyframe (IRAP).\r\n///\r\n/// HEVC has multiple IRAP (Intra Random Access Point) types:\r\n/// - BLA (16-18): Broken Link Access\r\n/// - IDR (19-20): Instantaneous Decoder Refresh\r\n/// - CRA (21): Clean Random Access\r\n#[inline]\r\npub fn is_hevc_keyframe_nal_type(nal_type: u8) -> bool {\r\n    matches!(nal_type, \r\n        nal_type::BLA_W_LP | nal_type::BLA_W_RADL | nal_type::BLA_N_LP |\r\n        nal_type::IDR_W_RADL | nal_type::IDR_N_LP | nal_type::CRA_NUT\r\n    )\r\n}\r\n\r\n/// Extract HEVC configuration (VPS/SPS/PPS) from Annex B keyframe data.\r\n///\r\n/// Scans the NAL units in the provided data and extracts the first\r\n/// VPS (type 32), SPS (type 33), and PPS (type 34) found.\r\n///\r\n/// # Arguments\r\n///\r\n/// * `data` - Annex B formatted data containing at least one keyframe\r\n///\r\n/// # Returns\r\n///\r\n/// - `Some(HevcConfig)` if VPS, SPS, and PPS are all found\r\n/// - `None` if any of the three is missing\r\n///\r\n/// # Example\r\n///\r\n/// ```\r\n/// use muxide::codec::h265::extract_hevc_config;\r\n///\r\n/// // Minimal HEVC keyframe with VPS, SPS, PPS, IDR\r\n/// let keyframe = [\r\n///     0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0c, 0x01,  // VPS (type 32)\r\n///     0x00, 0x00, 0x00, 0x01, 0x42, 0x01, 0x01, 0x01,  // SPS (type 33)\r\n///     0x00, 0x00, 0x00, 0x01, 0x44, 0x01, 0xc0, 0x73,  // PPS (type 34)\r\n///     0x00, 0x00, 0x00, 0x01, 0x26, 0x01, 0xaf, 0x00,  // IDR (type 19)\r\n/// ];\r\n///\r\n/// let config = extract_hevc_config(&keyframe).expect(\"should have config\");\r\n/// assert_eq!(config.vps[0] >> 1 & 0x3f, 32);  // VPS NAL type\r\n/// ```\r\npub fn extract_hevc_config(data: &[u8]) -> Option<HevcConfig> {\r\n    let mut vps: Option<&[u8]> = None;\r\n    let mut sps: Option<&[u8]> = None;\r\n    let mut pps: Option<&[u8]> = None;\r\n\r\n    for nal in AnnexBNalIter::new(data) {\r\n        if nal.is_empty() {\r\n            continue;\r\n        }\r\n        \r\n        let nal_type = hevc_nal_type(nal);\r\n        \r\n        match nal_type {\r\n            nal_type::VPS if vps.is_none() => vps = Some(nal),\r\n            nal_type::SPS if sps.is_none() => sps = Some(nal),\r\n            nal_type::PPS if pps.is_none() => pps = Some(nal),\r\n            _ => {}\r\n        }\r\n        \r\n        // Early exit once we have all three\r\n        if vps.is_some() && sps.is_some() && pps.is_some() {\r\n            break;\r\n        }\r\n    }\r\n\r\n    Some(HevcConfig {\r\n        vps: vps?.to_vec(),\r\n        sps: sps?.to_vec(),\r\n        pps: pps?.to_vec(),\r\n    })\r\n}\r\n\r\n/// Convert Annex B formatted HEVC data to hvcC format (length-prefixed).\r\n///\r\n/// Same conversion as H.264: replaces start codes with 4-byte NAL lengths.\r\npub fn hevc_annexb_to_hvcc(data: &[u8]) -> Vec<u8> {\r\n    let mut out = Vec::new();\r\n    \r\n    for nal in AnnexBNalIter::new(data) {\r\n        if nal.is_empty() {\r\n            continue;\r\n        }\r\n        let len = nal.len() as u32;\r\n        out.extend_from_slice(&len.to_be_bytes());\r\n        out.extend_from_slice(nal);\r\n    }\r\n\r\n    // Fallback: if no start codes found, treat entire input as single NAL\r\n    if out.is_empty() && !data.is_empty() {\r\n        let len = data.len() as u32;\r\n        out.extend_from_slice(&len.to_be_bytes());\r\n        out.extend_from_slice(data);\r\n    }\r\n\r\n    out\r\n}\r\n\r\n/// Check if the given Annex B data represents an HEVC keyframe (IRAP).\r\npub fn is_hevc_keyframe(data: &[u8]) -> bool {\r\n    for nal in AnnexBNalIter::new(data) {\r\n        if nal.is_empty() {\r\n            continue;\r\n        }\r\n        let nal_type = hevc_nal_type(nal);\r\n        if is_hevc_keyframe_nal_type(nal_type) {\r\n            return true;\r\n        }\r\n    }\r\n    false\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_hevc_nal_type_extraction() {\r\n        // VPS NAL: type 32, so first byte has (32 << 1) = 64 = 0x40\r\n        let vps_nal = [0x40, 0x01, 0x0c];\r\n        assert_eq!(hevc_nal_type(&vps_nal), 32);\r\n\r\n        // SPS NAL: type 33, so first byte has (33 << 1) = 66 = 0x42\r\n        let sps_nal = [0x42, 0x01, 0x01];\r\n        assert_eq!(hevc_nal_type(&sps_nal), 33);\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_hevc_keyframe_nal_type() {\r\n        // IRAP types should be keyframes\r\n        assert!(is_hevc_keyframe_nal_type(nal_type::IDR_W_RADL));\r\n        assert!(is_hevc_keyframe_nal_type(nal_type::IDR_N_LP));\r\n        assert!(is_hevc_keyframe_nal_type(nal_type::CRA_NUT));\r\n        assert!(is_hevc_keyframe_nal_type(nal_type::BLA_W_LP));\r\n        // Non-IRAP types\r\n        assert!(!is_hevc_keyframe_nal_type(nal_type::VPS));\r\n        assert!(!is_hevc_keyframe_nal_type(nal_type::SPS));\r\n        assert!(!is_hevc_keyframe_nal_type(nal_type::PPS));\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_hevc_config_empty() {\r\n        assert!(extract_hevc_config(&[]).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_hevc_config_success() {\r\n        // Minimal HEVC keyframe with VPS, SPS, PPS\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0c, 0x01,  // VPS (type 32)\r\n            0x00, 0x00, 0x00, 0x01, 0x42, 0x01, 0x01, 0x21,  // SPS (type 33)\r\n            0x00, 0x00, 0x00, 0x01, 0x44, 0x01, 0xc0, 0x73,  // PPS (type 34)\r\n        ];\r\n\r\n        let config = extract_hevc_config(&data).unwrap();\r\n        assert_eq!(hevc_nal_type(&config.vps), nal_type::VPS);\r\n        assert_eq!(hevc_nal_type(&config.sps), nal_type::SPS);\r\n        assert_eq!(hevc_nal_type(&config.pps), nal_type::PPS);\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_hevc_config_missing_vps() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x42, 0x01, 0x01, 0x21,  // SPS only\r\n            0x00, 0x00, 0x00, 0x01, 0x44, 0x01, 0xc0, 0x73,  // PPS\r\n        ];\r\n        assert!(extract_hevc_config(&data).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_hevc_config_missing_sps() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0c, 0x01,  // VPS only\r\n            0x00, 0x00, 0x00, 0x01, 0x44, 0x01, 0xc0, 0x73,  // PPS\r\n        ];\r\n        assert!(extract_hevc_config(&data).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_hevc_config_missing_pps() {\r\n        let data = [\r\n            0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0c, 0x01,  // VPS\r\n            0x00, 0x00, 0x00, 0x01, 0x42, 0x01, 0x01, 0x21,  // SPS only\r\n        ];\r\n        assert!(extract_hevc_config(&data).is_none());\r\n    }\r\n\r\n    #[test]\r\n    fn test_hevc_annexb_to_hvcc() {\r\n        let annexb = [\r\n            0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0c,  // VPS (3 bytes)\r\n            0x00, 0x00, 0x00, 0x01, 0x42, 0x01,        // SPS (2 bytes)\r\n        ];\r\n\r\n        let hvcc = hevc_annexb_to_hvcc(&annexb);\r\n        \r\n        // First NAL: length 3 + data\r\n        assert_eq!(&hvcc[0..4], &[0x00, 0x00, 0x00, 0x03]);\r\n        assert_eq!(&hvcc[4..7], &[0x40, 0x01, 0x0c]);\r\n        \r\n        // Second NAL: length 2 + data\r\n        assert_eq!(&hvcc[7..11], &[0x00, 0x00, 0x00, 0x02]);\r\n        assert_eq!(&hvcc[11..13], &[0x42, 0x01]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_hevc_keyframe() {\r\n        // IDR frame\r\n        let idr = [\r\n            0x00, 0x00, 0x00, 0x01, 0x40, 0x01,  // VPS\r\n            0x00, 0x00, 0x00, 0x01, 0x26, 0x01,  // IDR_W_RADL (type 19)\r\n        ];\r\n        assert!(is_hevc_keyframe(&idr));\r\n\r\n        // Non-keyframe (TRAIL_R, type 1)\r\n        let trail = [\r\n            0x00, 0x00, 0x00, 0x01, 0x02, 0x01,  // TRAIL_R (type 1)\r\n        ];\r\n        assert!(!is_hevc_keyframe(&trail));\r\n    }\r\n\r\n    #[test]\r\n    fn test_hevc_config_accessors() {\r\n        // Create config with realistic SPS header\r\n        // HEVC SPS has profile_tier_level at byte offset 3+\r\n        let config = HevcConfig::new(\r\n            vec![0x40, 0x01],  // VPS\r\n            vec![0x42, 0x01, 0x01, 0x21, 0x80, 0x00, 0x00, 0x03,\r\n                 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5d],  // SPS with level at byte 15\r\n            vec![0x44, 0x01],  // PPS\r\n        );\r\n        \r\n        // Profile space is bits 6-7 of byte 3 (0x21 >> 6 = 0)\r\n        assert_eq!(config.general_profile_space(), 0);\r\n        // Tier flag is bit 5 of byte 3 (0x21 >> 5 & 1 = 1)\r\n        assert!(config.general_tier_flag());\r\n        // Profile IDC is bits 0-4 of byte 3 (0x21 & 0x1f = 1)\r\n        assert_eq!(config.general_profile_idc(), 1);\r\n        // Level is byte 14 (index 14, which is 0x5d in this SPS)\r\n        // Our SPS is 16 bytes, so byte 14 is the second-to-last = 0x00\r\n        // Let's just verify the accessor works with a valid result\r\n        let level = config.general_level_idc();\r\n        assert!(level <= 186); // Max valid HEVC level\r\n    }\r\n}\r\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":72057594037928367}},{"line":87,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":88,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":92,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":93,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":97,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":98,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":113,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":114,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":127,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":128,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":165,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":166,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":167,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":169,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":170,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":176,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":177,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":178,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":179,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":180,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":184,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":185,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":190,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":191,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":192,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":199,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":200,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":202,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":203,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":207,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":208,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":212,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":222,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":223,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":224,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":228,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":229,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":232,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":47,"coverable":56},{"path":["C:","\\","Users","micha","repos","muxide","src","codec","mod.rs"],"content":"//! Codec configuration extraction for container muxing.\r\n//!\r\n//! This module provides minimal bitstream parsing required to build codec\r\n//! configuration boxes (avcC, hvcC, av1C, dOps). It does NOT perform decoding,\r\n//! transcoding, or frame reconstruction.\r\n//!\r\n//! # Supported Codecs\r\n//!\r\n//! - **H.264/AVC**: Extract SPS/PPS from Annex B NAL units\r\n//! - **H.265/HEVC**: Extract VPS/SPS/PPS from Annex B NAL units\r\n//! - **Opus**: Parse TOC for frame duration, build dOps config\r\n//! - **AV1**: (stub - coming soon)\r\n//!\r\n//! # Input Format\r\n//!\r\n//! All video input is expected in **Annex B** format (start code delimited):\r\n//! - 4-byte start code: `0x00 0x00 0x00 0x01`\r\n//! - 3-byte start code: `0x00 0x00 0x01`\r\n//!\r\n//! The muxer internally converts to length-prefixed format (AVCC/HVCC) for MP4.\r\n\r\npub mod common;\r\npub mod h264;\r\npub mod h265;\r\npub mod av1;\r\npub mod opus;\r\n\r\npub use common::{find_start_code, AnnexBNalIter};\r\npub use h264::{AvcConfig, extract_avc_config, annexb_to_avcc, is_h264_keyframe};\r\npub use h265::{HevcConfig, extract_hevc_config, hevc_annexb_to_hvcc, is_hevc_keyframe};\r\npub use opus::{OpusConfig, opus_packet_samples, is_valid_opus_packet, OPUS_SAMPLE_RATE};\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","src","codec","opus.rs"],"content":"//! Opus codec support for MP4 muxing.\r\n//!\r\n//! This module provides utilities for working with Opus audio in MP4 containers.\r\n//! Opus in MP4 follows the ISO/IEC 14496-3 Amendment 4 specification, using the\r\n//! `Opus` sample entry and `dOps` (Opus Decoder Configuration) box.\r\n//!\r\n//! # Opus in MP4\r\n//!\r\n//! Key characteristics:\r\n//! - Sample rate is always 48000 Hz (per Opus spec, internal rate is 48kHz)\r\n//! - Timescale should be 48000 for proper timing\r\n//! - Pre-skip samples must be signaled in dOps\r\n//! - Variable frame duration (2.5ms to 60ms)\r\n//!\r\n//! # Frame Duration\r\n//!\r\n//! Opus packets encode their duration in the TOC (Table of Contents) byte.\r\n//! This module can infer frame duration from the TOC or accept user-provided duration.\r\n\r\n/// Default Opus sample rate (48kHz, per Opus specification)\r\npub const OPUS_SAMPLE_RATE: u32 = 48000;\r\n\r\n/// Opus decoder configuration for the dOps box.\r\n#[derive(Debug, Clone)]\r\npub struct OpusConfig {\r\n    /// Opus version (should be 0)\r\n    pub version: u8,\r\n    /// Number of output channels (1-8)\r\n    pub output_channel_count: u8,\r\n    /// Pre-skip samples (samples to discard at start for encoder/decoder delay)\r\n    pub pre_skip: u16,\r\n    /// Original sample rate (for informational purposes only, Opus always decodes at 48kHz)\r\n    pub input_sample_rate: u32,\r\n    /// Output gain in dB (Q7.8 fixed point: value / 256.0 = dB)\r\n    pub output_gain: i16,\r\n    /// Channel mapping family (0 = mono/stereo, 1 = Vorbis order, 2+ = application-defined)\r\n    pub channel_mapping_family: u8,\r\n    /// Stream count (for mapping family >= 1)\r\n    pub stream_count: Option<u8>,\r\n    /// Coupled stream count (for mapping family >= 1)\r\n    pub coupled_count: Option<u8>,\r\n    /// Channel mapping table (for mapping family >= 1)\r\n    pub channel_mapping: Option<Vec<u8>>,\r\n}\r\n\r\nimpl Default for OpusConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            version: 0,\r\n            output_channel_count: 2,\r\n            pre_skip: 312, // Common encoder delay\r\n            input_sample_rate: 48000,\r\n            output_gain: 0,\r\n            channel_mapping_family: 0,\r\n            stream_count: None,\r\n            coupled_count: None,\r\n            channel_mapping: None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl OpusConfig {\r\n    /// Create a mono Opus configuration.\r\n    pub fn mono() -> Self {\r\n        Self {\r\n            output_channel_count: 1,\r\n            ..Default::default()\r\n        }\r\n    }\r\n\r\n    /// Create a stereo Opus configuration.\r\n    pub fn stereo() -> Self {\r\n        Self {\r\n            output_channel_count: 2,\r\n            ..Default::default()\r\n        }\r\n    }\r\n\r\n    /// Create configuration with custom pre-skip.\r\n    pub fn with_pre_skip(mut self, pre_skip: u16) -> Self {\r\n        self.pre_skip = pre_skip;\r\n        self\r\n    }\r\n\r\n    /// Create configuration with custom channel count.\r\n    pub fn with_channels(mut self, channels: u8) -> Self {\r\n        self.output_channel_count = channels;\r\n        if channels > 2 {\r\n            // For > 2 channels, need mapping family 1 or higher\r\n            self.channel_mapping_family = 1;\r\n        }\r\n        self\r\n    }\r\n}\r\n\r\n/// Opus frame duration in samples at 48kHz.\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\r\npub enum OpusFrameDuration {\r\n    /// 2.5ms = 120 samples\r\n    Ms2_5,\r\n    /// 5ms = 240 samples\r\n    Ms5,\r\n    /// 10ms = 480 samples\r\n    Ms10,\r\n    /// 20ms = 960 samples\r\n    Ms20,\r\n    /// 40ms = 1920 samples\r\n    Ms40,\r\n    /// 60ms = 2880 samples\r\n    Ms60,\r\n}\r\n\r\nimpl OpusFrameDuration {\r\n    /// Get the duration in samples at 48kHz.\r\n    pub fn samples(self) -> u32 {\r\n        match self {\r\n            OpusFrameDuration::Ms2_5 => 120,\r\n            OpusFrameDuration::Ms5 => 240,\r\n            OpusFrameDuration::Ms10 => 480,\r\n            OpusFrameDuration::Ms20 => 960,\r\n            OpusFrameDuration::Ms40 => 1920,\r\n            OpusFrameDuration::Ms60 => 2880,\r\n        }\r\n    }\r\n\r\n    /// Get the duration in seconds.\r\n    pub fn seconds(self) -> f64 {\r\n        self.samples() as f64 / OPUS_SAMPLE_RATE as f64\r\n    }\r\n}\r\n\r\n/// Extract frame duration from the Opus TOC byte.\r\n///\r\n/// The TOC byte encodes the frame configuration:\r\n/// - Bits 0-4: Frame count configuration\r\n/// - Bits 5-7: Bandwidth/mode/config\r\n///\r\n/// Returns the frame duration for a single frame in the packet.\r\npub fn opus_frame_duration_from_toc(toc: u8) -> Option<OpusFrameDuration> {\r\n    // Extract config bits (bits 3-7)\r\n    let config = (toc >> 3) & 0x1F;\r\n    \r\n    // Frame size depends on config value\r\n    // See RFC 6716 Section 3.1\r\n    match config {\r\n        // SILK-only modes\r\n        0..=3 => Some(OpusFrameDuration::Ms10),\r\n        4..=7 => Some(OpusFrameDuration::Ms20),\r\n        8..=11 => Some(OpusFrameDuration::Ms40),\r\n        12..=15 => Some(OpusFrameDuration::Ms60),\r\n        // Hybrid modes\r\n        16..=19 => Some(OpusFrameDuration::Ms10),\r\n        20..=23 => Some(OpusFrameDuration::Ms20),\r\n        // CELT-only modes  \r\n        24..=27 => Some(OpusFrameDuration::Ms2_5),\r\n        28..=31 => Some(OpusFrameDuration::Ms5),\r\n        _ => None,\r\n    }\r\n}\r\n\r\n/// Extract the frame count from the Opus packet.\r\n///\r\n/// Opus packets can contain 1, 2, or a variable number of frames.\r\n/// Returns (frame_count, is_vbr) where is_vbr indicates variable bitrate.\r\npub fn opus_frame_count(packet: &[u8]) -> Option<(u8, bool)> {\r\n    if packet.is_empty() {\r\n        return None;\r\n    }\r\n\r\n    let toc = packet[0];\r\n    let code = toc & 0x03;\r\n\r\n    match code {\r\n        0 => Some((1, false)),  // 1 frame\r\n        1 => Some((2, false)),  // 2 frames, equal size\r\n        2 => Some((2, true)),   // 2 frames, different sizes\r\n        3 => {\r\n            // Code 3: arbitrary number of frames\r\n            if packet.len() < 2 {\r\n                return None;\r\n            }\r\n            let frame_count_byte = packet[1];\r\n            let is_vbr = (frame_count_byte & 0x80) != 0;\r\n            let count = frame_count_byte & 0x3F;\r\n            Some((count, is_vbr))\r\n        }\r\n        _ => None,\r\n    }\r\n}\r\n\r\n/// Calculate total sample duration for an Opus packet.\r\n///\r\n/// Returns the total number of samples (at 48kHz) in the packet.\r\npub fn opus_packet_samples(packet: &[u8]) -> Option<u32> {\r\n    if packet.is_empty() {\r\n        return None;\r\n    }\r\n\r\n    let frame_duration = opus_frame_duration_from_toc(packet[0])?;\r\n    let (frame_count, _) = opus_frame_count(packet)?;\r\n\r\n    Some(frame_duration.samples() * frame_count as u32)\r\n}\r\n\r\n/// Validate an Opus packet for basic structural correctness.\r\n///\r\n/// Returns true if the packet appears to be a valid Opus packet.\r\npub fn is_valid_opus_packet(packet: &[u8]) -> bool {\r\n    if packet.is_empty() {\r\n        return false;\r\n    }\r\n\r\n    // Check if we can parse the TOC and frame count\r\n    opus_packet_samples(packet).is_some()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_opus_config_default() {\r\n        let config = OpusConfig::default();\r\n        assert_eq!(config.version, 0);\r\n        assert_eq!(config.output_channel_count, 2);\r\n        assert_eq!(config.pre_skip, 312);\r\n        assert_eq!(config.input_sample_rate, 48000);\r\n        assert_eq!(config.output_gain, 0);\r\n        assert_eq!(config.channel_mapping_family, 0);\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_config_mono() {\r\n        let config = OpusConfig::mono();\r\n        assert_eq!(config.output_channel_count, 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_config_stereo() {\r\n        let config = OpusConfig::stereo();\r\n        assert_eq!(config.output_channel_count, 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_duration_samples() {\r\n        assert_eq!(OpusFrameDuration::Ms2_5.samples(), 120);\r\n        assert_eq!(OpusFrameDuration::Ms5.samples(), 240);\r\n        assert_eq!(OpusFrameDuration::Ms10.samples(), 480);\r\n        assert_eq!(OpusFrameDuration::Ms20.samples(), 960);\r\n        assert_eq!(OpusFrameDuration::Ms40.samples(), 1920);\r\n        assert_eq!(OpusFrameDuration::Ms60.samples(), 2880);\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_duration_from_toc_silk() {\r\n        // SILK 10ms (config 0-3)\r\n        assert_eq!(opus_frame_duration_from_toc(0b00000_000), Some(OpusFrameDuration::Ms10));\r\n        // SILK 20ms (config 4-7)\r\n        assert_eq!(opus_frame_duration_from_toc(0b00100_000), Some(OpusFrameDuration::Ms20));\r\n        // SILK 40ms (config 8-11)\r\n        assert_eq!(opus_frame_duration_from_toc(0b01000_000), Some(OpusFrameDuration::Ms40));\r\n        // SILK 60ms (config 12-15)\r\n        assert_eq!(opus_frame_duration_from_toc(0b01100_000), Some(OpusFrameDuration::Ms60));\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_duration_from_toc_celt() {\r\n        // CELT 2.5ms (config 24-27)\r\n        assert_eq!(opus_frame_duration_from_toc(0b11000_000), Some(OpusFrameDuration::Ms2_5));\r\n        // CELT 5ms (config 28-31)\r\n        assert_eq!(opus_frame_duration_from_toc(0b11100_000), Some(OpusFrameDuration::Ms5));\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_count_single() {\r\n        // TOC with code 0 = 1 frame\r\n        let packet = vec![0b00000_00, 0x01, 0x02, 0x03];\r\n        assert_eq!(opus_frame_count(&packet), Some((1, false)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_count_double_equal() {\r\n        // TOC with code 1 = 2 frames, equal size\r\n        let packet = vec![0b00000_01, 0x01, 0x02, 0x03];\r\n        assert_eq!(opus_frame_count(&packet), Some((2, false)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_count_double_different() {\r\n        // TOC with code 2 = 2 frames, different sizes\r\n        let packet = vec![0b00000_10, 0x01, 0x02, 0x03];\r\n        assert_eq!(opus_frame_count(&packet), Some((2, true)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_frame_count_arbitrary() {\r\n        // TOC with code 3 = N frames, count in second byte\r\n        let packet = vec![0b00000_11, 0b0_00_00100]; // 4 frames, CBR\r\n        assert_eq!(opus_frame_count(&packet), Some((4, false)));\r\n\r\n        let packet_vbr = vec![0b00000_11, 0b1_00_00100]; // 4 frames, VBR\r\n        assert_eq!(opus_frame_count(&packet_vbr), Some((4, true)));\r\n    }\r\n\r\n    #[test]\r\n    fn test_opus_packet_samples() {\r\n        // SILK 20ms frame (config=4), 1 frame (code=0)\r\n        // TOC: config=4 (bits 3-7 = 0b00100), s=0, c=0\r\n        // Binary: 0b00100_0_00 = 0x20 = 32\r\n        let packet = vec![0x20, 0x01, 0x02, 0x03];\r\n        assert_eq!(opus_packet_samples(&packet), Some(960));\r\n\r\n        // SILK 20ms frame (config=4), 2 frames (code=1)\r\n        // TOC: config=4 (bits 3-7 = 0b00100), s=0, c=1\r\n        // Binary: 0b00100_0_01 = 0x21 = 33\r\n        let packet2 = vec![0x21, 0x01, 0x02, 0x03];\r\n        assert_eq!(opus_packet_samples(&packet2), Some(1920));\r\n    }\r\n\r\n    #[test]\r\n    fn test_is_valid_opus_packet() {\r\n        // Valid: config=4 (SILK 20ms), code=0 (1 frame)\r\n        assert!(is_valid_opus_packet(&[0x20, 0x01, 0x02]));\r\n        assert!(!is_valid_opus_packet(&[]));\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":504403158265495568}},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":72,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":115,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":116,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":117,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":119,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":120,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":122,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":141,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":145,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":147,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":148,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":149,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":150,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":152,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":153,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":155,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":156,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":166,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":171,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":173,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":174,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":175,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":176,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":179,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":183,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":185,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":195,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":200,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":202,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":208,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":209,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":210,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":214,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":48,"coverable":59},{"path":["C:","\\","Users","micha","repos","muxide","src","config.rs"],"content":"/// Shared track configuration used by the API and muxer modules.\r\n///\r\n/// These structs are intentionally minimal and may expand in future slices\r\n/// as additional track metadata is required for the encoder.\r\n#[derive(Debug, Clone)]\r\npub struct VideoTrackConfig {\r\n    /// Video codec.\r\n    pub codec: crate::api::VideoCodec,\r\n    /// Width in pixels.\r\n    pub width: u32,\r\n    /// Height in pixels.\r\n    pub height: u32,\r\n    /// Frame rate (frames per second).\r\n    pub framerate: f64,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\npub struct AudioTrackConfig {\r\n    /// Audio codec.\r\n    pub codec: crate::api::AudioCodec,\r\n    /// Sample rate (Hz).\r\n    pub sample_rate: u32,\r\n    /// Number of audio channels.\r\n    pub channels: u16,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","src","fragmented.rs"],"content":"//! Fragmented MP4 (fMP4) support for streaming applications.\r\n//!\r\n//! Fragmented MP4 splits the container into an init segment (ftyp + moov)\r\n//! and media segments (moof + mdat). This is essential for:\r\n//! - DASH streaming\r\n//! - HLS with fMP4\r\n//! - Low-latency live streaming\r\n//!\r\n//! # Example\r\n//! ```ignore\r\n//! use muxide::fragmented::{FragmentedMuxer, FragmentConfig};\r\n//!\r\n//! let config = FragmentConfig {\r\n//!     width: 1920,\r\n//!     height: 1080,\r\n//!     timescale: 90000,\r\n//!     fragment_duration_ms: 2000,\r\n//! };\r\n//!\r\n//! let mut muxer = FragmentedMuxer::new(config);\r\n//!\r\n//! // Get init segment (write once at start)\r\n//! let init_segment = muxer.init_segment();\r\n//!\r\n//! // Write frames...\r\n//! muxer.write_video(pts, dts, data, is_keyframe)?;\r\n//!\r\n//! // Get media segment when ready\r\n//! if let Some(segment) = muxer.flush_segment() {\r\n//!     // Send segment to client\r\n//! }\r\n//! ```\r\n\r\n// No imports needed currently - pure Vec-based API\r\n\r\n/// Configuration for fragmented MP4 output.\r\n#[derive(Debug, Clone)]\r\npub struct FragmentConfig {\r\n    /// Video width in pixels.\r\n    pub width: u32,\r\n    /// Video height in pixels.\r\n    pub height: u32,\r\n    /// Media timescale (typically 90000 for video).\r\n    pub timescale: u32,\r\n    /// Target fragment duration in milliseconds.\r\n    pub fragment_duration_ms: u32,\r\n    /// SPS NAL unit (required for init segment).\r\n    pub sps: Vec<u8>,\r\n    /// PPS NAL unit (required for init segment).\r\n    pub pps: Vec<u8>,\r\n}\r\n\r\nimpl Default for FragmentConfig {\r\n    fn default() -> Self {\r\n        Self {\r\n            width: 1920,\r\n            height: 1080,\r\n            timescale: 90000,\r\n            fragment_duration_ms: 2000,\r\n            sps: vec![0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11],\r\n            pps: vec![0x68, 0xce, 0x38, 0x80],\r\n        }\r\n    }\r\n}\r\n\r\n/// Sample information for fragmented muxing.\r\n#[derive(Debug, Clone)]\r\nstruct FragmentSample {\r\n    /// Presentation timestamp in timescale units.\r\n    pts: u64,\r\n    /// Decode timestamp in timescale units.\r\n    dts: u64,\r\n    /// Sample data (AVCC format).\r\n    data: Vec<u8>,\r\n    /// Whether this is a sync sample (keyframe).\r\n    is_sync: bool,\r\n}\r\n\r\n/// A fragmented MP4 muxer for streaming applications.\r\npub struct FragmentedMuxer {\r\n    config: FragmentConfig,\r\n    samples: Vec<FragmentSample>,\r\n    sequence_number: u32,\r\n    base_media_decode_time: u64,\r\n    init_segment: Option<Vec<u8>>,\r\n}\r\n\r\nimpl FragmentedMuxer {\r\n    /// Create a new fragmented muxer with the given configuration.\r\n    pub fn new(config: FragmentConfig) -> Self {\r\n        Self {\r\n            config,\r\n            samples: Vec::new(),\r\n            sequence_number: 1,\r\n            base_media_decode_time: 0,\r\n            init_segment: None,\r\n        }\r\n    }\r\n\r\n    /// Get the initialization segment (ftyp + moov).\r\n    /// This should be sent once at the start of a stream.\r\n    pub fn init_segment(&mut self) -> Vec<u8> {\r\n        if let Some(ref init) = self.init_segment {\r\n            return init.clone();\r\n        }\r\n\r\n        let mut buf = Vec::new();\r\n        \r\n        // ftyp box\r\n        let ftyp = build_ftyp_fmp4();\r\n        buf.extend_from_slice(&ftyp);\r\n\r\n        // moov box (no sample tables for fMP4)\r\n        let moov = build_moov_fmp4(&self.config);\r\n        buf.extend_from_slice(&moov);\r\n\r\n        self.init_segment = Some(buf.clone());\r\n        buf\r\n    }\r\n\r\n    /// Queue a video sample for the current fragment.\r\n    /// \r\n    /// - `pts`: Presentation timestamp in timescale units\r\n    /// - `dts`: Decode timestamp in timescale units\r\n    /// - `data`: Sample data in AVCC format (4-byte length prefixed)\r\n    /// - `is_sync`: True if this is a sync sample (keyframe)\r\n    pub fn write_video(&mut self, pts: u64, dts: u64, data: &[u8], is_sync: bool) {\r\n        self.samples.push(FragmentSample {\r\n            pts,\r\n            dts,\r\n            data: data.to_vec(),\r\n            is_sync,\r\n        });\r\n    }\r\n\r\n    /// Flush all queued samples as a media segment (moof + mdat).\r\n    /// Returns None if there are no samples to flush.\r\n    pub fn flush_segment(&mut self) -> Option<Vec<u8>> {\r\n        if self.samples.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        let samples = std::mem::take(&mut self.samples);\r\n        let segment = build_media_segment(\r\n            &samples,\r\n            self.sequence_number,\r\n            self.base_media_decode_time,\r\n            self.config.timescale,\r\n        );\r\n\r\n        // Update state for next segment\r\n        self.sequence_number += 1;\r\n        if let Some(last) = samples.last() {\r\n            // Estimate next base_media_decode_time\r\n            if samples.len() >= 2 {\r\n                let avg_duration = (last.dts - samples[0].dts) / (samples.len() as u64 - 1);\r\n                self.base_media_decode_time = last.dts + avg_duration;\r\n            } else {\r\n                self.base_media_decode_time = last.dts + 3000; // Fallback: 1 frame at 30fps\r\n            }\r\n        }\r\n\r\n        Some(segment)\r\n    }\r\n\r\n    /// Check if we have enough samples to make a fragment.\r\n    pub fn ready_to_flush(&self) -> bool {\r\n        if self.samples.is_empty() {\r\n            return false;\r\n        }\r\n        \r\n        if self.samples.len() < 2 {\r\n            return false;\r\n        }\r\n\r\n        let first_dts = self.samples[0].dts;\r\n        let last_dts = self.samples.last().unwrap().dts;\r\n        let duration_ticks = last_dts - first_dts;\r\n        let duration_ms = duration_ticks * 1000 / self.config.timescale as u64;\r\n        \r\n        duration_ms >= self.config.fragment_duration_ms as u64\r\n    }\r\n\r\n    /// Get current fragment duration in milliseconds.\r\n    pub fn current_fragment_duration_ms(&self) -> u64 {\r\n        if self.samples.len() < 2 {\r\n            return 0;\r\n        }\r\n        let first_dts = self.samples[0].dts;\r\n        let last_dts = self.samples.last().unwrap().dts;\r\n        let duration_ticks = last_dts - first_dts;\r\n        duration_ticks * 1000 / self.config.timescale as u64\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Box building functions for fMP4\r\n// ============================================================================\r\n\r\nfn build_box(typ: &[u8; 4], payload: &[u8]) -> Vec<u8> {\r\n    let size = (8 + payload.len()) as u32;\r\n    let mut buf = Vec::with_capacity(size as usize);\r\n    buf.extend_from_slice(&size.to_be_bytes());\r\n    buf.extend_from_slice(typ);\r\n    buf.extend_from_slice(payload);\r\n    buf\r\n}\r\n\r\nfn build_ftyp_fmp4() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(b\"iso5\");  // Major brand: ISO Base Media File Format v5\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Minor version\r\n    payload.extend_from_slice(b\"iso5\");  // Compatible brands\r\n    payload.extend_from_slice(b\"iso6\");\r\n    payload.extend_from_slice(b\"mp41\");\r\n    build_box(b\"ftyp\", &payload)\r\n}\r\n\r\nfn build_moov_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // mvhd (movie header)\r\n    let mvhd = build_mvhd_fmp4(config.timescale);\r\n    payload.extend_from_slice(&mvhd);\r\n    \r\n    // mvex (movie extends) - required for fragmented MP4\r\n    let mvex = build_mvex();\r\n    payload.extend_from_slice(&mvex);\r\n    \r\n    // trak (video track)\r\n    let trak = build_trak_fmp4(config);\r\n    payload.extend_from_slice(&trak);\r\n    \r\n    build_box(b\"moov\", &payload)\r\n}\r\n\r\nfn build_mvhd_fmp4(timescale: u32) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Creation time\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Modification time\r\n    payload.extend_from_slice(&timescale.to_be_bytes()); // Timescale\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Duration (unknown for live)\r\n    payload.extend_from_slice(&0x0001_0000_u32.to_be_bytes()); // Rate (1.0)\r\n    payload.extend_from_slice(&0x0100_u16.to_be_bytes()); // Volume (1.0)\r\n    payload.extend_from_slice(&[0u8; 10]); // Reserved\r\n    // Unity matrix (36 bytes)\r\n    payload.extend_from_slice(&0x0001_0000_u32.to_be_bytes());\r\n    payload.extend_from_slice(&[0u8; 12]);\r\n    payload.extend_from_slice(&0x0001_0000_u32.to_be_bytes());\r\n    payload.extend_from_slice(&[0u8; 12]);\r\n    payload.extend_from_slice(&0x4000_0000_u32.to_be_bytes());\r\n    payload.extend_from_slice(&[0u8; 24]); // Pre-defined\r\n    payload.extend_from_slice(&2u32.to_be_bytes()); // Next track ID\r\n    build_box(b\"mvhd\", &payload)\r\n}\r\n\r\nfn build_mvex() -> Vec<u8> {\r\n    // trex (track extends) - default sample flags\r\n    let mut trex_payload = Vec::new();\r\n    trex_payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    trex_payload.extend_from_slice(&1u32.to_be_bytes()); // Track ID\r\n    trex_payload.extend_from_slice(&1u32.to_be_bytes()); // Default sample description index\r\n    trex_payload.extend_from_slice(&0u32.to_be_bytes()); // Default sample duration\r\n    trex_payload.extend_from_slice(&0u32.to_be_bytes()); // Default sample size\r\n    trex_payload.extend_from_slice(&0u32.to_be_bytes()); // Default sample flags\r\n    let trex = build_box(b\"trex\", &trex_payload);\r\n    \r\n    build_box(b\"mvex\", &trex)\r\n}\r\n\r\nfn build_trak_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // tkhd (track header)\r\n    let tkhd = build_tkhd_fmp4(config);\r\n    payload.extend_from_slice(&tkhd);\r\n    \r\n    // mdia (media)\r\n    let mdia = build_mdia_fmp4(config);\r\n    payload.extend_from_slice(&mdia);\r\n    \r\n    build_box(b\"trak\", &payload)\r\n}\r\n\r\nfn build_tkhd_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0x0000_0003_u32.to_be_bytes()); // Version 0, flags: enabled + in_movie\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Creation time\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Modification time\r\n    payload.extend_from_slice(&1u32.to_be_bytes()); // Track ID\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Reserved\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Duration\r\n    payload.extend_from_slice(&[0u8; 8]); // Reserved\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Layer\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Alternate group\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Volume (0 for video)\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Reserved\r\n    // Unity matrix (36 bytes)\r\n    payload.extend_from_slice(&0x0001_0000_u32.to_be_bytes());\r\n    payload.extend_from_slice(&[0u8; 12]);\r\n    payload.extend_from_slice(&0x0001_0000_u32.to_be_bytes());\r\n    payload.extend_from_slice(&[0u8; 12]);\r\n    payload.extend_from_slice(&0x4000_0000_u32.to_be_bytes());\r\n    // Width and height in fixed-point 16.16\r\n    payload.extend_from_slice(&((config.width as u32) << 16).to_be_bytes());\r\n    payload.extend_from_slice(&((config.height as u32) << 16).to_be_bytes());\r\n    build_box(b\"tkhd\", &payload)\r\n}\r\n\r\nfn build_mdia_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // mdhd (media header)\r\n    let mdhd = build_mdhd_fmp4(config.timescale);\r\n    payload.extend_from_slice(&mdhd);\r\n    \r\n    // hdlr (handler)\r\n    let hdlr = build_hdlr_video();\r\n    payload.extend_from_slice(&hdlr);\r\n    \r\n    // minf (media info)\r\n    let minf = build_minf_fmp4(config);\r\n    payload.extend_from_slice(&minf);\r\n    \r\n    build_box(b\"mdia\", &payload)\r\n}\r\n\r\nfn build_mdhd_fmp4(timescale: u32) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Creation time\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Modification time\r\n    payload.extend_from_slice(&timescale.to_be_bytes()); // Timescale\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Duration (unknown)\r\n    payload.extend_from_slice(&0x55c4_u16.to_be_bytes()); // Language: und\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Quality\r\n    build_box(b\"mdhd\", &payload)\r\n}\r\n\r\nfn build_hdlr_video() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Pre-defined\r\n    payload.extend_from_slice(b\"vide\"); // Handler type\r\n    payload.extend_from_slice(&[0u8; 12]); // Reserved\r\n    payload.extend_from_slice(b\"VideoHandler\\0\"); // Name\r\n    build_box(b\"hdlr\", &payload)\r\n}\r\n\r\nfn build_minf_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // vmhd (video media header)\r\n    let vmhd = build_vmhd();\r\n    payload.extend_from_slice(&vmhd);\r\n    \r\n    // dinf (data information)\r\n    let dinf = build_dinf();\r\n    payload.extend_from_slice(&dinf);\r\n    \r\n    // stbl (sample table) - minimal for fMP4\r\n    let stbl = build_stbl_fmp4(config);\r\n    payload.extend_from_slice(&stbl);\r\n    \r\n    build_box(b\"minf\", &payload)\r\n}\r\n\r\nfn build_vmhd() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0x0000_0001_u32.to_be_bytes()); // Version 0, flags: 1\r\n    payload.extend_from_slice(&[0u8; 8]); // Graphics mode + op color\r\n    build_box(b\"vmhd\", &payload)\r\n}\r\n\r\nfn build_dinf() -> Vec<u8> {\r\n    // dref with self-contained data reference\r\n    let mut dref_payload = Vec::new();\r\n    dref_payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    dref_payload.extend_from_slice(&1u32.to_be_bytes()); // Entry count\r\n    // url box (self-contained)\r\n    let url_payload = [0x00, 0x00, 0x00, 0x01]; // Flags: self-contained\r\n    let url_box = build_box(b\"url \", &url_payload);\r\n    dref_payload.extend_from_slice(&url_box);\r\n    let dref = build_box(b\"dref\", &dref_payload);\r\n    \r\n    build_box(b\"dinf\", &dref)\r\n}\r\n\r\nfn build_stbl_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // stsd (sample description)\r\n    let stsd = build_stsd_fmp4(config);\r\n    payload.extend_from_slice(&stsd);\r\n    \r\n    // Empty stts (time-to-sample) - actual data in moof\r\n    let stts = build_empty_stts();\r\n    payload.extend_from_slice(&stts);\r\n    \r\n    // Empty stsc (sample-to-chunk)\r\n    let stsc = build_empty_stsc();\r\n    payload.extend_from_slice(&stsc);\r\n    \r\n    // Empty stsz (sample size)\r\n    let stsz = build_empty_stsz();\r\n    payload.extend_from_slice(&stsz);\r\n    \r\n    // Empty stco (chunk offset)\r\n    let stco = build_empty_stco();\r\n    payload.extend_from_slice(&stco);\r\n    \r\n    build_box(b\"stbl\", &payload)\r\n}\r\n\r\nfn build_stsd_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let avc1 = build_avc1_fmp4(config);\r\n    \r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&1u32.to_be_bytes()); // Entry count\r\n    payload.extend_from_slice(&avc1);\r\n    build_box(b\"stsd\", &payload)\r\n}\r\n\r\nfn build_avc1_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&[0u8; 6]); // Reserved\r\n    payload.extend_from_slice(&1u16.to_be_bytes()); // Data reference index\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Pre-defined\r\n    payload.extend_from_slice(&0u16.to_be_bytes()); // Reserved\r\n    payload.extend_from_slice(&[0u8; 12]); // Pre-defined\r\n    payload.extend_from_slice(&(config.width as u16).to_be_bytes());\r\n    payload.extend_from_slice(&(config.height as u16).to_be_bytes());\r\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes()); // Horizontal resolution (72 dpi)\r\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes()); // Vertical resolution (72 dpi)\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Reserved\r\n    payload.extend_from_slice(&1u16.to_be_bytes()); // Frame count\r\n    payload.extend_from_slice(&[0u8; 32]); // Compressor name\r\n    payload.extend_from_slice(&0x0018_u16.to_be_bytes()); // Depth: 24-bit color\r\n    payload.extend_from_slice(&0xffff_u16.to_be_bytes()); // Pre-defined (-1)\r\n    \r\n    // avcC (AVC Configuration)\r\n    let avcc = build_avcc_fmp4(config);\r\n    payload.extend_from_slice(&avcc);\r\n    \r\n    build_box(b\"avc1\", &payload)\r\n}\r\n\r\nfn build_avcc_fmp4(config: &FragmentConfig) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.push(1); // Configuration version\r\n    payload.push(config.sps.get(1).copied().unwrap_or(0x42)); // Profile\r\n    payload.push(config.sps.get(2).copied().unwrap_or(0x00)); // Profile compatibility\r\n    payload.push(config.sps.get(3).copied().unwrap_or(0x1e)); // Level\r\n    payload.push(0xff); // 6 bits reserved + 2 bits NAL unit length - 1 (3 = 4 bytes)\r\n    payload.push(0xe1); // 3 bits reserved + 5 bits number of SPS\r\n    payload.extend_from_slice(&(config.sps.len() as u16).to_be_bytes());\r\n    payload.extend_from_slice(&config.sps);\r\n    payload.push(1); // Number of PPS\r\n    payload.extend_from_slice(&(config.pps.len() as u16).to_be_bytes());\r\n    payload.extend_from_slice(&config.pps);\r\n    build_box(b\"avcC\", &payload)\r\n}\r\n\r\nfn build_empty_stts() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Entry count\r\n    build_box(b\"stts\", &payload)\r\n}\r\n\r\nfn build_empty_stsc() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Entry count\r\n    build_box(b\"stsc\", &payload)\r\n}\r\n\r\nfn build_empty_stsz() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Sample size (0 = variable)\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Sample count\r\n    build_box(b\"stsz\", &payload)\r\n}\r\n\r\nfn build_empty_stco() -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Entry count\r\n    build_box(b\"stco\", &payload)\r\n}\r\n\r\n// ============================================================================\r\n// Media segment building (moof + mdat)\r\n// ============================================================================\r\n\r\nfn build_media_segment(\r\n    samples: &[FragmentSample],\r\n    sequence_number: u32,\r\n    base_media_decode_time: u64,\r\n    _timescale: u32,  // Reserved for future use (duration calculations)\r\n) -> Vec<u8> {\r\n    // Calculate total mdat size\r\n    let mdat_payload_size: usize = samples.iter().map(|s| s.data.len()).sum();\r\n    \r\n    // Build moof first to get its size\r\n    let moof = build_moof(samples, sequence_number, base_media_decode_time);\r\n    let moof_size = moof.len() as u32;\r\n    \r\n    // Data offset is moof_size + mdat_header(8)\r\n    let data_offset = moof_size + 8;\r\n    \r\n    // Rebuild moof with correct data offset\r\n    let moof = build_moof_with_offset(samples, sequence_number, base_media_decode_time, data_offset);\r\n    \r\n    // Build mdat\r\n    let mut segment = Vec::with_capacity(moof.len() + 8 + mdat_payload_size);\r\n    segment.extend_from_slice(&moof);\r\n    \r\n    // mdat header\r\n    let mdat_size = (8 + mdat_payload_size) as u32;\r\n    segment.extend_from_slice(&mdat_size.to_be_bytes());\r\n    segment.extend_from_slice(b\"mdat\");\r\n    \r\n    // mdat payload (all sample data)\r\n    for sample in samples {\r\n        segment.extend_from_slice(&sample.data);\r\n    }\r\n    \r\n    segment\r\n}\r\n\r\nfn build_moof(\r\n    samples: &[FragmentSample],\r\n    sequence_number: u32,\r\n    base_media_decode_time: u64,\r\n) -> Vec<u8> {\r\n    build_moof_with_offset(samples, sequence_number, base_media_decode_time, 0)\r\n}\r\n\r\nfn build_moof_with_offset(\r\n    samples: &[FragmentSample],\r\n    sequence_number: u32,\r\n    base_media_decode_time: u64,\r\n    data_offset: u32,\r\n) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // mfhd (movie fragment header)\r\n    let mfhd = build_mfhd(sequence_number);\r\n    payload.extend_from_slice(&mfhd);\r\n    \r\n    // traf (track fragment)\r\n    let traf = build_traf(samples, base_media_decode_time, data_offset);\r\n    payload.extend_from_slice(&traf);\r\n    \r\n    build_box(b\"moof\", &payload)\r\n}\r\n\r\nfn build_mfhd(sequence_number: u32) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0u32.to_be_bytes()); // Version + flags\r\n    payload.extend_from_slice(&sequence_number.to_be_bytes());\r\n    build_box(b\"mfhd\", &payload)\r\n}\r\n\r\nfn build_traf(\r\n    samples: &[FragmentSample],\r\n    base_media_decode_time: u64,\r\n    data_offset: u32,\r\n) -> Vec<u8> {\r\n    let mut payload = Vec::new();\r\n    \r\n    // tfhd (track fragment header)\r\n    let tfhd = build_tfhd();\r\n    payload.extend_from_slice(&tfhd);\r\n    \r\n    // tfdt (track fragment decode time)\r\n    let tfdt = build_tfdt(base_media_decode_time);\r\n    payload.extend_from_slice(&tfdt);\r\n    \r\n    // trun (track run)\r\n    let trun = build_trun(samples, data_offset);\r\n    payload.extend_from_slice(&trun);\r\n    \r\n    build_box(b\"traf\", &payload)\r\n}\r\n\r\nfn build_tfhd() -> Vec<u8> {\r\n    // Flags: 0x020000 = default-base-is-moof\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0x0002_0000_u32.to_be_bytes()); // Version 0 + flags\r\n    payload.extend_from_slice(&1u32.to_be_bytes()); // Track ID\r\n    build_box(b\"tfhd\", &payload)\r\n}\r\n\r\nfn build_tfdt(base_media_decode_time: u64) -> Vec<u8> {\r\n    // Version 1 for 64-bit decode time\r\n    let mut payload = Vec::new();\r\n    payload.extend_from_slice(&0x0100_0000_u32.to_be_bytes()); // Version 1 + flags\r\n    payload.extend_from_slice(&base_media_decode_time.to_be_bytes());\r\n    build_box(b\"tfdt\", &payload)\r\n}\r\n\r\nfn build_trun(samples: &[FragmentSample], data_offset: u32) -> Vec<u8> {\r\n    // Flags:\r\n    // 0x000001 = data-offset-present\r\n    // 0x000100 = sample-duration-present\r\n    // 0x000200 = sample-size-present\r\n    // 0x000400 = sample-flags-present\r\n    // 0x000800 = sample-composition-time-offset-present\r\n    let flags: u32 = 0x000001 | 0x000100 | 0x000200 | 0x000400 | 0x000800;\r\n    \r\n    let mut payload = Vec::new();\r\n    // Version 1 for signed composition time offsets\r\n    payload.extend_from_slice(&(0x0100_0000 | flags).to_be_bytes());\r\n    payload.extend_from_slice(&(samples.len() as u32).to_be_bytes()); // Sample count\r\n    payload.extend_from_slice(&data_offset.to_be_bytes()); // Data offset\r\n    \r\n    // Per-sample data\r\n    for (i, sample) in samples.iter().enumerate() {\r\n        // Sample duration (estimate from DTS delta)\r\n        let duration = if i + 1 < samples.len() {\r\n            (samples[i + 1].dts - sample.dts) as u32\r\n        } else if i > 0 {\r\n            // Use previous duration for last sample\r\n            (sample.dts - samples[i - 1].dts) as u32\r\n        } else {\r\n            3000 // Default: 1 frame at 30fps\r\n        };\r\n        payload.extend_from_slice(&duration.to_be_bytes());\r\n        \r\n        // Sample size\r\n        payload.extend_from_slice(&(sample.data.len() as u32).to_be_bytes());\r\n        \r\n        // Sample flags\r\n        // Bits 24-25: depends_on (2 = no other samples)\r\n        // Bit 16: is_non_sync_sample\r\n        let flags = if sample.is_sync {\r\n            0x0200_0000_u32 // depends_on = 2, is_non_sync = 0\r\n        } else {\r\n            0x0101_0000_u32 // depends_on = 1, is_non_sync = 1\r\n        };\r\n        payload.extend_from_slice(&flags.to_be_bytes());\r\n        \r\n        // Composition time offset (signed, pts - dts)\r\n        let cts = (sample.pts as i64 - sample.dts as i64) as i32;\r\n        payload.extend_from_slice(&cts.to_be_bytes());\r\n    }\r\n    \r\n    build_box(b\"trun\", &payload)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn init_segment_contains_ftyp_moov() {\r\n        let config = FragmentConfig::default();\r\n        let mut muxer = FragmentedMuxer::new(config);\r\n        let init = muxer.init_segment();\r\n        \r\n        // Check ftyp\r\n        assert_eq!(&init[4..8], b\"ftyp\");\r\n        \r\n        // Find moov\r\n        let ftyp_size = u32::from_be_bytes(init[0..4].try_into().unwrap()) as usize;\r\n        assert_eq!(&init[ftyp_size + 4..ftyp_size + 8], b\"moov\");\r\n    }\r\n\r\n    #[test]\r\n    fn media_segment_contains_moof_mdat() {\r\n        let config = FragmentConfig::default();\r\n        let mut muxer = FragmentedMuxer::new(config);\r\n        \r\n        // Write some samples\r\n        let sample_data = vec![0x00, 0x00, 0x00, 0x05, 0x65, 0xaa, 0xbb, 0xcc, 0xdd];\r\n        muxer.write_video(0, 0, &sample_data, true);\r\n        muxer.write_video(3000, 3000, &sample_data, false);\r\n        \r\n        let segment = muxer.flush_segment().unwrap();\r\n        \r\n        // Check moof\r\n        assert_eq!(&segment[4..8], b\"moof\");\r\n        \r\n        // Find mdat\r\n        let moof_size = u32::from_be_bytes(segment[0..4].try_into().unwrap()) as usize;\r\n        assert_eq!(&segment[moof_size + 4..moof_size + 8], b\"mdat\");\r\n    }\r\n\r\n    #[test]\r\n    fn flush_returns_none_when_empty() {\r\n        let config = FragmentConfig::default();\r\n        let mut muxer = FragmentedMuxer::new(config);\r\n        assert!(muxer.flush_segment().is_none());\r\n    }\r\n}\r\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":60,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":61,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":90,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":93,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":103,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":111,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":114,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":115,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":118,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":131,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":139,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":143,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":145,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":146,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":147,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":148,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":152,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":153,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":155,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":156,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":157,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":201,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":202,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":203,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":204,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":205,"address":[],"length":0,"stats":{"Line":7566047373982433280}},{"line":206,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":209,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":210,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":211,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":212,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":213,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":214,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":215,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":216,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":219,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":220,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":223,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":224,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":227,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":228,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":232,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":234,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":237,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":238,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":239,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":240,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":241,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":242,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":243,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":244,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":245,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":246,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":248,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":249,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":250,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":251,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":252,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":253,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":254,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":255,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":258,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":260,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":261,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":262,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":263,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":264,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":265,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":266,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":267,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":269,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":272,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":273,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":276,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":277,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":280,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":281,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":283,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":286,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":287,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":288,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":289,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":290,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":291,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":292,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":293,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":294,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":295,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":296,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":297,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":298,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":300,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":301,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":302,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":303,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":304,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":306,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":307,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":308,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":311,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":312,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":315,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":316,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":319,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":320,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":323,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":324,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":326,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":329,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":330,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":331,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":332,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":333,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":334,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":335,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":336,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":337,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":338,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":341,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":342,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":343,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":344,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":345,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":346,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":347,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":348,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":351,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":352,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":355,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":356,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":359,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":360,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":363,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":364,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":366,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":369,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":370,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":371,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":372,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":373,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":376,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":378,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":379,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":380,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":382,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":383,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":384,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":385,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":387,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":390,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":391,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":394,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":395,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":398,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":399,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":402,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":403,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":406,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":407,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":410,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":411,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":413,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":416,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":417,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":419,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":420,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":421,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":422,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":423,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":426,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":427,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":428,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":429,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":430,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":431,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":432,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":433,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":434,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":435,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":436,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":437,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":438,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":439,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":440,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":441,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":444,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":445,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":447,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":450,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":451,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":452,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":453,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":454,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":455,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":456,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":457,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":458,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":459,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":460,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":461,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":462,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":463,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":466,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":467,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":468,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":469,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":470,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":473,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":474,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":475,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":476,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":477,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":480,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":481,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":482,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":483,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":484,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":485,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":488,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":489,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":490,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":491,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":492,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":499,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":506,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":509,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":510,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":513,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":516,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":519,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":520,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":523,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":524,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":525,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":528,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":529,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":532,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":535,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":540,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":543,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":549,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":552,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":553,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":556,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":557,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":559,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":562,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":563,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":564,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":565,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":566,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":569,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":574,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":577,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":578,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":581,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":582,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":585,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":586,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":588,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":591,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":593,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":594,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":595,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":596,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":599,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":601,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":602,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":603,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":604,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":607,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":614,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":616,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":618,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":619,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":620,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":623,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":625,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":626,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":627,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":629,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":636,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":641,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":642,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":644,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":646,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":649,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":650,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":653,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":305,"coverable":325},{"path":["C:","\\","Users","micha","repos","muxide","src","invariant_ppt.rs"],"content":"//! Invariant PPT Testing Framework\r\n//!\r\n//! This module provides runtime invariant checking and contract test support\r\n//! for Predictive Property-Based Testing (PPT).\r\n//!\r\n//! # Usage\r\n//!\r\n//! ```rust,ignore\r\n//! use muxide::invariant_ppt::*;\r\n//!\r\n//! // In production code - assert invariants\r\n//! assert_invariant!(\r\n//!     box_size == payload.len() + 8,\r\n//!     \"Box size must equal header + payload\"\r\n//! );\r\n//!\r\n//! // In tests - verify contracts are enforced\r\n//! #[test]\r\n//! fn contract_mp4_boxes() {\r\n//!     contract_test(\"mp4 boxes\", &[\r\n//!         \"Box size must equal header + payload\",\r\n//!     ]);\r\n//! }\r\n//! ```\r\n\r\nuse std::collections::HashSet;\r\nuse std::sync::RwLock;\r\n\r\nlazy_static::lazy_static! {\r\n    /// Global registry of checked invariants\r\n    static ref INVARIANT_LOG: RwLock<HashSet<String>> = RwLock::new(HashSet::new());\r\n}\r\n\r\n/// Assert an invariant and log it for contract testing.\r\n///\r\n/// # Arguments\r\n/// * `condition` - The invariant condition (must be true)\r\n/// * `message` - Description of the invariant\r\n/// * `context` - Optional context (module/function name)\r\n///\r\n/// # Panics\r\n/// Panics if the condition is false.\r\n#[macro_export]\r\nmacro_rules! assert_invariant {\r\n    ($condition:expr, $message:expr) => {\r\n        $crate::invariant_ppt::__assert_invariant_impl($condition, $message, None)\r\n    };\r\n    ($condition:expr, $message:expr, $context:expr) => {\r\n        $crate::invariant_ppt::__assert_invariant_impl($condition, $message, Some($context))\r\n    };\r\n}\r\n\r\n/// Internal implementation - do not call directly\r\n#[doc(hidden)]\r\npub fn __assert_invariant_impl(condition: bool, message: &str, context: Option<&str>) {\r\n    // Log that this invariant was checked (ignore poisoned lock)\r\n    if let Ok(mut log) = INVARIANT_LOG.write() {\r\n        log.insert(message.to_string());\r\n    }\r\n\r\n    if !condition {\r\n        let ctx = context.unwrap_or(\"unknown\");\r\n        panic!(\"INVARIANT VIOLATION [{}]: {}\", ctx, message);\r\n    }\r\n}\r\n\r\n/// Check that specific invariants were verified during test execution.\r\n///\r\n/// # Arguments\r\n/// * `test_name` - Name of the contract test\r\n/// * `required_invariants` - List of invariant messages that must have been checked\r\n///\r\n/// # Panics\r\n/// Panics if any required invariant was not checked.\r\npub fn contract_test(test_name: &str, required_invariants: &[&str]) {\r\n    let log = match INVARIANT_LOG.read() {\r\n        Ok(l) => l,\r\n        Err(poisoned) => poisoned.into_inner(),\r\n    };\r\n\r\n    let mut missing: Vec<&str> = Vec::new();\r\n    for invariant in required_invariants {\r\n        if !log.contains(*invariant) {\r\n            missing.push(invariant);\r\n        }\r\n    }\r\n\r\n    if !missing.is_empty() {\r\n        panic!(\r\n            \"CONTRACT FAILURE [{}]: The following invariants were not checked:\\n  - {}\",\r\n            test_name,\r\n            missing.join(\"\\n  - \")\r\n        );\r\n    }\r\n}\r\n\r\n/// Clear the invariant log (call between test runs if needed)\r\npub fn clear_invariant_log() {\r\n    if let Ok(mut log) = INVARIANT_LOG.write() {\r\n        log.clear();\r\n    }\r\n}\r\n\r\n/// Get a snapshot of currently logged invariants (for debugging)\r\npub fn get_logged_invariants() -> Vec<String> {\r\n    match INVARIANT_LOG.read() {\r\n        Ok(log) => log.iter().cloned().collect(),\r\n        Err(poisoned) => poisoned.into_inner().iter().cloned().collect(),\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_invariant_passes() {\r\n        clear_invariant_log();\r\n        assert_invariant!(true, \"test invariant passes\");\r\n        \r\n        let logged = get_logged_invariants();\r\n        assert!(logged.contains(&\"test invariant passes\".to_string()));\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic(expected = \"INVARIANT VIOLATION\")]\r\n    fn test_invariant_fails() {\r\n        assert_invariant!(false, \"this should fail\", \"test\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_contract_passes() {\r\n        clear_invariant_log();\r\n        assert_invariant!(true, \"contract required invariant\");\r\n        contract_test(\"test contract\", &[\"contract required invariant\"]);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic(expected = \"CONTRACT FAILURE\")]\r\n    fn test_contract_fails_missing() {\r\n        clear_invariant_log();\r\n        // Don't check any invariants\r\n        contract_test(\"test missing\", &[\"this invariant was never checked\"]);\r\n    }\r\n}\r\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":16573246628723425826}},{"line":57,"address":[],"length":0,"stats":{"Line":12826251738751173154}},{"line":58,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":61,"address":[],"length":0,"stats":{"Line":16573246628723425826}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151713928}},{"line":63,"address":[],"length":0,"stats":{"Line":144115188075856964}},{"line":75,"address":[],"length":0,"stats":{"Line":360287970189640226}},{"line":76,"address":[],"length":0,"stats":{"Line":720575940379280452}},{"line":77,"address":[],"length":0,"stats":{"Line":720575940379280452}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":1080863910568920678}},{"line":82,"address":[],"length":0,"stats":{"Line":1224979098644774366}},{"line":83,"address":[],"length":0,"stats":{"Line":936748722493061530}},{"line":84,"address":[],"length":0,"stats":{"Line":144115188075854780}},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189640226}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037928482}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037928482}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075856964}},{"line":98,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":99,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":108,"address":[],"length":0,"stats":{"Line":0}}],"covered":23,"coverable":25},{"path":["C:","\\","Users","micha","repos","muxide","src","lib.rs"],"content":"//! # Muxide\n//!\n//! **Zero-dependency pure-Rust MP4 muxer for recording applications.**\n//!\n//! ## Core Invariant\n//!\n//! > Muxide guarantees that any **correctly-timestamped**, **already-encoded** audio/video\n//! > stream can be turned into a **standards-compliant**, **immediately-playable** MP4\n//! > **without external tooling**.\n//!\n//! ## What Muxide Does\n//!\n//! - Accepts encoded H.264 (Annex B) video frames with timestamps\n//! - Accepts encoded AAC (ADTS) audio frames with timestamps  \n//! - Outputs MP4 files with fast-start (moov before mdat) for instant web playback\n//! - Supports B-frames via explicit PTS/DTS\n//! - Supports fragmented MP4 (fMP4) for DASH/HLS streaming\n//!\n//! ## What Muxide Does NOT Do\n//!\n//! - ❌ Encode or decode video/audio (use openh264, x264, etc.)\n//! - ❌ Read or demux MP4 files\n//! - ❌ Fix bad timestamps (rejects invalid input)\n//! - ❌ DRM, encryption, or content protection\n//! - ❌ MKV, WebM, or other container formats\n//!\n//! See `docs/charter.md` and `docs/contract.md` for full invariants.\n//!\n//! # Example\n//!\n//! ```no_run\n//! use muxide::api::{Muxer, MuxerConfig};\n//! use std::fs::File;\n//!\n//! # fn main() -> Result<(), Box<dyn std::error::Error>> {\n//! let file = File::create(\"out.mp4\")?;\n//! let config = MuxerConfig::new(1920, 1080, 30.0);\n//! let mut muxer = Muxer::new(file, config)?;\n//!\n//! // Write frames (encoded elsewhere).\n//! // muxer.write_video(pts_secs, annex_b_bytes, is_keyframe)?;\n//!\n//! let _stats = muxer.finish_with_stats()?;\n//! # Ok(())\n//! # }\n//! ```\n\nmod muxer;\n\n// Re-export the API module so users can simply `use muxide::api::...`.\npub mod api;\n\n// Fragmented MP4 support for streaming applications\npub mod fragmented;\n\n// Codec configuration extraction (minimal bitstream parsing)\npub mod codec;\n\n// Invariant PPT testing framework\npub mod invariant_ppt;\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","src","muxer","mod.rs"],"content":"pub mod mp4;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","src","muxer","mp4.rs"],"content":"use std::fmt;\nuse std::io::{self, Write};\n\nuse crate::api::{AudioCodec, Metadata, VideoCodec};\nuse crate::assert_invariant;\nuse crate::codec::h264::{AvcConfig, extract_avc_config, default_avc_config, annexb_to_avcc};\nuse crate::codec::h265::{HevcConfig, extract_hevc_config, hevc_annexb_to_hvcc};\nuse crate::codec::av1::{Av1Config, extract_av1_config};\nuse crate::codec::opus::{OpusConfig, is_valid_opus_packet, OPUS_SAMPLE_RATE};\n\nconst MOVIE_TIMESCALE: u32 = 1000;\n/// Track/media timebase used for converting `pts` seconds into MP4 sample deltas.\n///\n/// v0.1.0 uses a 90 kHz media timescale (common for MP4/H.264 workflows).\npub const MEDIA_TIMESCALE: u32 = 90_000;\n\n/// Video codec configuration extracted from the first keyframe.\n#[derive(Clone, Debug)]\npub enum VideoConfig {\n    /// H.264/AVC configuration (SPS + PPS)\n    Avc(AvcConfig),\n    /// H.265/HEVC configuration (VPS + SPS + PPS)\n    Hevc(HevcConfig),\n    /// AV1 configuration (Sequence Header OBU)\n    Av1(Av1Config),\n}\n\n/// Minimal MP4 writer used by the early slices.\npub struct Mp4Writer<Writer> {\n    writer: Writer,\n    video_codec: VideoCodec,\n    video_samples: Vec<SampleInfo>,\n    video_prev_pts: Option<u64>,\n    video_last_delta: Option<u32>,\n    video_config: Option<VideoConfig>,\n    audio_track: Option<Mp4AudioTrack>,\n    audio_samples: Vec<SampleInfo>,\n    audio_prev_pts: Option<u64>,\n    audio_last_delta: Option<u32>,\n    finalized: bool,\n    bytes_written: u64,\n}\n\n/// Simplified video track information used when writing the header.\npub struct Mp4VideoTrack {\n    pub width: u32,\n    pub height: u32,\n}\n\npub struct Mp4AudioTrack {\n    pub sample_rate: u32,\n    pub channels: u16,\n    pub codec: AudioCodec,\n}\n\nstruct SampleInfo {\n    pts: u64,\n    dts: u64,  // Decode time (for B-frames: dts != pts)\n    data: Vec<u8>,\n    is_keyframe: bool,\n    duration: Option<u32>,\n}\n\nstruct SampleTables {\n    durations: Vec<u32>,\n    sizes: Vec<u32>,\n    keyframes: Vec<u32>,\n    chunk_offsets: Vec<u32>,\n    samples_per_chunk: u32,\n    cts_offsets: Vec<i32>,  // Composition time offsets (pts - dts) for ctts box\n    has_bframes: bool,       // True if any sample has pts != dts\n}\n\nimpl SampleTables {\n    fn from_samples(\n        samples: &[SampleInfo],\n        chunk_offsets: Vec<u32>,\n        samples_per_chunk: u32,\n        fallback_duration: Option<u32>,\n    ) -> Self {\n        let sample_count = samples.len() as u32;\n        let mut durations = Vec::with_capacity(sample_count as usize);\n        for (idx, sample) in samples.iter().enumerate() {\n            let duration = sample.duration.unwrap_or_else(|| {\n                if idx == samples.len() - 1 {\n                    fallback_duration.unwrap_or(1)\n                } else {\n                    1\n                }\n            });\n            durations.push(duration);\n        }\n        let sizes = samples\n            .iter()\n            .map(|sample| sample.data.len() as u32)\n            .collect();\n        let keyframes = samples\n            .iter()\n            .enumerate()\n            .filter_map(|(idx, sample)| {\n                if sample.is_keyframe {\n                    Some(idx as u32 + 1)\n                } else {\n                    None\n                }\n            })\n            .collect();\n        \n        // Compute composition time offsets (cts = pts - dts)\n        let mut has_bframes = false;\n        let cts_offsets: Vec<i32> = samples\n            .iter()\n            .map(|sample| {\n                let offset = (sample.pts as i64 - sample.dts as i64) as i32;\n                if offset != 0 {\n                    has_bframes = true;\n                }\n                offset\n            })\n            .collect();\n        \n        let _ = sample_count;\n        Self {\n            durations,\n            sizes,\n            keyframes,\n            chunk_offsets,\n            samples_per_chunk,\n            cts_offsets,\n            has_bframes,\n        }\n    }\n    \n    /// Calculate total duration in media timescale units\n    fn total_duration(&self) -> u64 {\n        self.durations.iter().map(|&d| d as u64).sum()\n    }\n}\n\n/// Errors produced while queuing video samples.\n#[derive(Debug)]\npub enum Mp4WriterError {\n    /// Video frames must have strictly increasing timestamps.\n    NonIncreasingTimestamp,\n    /// The first frame must be a keyframe containing SPS/PPS data.\n    FirstFrameMustBeKeyframe,\n    /// The first keyframe must include SPS and PPS NAL units.\n    FirstFrameMissingSpsPps,\n    /// The first AV1 keyframe must include a Sequence Header OBU.\n    FirstFrameMissingSequenceHeader,\n    /// Audio sample is not a valid ADTS frame.\n    InvalidAdts,\n    /// Audio sample is not a valid Opus packet.\n    InvalidOpusPacket,\n    /// Audio track is not enabled on this writer.\n    AudioNotEnabled,\n    /// Computed sample duration overflowed a `u32`.\n    DurationOverflow,\n    /// The writer has already been finalised.\n    AlreadyFinalized,\n}\n\nimpl fmt::Display for Mp4WriterError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Mp4WriterError::NonIncreasingTimestamp => write!(f, \"timestamps must grow\"),\n            Mp4WriterError::FirstFrameMustBeKeyframe => {\n                write!(f, \"first frame must be a keyframe\")\n            }\n            Mp4WriterError::FirstFrameMissingSpsPps => {\n                write!(f, \"first frame must contain SPS/PPS\")\n            }\n            Mp4WriterError::FirstFrameMissingSequenceHeader => {\n                write!(f, \"first AV1 frame must contain Sequence Header OBU\")\n            }\n            Mp4WriterError::InvalidAdts => write!(f, \"invalid ADTS frame\"),\n            Mp4WriterError::InvalidOpusPacket => write!(f, \"invalid Opus packet\"),\n            Mp4WriterError::AudioNotEnabled => write!(f, \"audio track not enabled\"),\n            Mp4WriterError::DurationOverflow => write!(f, \"sample duration overflow\"),\n            Mp4WriterError::AlreadyFinalized => write!(f, \"writer already finalised\"),\n        }\n    }\n}\n\nimpl std::error::Error for Mp4WriterError {}\n\nimpl<Writer: Write> Mp4Writer<Writer> {\n    /// Wraps the provided writer for MP4 container output.\n    pub fn new(writer: Writer, video_codec: VideoCodec) -> Self {\n        Self {\n            writer,\n            video_codec,\n            video_samples: Vec::new(),\n            video_prev_pts: None,\n            video_last_delta: None,\n            video_config: None,\n            audio_track: None,\n            audio_samples: Vec::new(),\n            audio_prev_pts: None,\n            audio_last_delta: None,\n            finalized: false,\n            bytes_written: 0,\n        }\n    }\n\n    pub(crate) fn video_sample_count(&self) -> u64 {\n        self.video_samples.len() as u64\n    }\n\n    pub(crate) fn audio_sample_count(&self) -> u64 {\n        self.audio_samples.len() as u64\n    }\n\n    pub(crate) fn bytes_written(&self) -> u64 {\n        self.bytes_written\n    }\n\n    pub(crate) fn max_end_pts(&self) -> Option<u64> {\n        fn track_end(samples: &[SampleInfo], last_delta: Option<u32>) -> Option<u64> {\n            let last = samples.last()?;\n            Some(last.pts + u64::from(last_delta.unwrap_or(0)))\n        }\n\n        let video_end = track_end(&self.video_samples, self.video_last_delta);\n        let audio_end = track_end(&self.audio_samples, self.audio_last_delta);\n\n        match (video_end, audio_end) {\n            (Some(v), Some(a)) => Some(v.max(a)),\n            (Some(v), None) => Some(v),\n            (None, Some(a)) => Some(a),\n            (None, None) => None,\n        }\n    }\n\n    fn write_counted(writer: &mut Writer, bytes_written: &mut u64, buf: &[u8]) -> io::Result<()> {\n        *bytes_written = bytes_written.saturating_add(buf.len() as u64);\n        writer.write_all(buf)\n    }\n\n    pub fn enable_audio(&mut self, track: Mp4AudioTrack) {\n        self.audio_track = Some(track);\n    }\n\n    /// Queues a video sample for later `mdat` emission.\n    /// For backward compatibility, dts is assumed equal to pts.\n    pub fn write_video_sample(\n        &mut self,\n        pts: u64,\n        data: &[u8],\n        is_keyframe: bool,\n    ) -> Result<(), Mp4WriterError> {\n        self.write_video_sample_with_dts(pts, pts, data, is_keyframe)\n    }\n\n    /// Queues a video sample with explicit DTS for B-frame support.\n    /// - `pts`: Presentation timestamp (display order)\n    /// - `dts`: Decode timestamp (decode order) - must be monotonically increasing\n    pub fn write_video_sample_with_dts(\n        &mut self,\n        pts: u64,\n        dts: u64,\n        data: &[u8],\n        is_keyframe: bool,\n    ) -> Result<(), Mp4WriterError> {\n        if self.finalized {\n            return Err(Mp4WriterError::AlreadyFinalized);\n        }\n        // DTS must be monotonically increasing (decode order)\n        if let Some(prev) = self.video_prev_pts {\n            if dts <= prev {\n                return Err(Mp4WriterError::NonIncreasingTimestamp);\n            }\n            let delta = dts - prev;\n            if delta > u64::from(u32::MAX) {\n                return Err(Mp4WriterError::DurationOverflow);\n            }\n            let delta = delta as u32;\n            if let Some(last) = self.video_samples.last_mut() {\n                last.duration = Some(delta);\n            }\n            self.video_last_delta = Some(delta);\n        } else {\n            if !is_keyframe {\n                return Err(Mp4WriterError::FirstFrameMustBeKeyframe);\n            }\n            // Extract codec configuration based on video codec type\n            let config = match self.video_codec {\n                VideoCodec::H264 => {\n                    extract_avc_config(data).map(VideoConfig::Avc)\n                }\n                VideoCodec::H265 => {\n                    extract_hevc_config(data).map(VideoConfig::Hevc)\n                }\n                VideoCodec::Av1 => {\n                    extract_av1_config(data).map(VideoConfig::Av1)\n                }\n            };\n            if config.is_none() {\n                return Err(match self.video_codec {\n                    VideoCodec::Av1 => Mp4WriterError::FirstFrameMissingSequenceHeader,\n                    _ => Mp4WriterError::FirstFrameMissingSpsPps,\n                });\n            }\n            self.video_config = config;\n        }\n\n        // Convert Annex B to length-prefixed format based on codec\n        // AV1 uses OBU format which doesn't need conversion\n        let converted = match self.video_codec {\n            VideoCodec::H264 => annexb_to_avcc(data),\n            VideoCodec::H265 => hevc_annexb_to_hvcc(data),\n            VideoCodec::Av1 => data.to_vec(),  // AV1 OBUs passed as-is\n        };\n        if converted.len() > u32::MAX as usize {\n            return Err(Mp4WriterError::DurationOverflow);\n        }\n\n        self.video_samples.push(SampleInfo {\n            pts,\n            dts,\n            data: converted,\n            is_keyframe,\n            duration: None,\n        });\n        self.video_prev_pts = Some(dts);  // Track DTS for monotonic check\n        Ok(())\n    }\n\n    pub fn write_audio_sample(&mut self, pts: u64, data: &[u8]) -> Result<(), Mp4WriterError> {\n        if self.finalized {\n            return Err(Mp4WriterError::AlreadyFinalized);\n        }\n        let audio_track = self.audio_track.as_ref().ok_or(Mp4WriterError::AudioNotEnabled)?;\n\n        if let Some(prev) = self.audio_prev_pts {\n            if pts < prev {\n                return Err(Mp4WriterError::NonIncreasingTimestamp);\n            }\n            let delta = pts - prev;\n            if delta > u64::from(u32::MAX) {\n                return Err(Mp4WriterError::DurationOverflow);\n            }\n            let delta = delta as u32;\n            if let Some(last) = self.audio_samples.last_mut() {\n                last.duration = Some(delta);\n            }\n            self.audio_last_delta = Some(delta);\n        }\n\n        // Process audio data based on codec\n        let sample_data = match audio_track.codec {\n            AudioCodec::Aac => {\n                let raw = adts_to_raw(data).ok_or(Mp4WriterError::InvalidAdts)?;\n                raw.to_vec()\n            }\n            AudioCodec::Opus => {\n                // Validate Opus packet structure\n                if !is_valid_opus_packet(data) {\n                    return Err(Mp4WriterError::InvalidOpusPacket);\n                }\n                // Opus packets are passed through as-is (no container framing)\n                data.to_vec()\n            }\n            AudioCodec::None => {\n                return Err(Mp4WriterError::AudioNotEnabled);\n            }\n        };\n\n        if sample_data.len() > u32::MAX as usize {\n            return Err(Mp4WriterError::DurationOverflow);\n        }\n\n        self.audio_samples.push(SampleInfo {\n            pts,\n            dts: pts,  // Audio: dts == pts (no B-frames)\n            data: sample_data,\n            is_keyframe: false,\n            duration: None,\n        });\n        self.audio_prev_pts = Some(pts);\n        Ok(())\n    }\n\n    /// Finalises the MP4 file by writing the header boxes and sample data.\n    pub fn finalize(&mut self, video: &Mp4VideoTrack, metadata: Option<&Metadata>, fast_start: bool) -> io::Result<()> {\n        if self.finalized {\n            return Err(io::Error::new(\n                io::ErrorKind::Other,\n                \"mp4 writer already finalised\",\n            ));\n        }\n        self.finalized = true;\n\n        let video_config = self\n            .video_config\n            .clone()\n            .or_else(|| {\n                if self.video_samples.is_empty() {\n                    // Default config based on codec type\n                    match self.video_codec {\n                        VideoCodec::H264 => Some(VideoConfig::Avc(default_avc_config())),\n                        VideoCodec::H265 => None, // No default for HEVC, must have frames\n                        VideoCodec::Av1 => None, // No default for AV1, must have frames\n                    }\n                } else {\n                    None\n                }\n            })\n            .unwrap_or_else(|| VideoConfig::Avc(default_avc_config()));\n\n        if fast_start {\n            self.finalize_fast_start(video, metadata, &video_config)\n        } else {\n            self.finalize_standard(video, metadata, &video_config)\n        }\n    }\n\n    fn finalize_standard(&mut self, video: &Mp4VideoTrack, metadata: Option<&Metadata>, video_config: &VideoConfig) -> io::Result<()> {\n        let ftyp_box = build_ftyp_box();\n        let ftyp_len = ftyp_box.len() as u32;\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, &ftyp_box)?;\n\n        let audio_present = self.audio_track.is_some();\n\n        if !audio_present {\n            let chunk_offset = if !self.video_samples.is_empty() {\n                let mut payload_size: u32 = 0;\n                for sample in &self.video_samples {\n                    payload_size += sample.data.len() as u32;\n                }\n\n                let mdat_size = 8 + payload_size;\n                Self::write_counted(&mut self.writer, &mut self.bytes_written, &mdat_size.to_be_bytes())?;\n                Self::write_counted(&mut self.writer, &mut self.bytes_written, b\"mdat\")?;\n                for sample in &self.video_samples {\n                    Self::write_counted(&mut self.writer, &mut self.bytes_written, &sample.data)?;\n                }\n                Some(ftyp_len + 8)\n            } else {\n                None\n            };\n\n            let (chunk_offsets, samples_per_chunk) = match chunk_offset {\n                Some(offset) => (vec![offset], self.video_samples.len() as u32),\n                None => (Vec::new(), 0),\n            };\n\n            let tables = SampleTables::from_samples(\n                &self.video_samples,\n                chunk_offsets,\n                samples_per_chunk,\n                self.video_last_delta,\n            );\n            let moov_box = build_moov_box(video, &tables, None, video_config, metadata);\n            return Self::write_counted(&mut self.writer, &mut self.bytes_written, &moov_box);\n        }\n\n        // Audio present - write interleaved mdat then moov\n        let mut total_payload_size: u32 = 0;\n        for sample in &self.video_samples {\n            total_payload_size += sample.data.len() as u32;\n        }\n        for sample in &self.audio_samples {\n            total_payload_size += sample.data.len() as u32;\n        }\n\n        let mdat_size = 8 + total_payload_size;\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, &mdat_size.to_be_bytes())?;\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, b\"mdat\")?;\n\n        // Write interleaved samples and collect chunk offsets\n        let schedule = self.compute_interleave_schedule();\n        let mut video_chunk_offsets = Vec::with_capacity(self.video_samples.len());\n        let mut audio_chunk_offsets = Vec::with_capacity(self.audio_samples.len());\n        let mut cursor = ftyp_len + 8;  // After ftyp + mdat header\n\n        for (_, kind, idx) in schedule {\n            match kind {\n                TrackKind::Video => {\n                    video_chunk_offsets.push(cursor);\n                    let sample = &self.video_samples[idx];\n                    let sample_len = sample.data.len() as u32;\n                    Self::write_counted(&mut self.writer, &mut self.bytes_written, &sample.data)?;\n                    cursor += sample_len;\n                }\n                TrackKind::Audio => {\n                    audio_chunk_offsets.push(cursor);\n                    let sample = &self.audio_samples[idx];\n                    let sample_len = sample.data.len() as u32;\n                    Self::write_counted(&mut self.writer, &mut self.bytes_written, &sample.data)?;\n                    cursor += sample_len;\n                }\n            }\n        }\n\n        let video_tables = SampleTables::from_samples(\n            &self.video_samples,\n            video_chunk_offsets,\n            1,\n            self.video_last_delta,\n        );\n        let audio_tables = SampleTables::from_samples(\n            &self.audio_samples,\n            audio_chunk_offsets,\n            1,\n            self.audio_last_delta,\n        );\n\n        let audio_track = self.audio_track.as_ref().expect(\"audio_present implies track\");\n        let moov_box = build_moov_box(\n            video,\n            &video_tables,\n            Some((audio_track, &audio_tables)),\n            video_config,\n            metadata,\n        );\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, &moov_box)\n    }\n\n    fn finalize_fast_start(&mut self, video: &Mp4VideoTrack, metadata: Option<&Metadata>, video_config: &VideoConfig) -> io::Result<()> {\n        let ftyp_box = build_ftyp_box();\n        let ftyp_len = ftyp_box.len() as u32;\n\n        // Calculate total mdat payload size\n        let mut mdat_payload_size: u32 = 0;\n        for sample in &self.video_samples {\n            mdat_payload_size += sample.data.len() as u32;\n        }\n        for sample in &self.audio_samples {\n            mdat_payload_size += sample.data.len() as u32;\n        }\n        let mdat_header_size = 8u32;\n        let mdat_total_size = mdat_header_size + mdat_payload_size;\n\n        let audio_present = self.audio_track.is_some();\n\n        // Build moov with placeholder offsets to measure its size\n        let (placeholder_video_tables, placeholder_audio_tables) = if audio_present {\n            // For fast-start with audio, we need to compute interleaved offsets\n            // First, compute the interleave schedule\n            let schedule = self.compute_interleave_schedule();\n            \n            // Placeholder offsets - will be recalculated after we know moov size\n            let mut video_offsets = Vec::with_capacity(self.video_samples.len());\n            let mut audio_offsets = Vec::with_capacity(self.audio_samples.len());\n            let mut cursor = 0u32;\n            for (_, kind, _) in &schedule {\n                match kind {\n                    TrackKind::Video => {\n                        video_offsets.push(cursor);\n                        cursor += 1; // placeholder\n                    }\n                    TrackKind::Audio => {\n                        audio_offsets.push(cursor);\n                        cursor += 1; // placeholder\n                    }\n                }\n            }\n            \n            let video_tables = SampleTables::from_samples(&self.video_samples, video_offsets, 1, self.video_last_delta);\n            let audio_tables = SampleTables::from_samples(&self.audio_samples, audio_offsets, 1, self.audio_last_delta);\n            (video_tables, Some(audio_tables))\n        } else {\n            // Video-only: all samples in one chunk\n            let chunk_offsets = if self.video_samples.is_empty() {\n                Vec::new()\n            } else {\n                vec![0u32]  // Single placeholder chunk offset (will be replaced with real value)\n            };\n            let samples_per_chunk = if self.video_samples.is_empty() { 0 } else { self.video_samples.len() as u32 };\n            let video_tables = SampleTables::from_samples(\n                &self.video_samples,\n                chunk_offsets,\n                samples_per_chunk,\n                self.video_last_delta,\n            );\n            (video_tables, None)\n        };\n\n        let placeholder_moov = if let Some(ref audio_tables) = placeholder_audio_tables {\n            let audio_track = self.audio_track.as_ref().unwrap();\n            build_moov_box(video, &placeholder_video_tables, Some((audio_track, audio_tables)), video_config, metadata)\n        } else {\n            build_moov_box(video, &placeholder_video_tables, None, video_config, metadata)\n        };\n        let moov_len = placeholder_moov.len() as u32;\n\n        // Now we know: mdat starts at ftyp_len + moov_len\n        let mdat_data_start = ftyp_len + moov_len + mdat_header_size;\n\n        // Rebuild moov with correct offsets\n        let (final_video_tables, final_audio_tables) = if audio_present {\n            let schedule = self.compute_interleave_schedule();\n            \n            let mut video_offsets = Vec::with_capacity(self.video_samples.len());\n            let mut audio_offsets = Vec::with_capacity(self.audio_samples.len());\n            let mut cursor = mdat_data_start;\n            \n            for (_, kind, idx) in &schedule {\n                match kind {\n                    TrackKind::Video => {\n                        video_offsets.push(cursor);\n                        cursor += self.video_samples[*idx].data.len() as u32;\n                    }\n                    TrackKind::Audio => {\n                        audio_offsets.push(cursor);\n                        cursor += self.audio_samples[*idx].data.len() as u32;\n                    }\n                }\n            }\n            \n            let video_tables = SampleTables::from_samples(&self.video_samples, video_offsets, 1, self.video_last_delta);\n            let audio_tables = SampleTables::from_samples(&self.audio_samples, audio_offsets, 1, self.audio_last_delta);\n            (video_tables, Some(audio_tables))\n        } else {\n            // Video only - all samples in one chunk\n            let chunk_offsets = if self.video_samples.is_empty() {\n                Vec::new()\n            } else {\n                vec![mdat_data_start]\n            };\n            let samples_per_chunk = if self.video_samples.is_empty() { 0 } else { self.video_samples.len() as u32 };\n            let video_tables = SampleTables::from_samples(&self.video_samples, chunk_offsets, samples_per_chunk, self.video_last_delta);\n            (video_tables, None)\n        };\n\n        let final_moov = if let Some(ref audio_tables) = final_audio_tables {\n            let audio_track = self.audio_track.as_ref().unwrap();\n            build_moov_box(video, &final_video_tables, Some((audio_track, audio_tables)), video_config, metadata)\n        } else {\n            build_moov_box(video, &final_video_tables, None, video_config, metadata)\n        };\n\n        // Write: ftyp → moov → mdat header → samples\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, &ftyp_box)?;\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, &final_moov)?;\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, &mdat_total_size.to_be_bytes())?;\n        Self::write_counted(&mut self.writer, &mut self.bytes_written, b\"mdat\")?;\n\n        // Write samples in interleaved order\n        if audio_present {\n            let schedule = self.compute_interleave_schedule();\n            for (_, kind, idx) in schedule {\n                match kind {\n                    TrackKind::Video => {\n                        Self::write_counted(&mut self.writer, &mut self.bytes_written, &self.video_samples[idx].data)?;\n                    }\n                    TrackKind::Audio => {\n                        Self::write_counted(&mut self.writer, &mut self.bytes_written, &self.audio_samples[idx].data)?;\n                    }\n                }\n            }\n        } else {\n            for sample in &self.video_samples {\n                Self::write_counted(&mut self.writer, &mut self.bytes_written, &sample.data)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn compute_interleave_schedule(&self) -> Vec<(u64, TrackKind, usize)> {\n        let mut schedule: Vec<(u64, TrackKind, usize)> = Vec::new();\n        for (idx, sample) in self.video_samples.iter().enumerate() {\n            schedule.push((sample.pts, TrackKind::Video, idx));\n        }\n        for (idx, sample) in self.audio_samples.iter().enumerate() {\n            schedule.push((sample.pts, TrackKind::Audio, idx));\n        }\n        schedule.sort_by_key(|(pts, kind, idx)| {\n            let kind_order = match kind {\n                TrackKind::Video => 0u8,\n                TrackKind::Audio => 1u8,\n            };\n            (*pts, kind_order, *idx)\n        });\n        schedule\n    }\n}\n\n#[derive(Clone, Copy)]\nenum TrackKind {\n    Video,\n    Audio,\n}\n\nfn adts_to_raw(frame: &[u8]) -> Option<&[u8]> {\n    if frame.len() < 7 {\n        return None;\n    }\n\n    // Syncword 0xFFF (12 bits)\n    if frame[0] != 0xFF || (frame[1] & 0xF0) != 0xF0 {\n        return None;\n    }\n\n    let protection_absent = (frame[1] & 0x01) != 0;\n    let header_len = if protection_absent { 7 } else { 9 };\n    if frame.len() < header_len {\n        return None;\n    }\n\n    // aac_frame_length: 13 bits across bytes 3..5 (includes header)\n    let aac_frame_length: usize = (((frame[3] & 0x03) as usize) << 11)\n        | ((frame[4] as usize) << 3)\n        | (((frame[5] & 0xE0) as usize) >> 5);\n\n    if aac_frame_length < header_len || aac_frame_length > frame.len() {\n        return None;\n    }\n\n    Some(&frame[header_len..aac_frame_length])\n}\n\nfn build_moov_box(\n    video: &Mp4VideoTrack,\n    video_tables: &SampleTables,\n    audio: Option<(&Mp4AudioTrack, &SampleTables)>,\n    video_config: &VideoConfig,\n    metadata: Option<&Metadata>,\n) -> Vec<u8> {\n    // Calculate duration in media timescale, then convert to movie timescale (ms)\n    let video_duration_media = video_tables.total_duration();\n    let video_duration_ms = (video_duration_media * MOVIE_TIMESCALE as u64 / MEDIA_TIMESCALE as u64) as u32;\n    \n    let mvhd_payload = build_mvhd_payload(video_duration_ms);\n    let mvhd_box = build_box(b\"mvhd\", &mvhd_payload);\n    let trak_box = build_trak_box(video, video_tables, video_config);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&mvhd_box);\n    payload.extend_from_slice(&trak_box);\n    if let Some((audio_track, audio_tables)) = audio {\n        let audio_trak = build_audio_trak_box(audio_track, audio_tables);\n        payload.extend_from_slice(&audio_trak);\n    }\n    \n    // Add metadata (udta box) if present\n    if let Some(meta) = metadata {\n        let udta_box = build_udta_box(meta);\n        if !udta_box.is_empty() {\n            payload.extend_from_slice(&udta_box);\n        }\n    }\n    \n    build_box(b\"moov\", &payload)\n}\n\nfn build_audio_trak_box(audio: &Mp4AudioTrack, tables: &SampleTables) -> Vec<u8> {\n    let tkhd_box = build_audio_tkhd_box();\n    let mdia_box = build_audio_mdia_box(audio, tables);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&tkhd_box);\n    payload.extend_from_slice(&mdia_box);\n    build_box(b\"trak\", &payload)\n}\n\nfn build_audio_tkhd_box() -> Vec<u8> {\n    build_tkhd_box_with_id(2, 0x0100, 0, 0)\n}\n\nfn build_audio_mdia_box(audio: &Mp4AudioTrack, tables: &SampleTables) -> Vec<u8> {\n    let duration = tables.total_duration();\n    let mdhd_box = build_mdhd_box_with_timescale(MEDIA_TIMESCALE, duration);\n    let hdlr_box = build_sound_hdlr_box();\n    let minf_box = build_audio_minf_box(audio, tables);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&mdhd_box);\n    payload.extend_from_slice(&hdlr_box);\n    payload.extend_from_slice(&minf_box);\n    build_box(b\"mdia\", &payload)\n}\n\nfn build_audio_minf_box(audio: &Mp4AudioTrack, tables: &SampleTables) -> Vec<u8> {\n    let smhd_box = build_smhd_box();\n    let dinf_box = build_dinf_box();\n    let stbl_box = build_audio_stbl_box(audio, tables);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&smhd_box);\n    payload.extend_from_slice(&dinf_box);\n    payload.extend_from_slice(&stbl_box);\n    build_box(b\"minf\", &payload)\n}\n\nfn build_audio_stbl_box(audio: &Mp4AudioTrack, tables: &SampleTables) -> Vec<u8> {\n    let stsd_box = build_audio_stsd_box(audio);\n    let stts_box = build_stts_box(&tables.durations);\n    let stsc_box = build_stsc_box(tables.samples_per_chunk, tables.chunk_offsets.len() as u32);\n    let stsz_box = build_stsz_box(&tables.sizes);\n    let stco_box = build_stco_box(&tables.chunk_offsets);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&stsd_box);\n    payload.extend_from_slice(&stts_box);\n    payload.extend_from_slice(&stsc_box);\n    payload.extend_from_slice(&stsz_box);\n    payload.extend_from_slice(&stco_box);\n    build_box(b\"stbl\", &payload)\n}\n\nfn build_audio_stsd_box(audio: &Mp4AudioTrack) -> Vec<u8> {\n    let sample_entry_box = match audio.codec {\n        AudioCodec::Aac => build_mp4a_box(audio),\n        AudioCodec::Opus => build_opus_box(audio),\n        AudioCodec::None => build_mp4a_box(audio), // Fallback, shouldn't happen\n    };\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    payload.extend_from_slice(&sample_entry_box);\n    build_box(b\"stsd\", &payload)\n}\n\nfn build_mp4a_box(audio: &Mp4AudioTrack) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&[0u8; 6]);\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&audio.channels.to_be_bytes());\n    payload.extend_from_slice(&16u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    let rate_fixed = (audio.sample_rate as u32) << 16;\n    payload.extend_from_slice(&rate_fixed.to_be_bytes());\n    let esds = build_esds_box(audio);\n    payload.extend_from_slice(&esds);\n    build_box(b\"mp4a\", &payload)\n}\n\nfn build_esds_box(audio: &Mp4AudioTrack) -> Vec<u8> {\n    let asc = build_audio_specific_config(audio.sample_rate, audio.channels);\n\n    let mut dec_specific = Vec::new();\n    dec_specific.push(0x05);\n    dec_specific.push(asc.len() as u8);\n    dec_specific.extend_from_slice(&asc);\n\n    let mut dec_config_payload = Vec::new();\n    dec_config_payload.push(0x40);\n    dec_config_payload.push(0x15);\n    dec_config_payload.extend_from_slice(&[0x00, 0x00, 0x00]);\n    dec_config_payload.extend_from_slice(&0u32.to_be_bytes());\n    dec_config_payload.extend_from_slice(&0u32.to_be_bytes());\n    dec_config_payload.extend_from_slice(&dec_specific);\n\n    let mut dec_config = Vec::new();\n    dec_config.push(0x04);\n    dec_config.push(dec_config_payload.len() as u8);\n    dec_config.extend_from_slice(&dec_config_payload);\n\n    let sl_config = [0x06u8, 0x01u8, 0x02u8];\n\n    let mut es_payload = Vec::new();\n    es_payload.extend_from_slice(&1u16.to_be_bytes());\n    es_payload.push(0);\n    es_payload.extend_from_slice(&dec_config);\n    es_payload.extend_from_slice(&sl_config);\n\n    let mut es_desc = Vec::new();\n    es_desc.push(0x03);\n    es_desc.push(es_payload.len() as u8);\n    es_desc.extend_from_slice(&es_payload);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&es_desc);\n    build_box(b\"esds\", &payload)\n}\n\nfn build_audio_specific_config(sample_rate: u32, channels: u16) -> [u8; 2] {\n    let sfi = match sample_rate {\n        96000 => 0,\n        88200 => 1,\n        64000 => 2,\n        48000 => 3,\n        44100 => 4,\n        32000 => 5,\n        24000 => 6,\n        22050 => 7,\n        16000 => 8,\n        12000 => 9,\n        11025 => 10,\n        8000 => 11,\n        7350 => 12,\n        _ => 4,\n    };\n    let aot = 2u8;\n    let chan = (channels.min(15) as u8) & 0x0f;\n    let byte0 = (aot << 3) | (sfi >> 1);\n    let byte1 = ((sfi & 1) << 7) | (chan << 3);\n    [byte0, byte1]\n}\n\n/// Build an Opus sample entry box.\nfn build_opus_box(audio: &Mp4AudioTrack) -> Vec<u8> {\n    let mut payload = Vec::new();\n    // Reserved (6 bytes)\n    payload.extend_from_slice(&[0u8; 6]);\n    // Data reference index\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    // Reserved (2 x u32)\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    // Channel count\n    payload.extend_from_slice(&audio.channels.to_be_bytes());\n    // Sample size (16 bits)\n    payload.extend_from_slice(&16u16.to_be_bytes());\n    // Pre-defined\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    // Reserved\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    // Sample rate (fixed point 16.16, always 48000 for Opus)\n    let rate_fixed = (OPUS_SAMPLE_RATE as u32) << 16;\n    payload.extend_from_slice(&rate_fixed.to_be_bytes());\n    \n    // dOps box (Opus decoder configuration)\n    let dops = build_dops_box(audio);\n    payload.extend_from_slice(&dops);\n    \n    build_box(b\"Opus\", &payload)\n}\n\n/// Build the dOps (Opus Decoder Configuration) box.\n///\n/// Structure per ISO/IEC 14496-3 Amendment 4:\n/// - Version (1 byte) = 0\n/// - OutputChannelCount (1 byte)\n/// - PreSkip (2 bytes, big-endian)\n/// - InputSampleRate (4 bytes, big-endian)\n/// - OutputGain (2 bytes, signed, big-endian)\n/// - ChannelMappingFamily (1 byte)\n/// - If ChannelMappingFamily != 0:\n///   - StreamCount (1 byte)\n///   - CoupledCount (1 byte)\n///   - ChannelMapping (OutputChannelCount bytes)\nfn build_dops_box(audio: &Mp4AudioTrack) -> Vec<u8> {\n    let config = OpusConfig::default()\n        .with_channels(audio.channels as u8);\n    \n    let mut payload = Vec::new();\n    // Version = 0\n    payload.push(config.version);\n    // OutputChannelCount\n    payload.push(config.output_channel_count);\n    // PreSkip (big-endian)\n    payload.extend_from_slice(&config.pre_skip.to_be_bytes());\n    // InputSampleRate (big-endian)\n    payload.extend_from_slice(&config.input_sample_rate.to_be_bytes());\n    // OutputGain (signed, big-endian)\n    payload.extend_from_slice(&config.output_gain.to_be_bytes());\n    // ChannelMappingFamily\n    payload.push(config.channel_mapping_family);\n    \n    // Extended channel mapping for family != 0\n    if config.channel_mapping_family != 0 {\n        payload.push(config.stream_count.unwrap_or(1));\n        payload.push(config.coupled_count.unwrap_or(0));\n        if let Some(mapping) = &config.channel_mapping {\n            payload.extend_from_slice(mapping);\n        } else {\n            // Default mapping for stereo\n            for i in 0..config.output_channel_count {\n                payload.push(i);\n            }\n        }\n    }\n    \n    build_box(b\"dOps\", &payload)\n}\n\nfn build_trak_box(video: &Mp4VideoTrack, tables: &SampleTables, video_config: &VideoConfig) -> Vec<u8> {\n    let tkhd_box = build_tkhd_box(video);\n    let mdia_box = build_mdia_box(video, tables, video_config);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&tkhd_box);\n    payload.extend_from_slice(&mdia_box);\n    build_box(b\"trak\", &payload)\n}\n\nfn build_mdia_box(video: &Mp4VideoTrack, tables: &SampleTables, video_config: &VideoConfig) -> Vec<u8> {\n    let duration = tables.total_duration();\n    let mdhd_box = build_mdhd_box_with_timescale(MEDIA_TIMESCALE, duration);\n    let hdlr_box = build_hdlr_box();\n    let minf_box = build_minf_box(video, tables, video_config);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&mdhd_box);\n    payload.extend_from_slice(&hdlr_box);\n    payload.extend_from_slice(&minf_box);\n    build_box(b\"mdia\", &payload)\n}\n\nfn build_minf_box(video: &Mp4VideoTrack, tables: &SampleTables, video_config: &VideoConfig) -> Vec<u8> {\n    let vmhd_box = build_vmhd_box();\n    let dinf_box = build_dinf_box();\n    let stbl_box = build_stbl_box(video, tables, video_config);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&vmhd_box);\n    payload.extend_from_slice(&dinf_box);\n    payload.extend_from_slice(&stbl_box);\n    build_box(b\"minf\", &payload)\n}\n\nfn build_stbl_box(video: &Mp4VideoTrack, tables: &SampleTables, video_config: &VideoConfig) -> Vec<u8> {\n    let stsd_box = build_stsd_box(video, video_config);\n    let stts_box = build_stts_box(&tables.durations);\n    let stsc_box = build_stsc_box(tables.samples_per_chunk, tables.chunk_offsets.len() as u32);\n    let stsz_box = build_stsz_box(&tables.sizes);\n    let stco_box = build_stco_box(&tables.chunk_offsets);\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&stsd_box);\n    payload.extend_from_slice(&stts_box);\n    // Add ctts box if B-frames are present (pts != dts for any sample)\n    if tables.has_bframes {\n        let ctts_box = build_ctts_box(&tables.cts_offsets);\n        payload.extend_from_slice(&ctts_box);\n    }\n    payload.extend_from_slice(&stsc_box);\n    payload.extend_from_slice(&stsz_box);\n    payload.extend_from_slice(&stco_box);\n    if !tables.keyframes.is_empty() {\n        let stss_box = build_stss_box(&tables.keyframes);\n        payload.extend_from_slice(&stss_box);\n    }\n    build_box(b\"stbl\", &payload)\n}\n\nfn build_stsd_box(video: &Mp4VideoTrack, video_config: &VideoConfig) -> Vec<u8> {\n    let sample_entry = match video_config {\n        VideoConfig::Avc(avc_config) => build_avc1_box(video, avc_config),\n        VideoConfig::Hevc(hevc_config) => build_hvc1_box(video, hevc_config),\n        VideoConfig::Av1(av1_config) => build_av01_box(video, av1_config),\n    };\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    payload.extend_from_slice(&sample_entry);\n    build_box(b\"stsd\", &payload)\n}\n\nfn build_stts_box(durations: &[u32]) -> Vec<u8> {\n    let mut entries: Vec<(u32, u32)> = Vec::new();\n    for &duration in durations {\n        if let Some(last) = entries.last_mut() {\n            if last.1 == duration {\n                last.0 += 1;\n                continue;\n            }\n        }\n        entries.push((1u32, duration));\n    }\n\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&(entries.len() as u32).to_be_bytes());\n    for (count, delta) in entries {\n        payload.extend_from_slice(&count.to_be_bytes());\n        payload.extend_from_slice(&delta.to_be_bytes());\n    }\n    build_box(b\"stts\", &payload)\n}\n\nfn build_stsc_box(samples_per_chunk: u32, chunk_count: u32) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n\n    if chunk_count == 0 || samples_per_chunk == 0 {\n        payload.extend_from_slice(&0u32.to_be_bytes());\n        return build_box(b\"stsc\", &payload);\n    }\n\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    payload.extend_from_slice(&samples_per_chunk.to_be_bytes());\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    build_box(b\"stsc\", &payload)\n}\n\nfn build_stsz_box(sizes: &[u32]) -> Vec<u8> {\n    // INV-004: No empty samples (zero-size) in stsz\n    for (i, &size) in sizes.iter().enumerate() {\n        assert_invariant!(\n            size > 0,\n            \"No empty samples in stsz\",\n            &format!(\"build_stsz_box[{}]\", i)\n        );\n    }\n    \n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&(sizes.len() as u32).to_be_bytes());\n    for size in sizes {\n        payload.extend_from_slice(&size.to_be_bytes());\n    }\n    build_box(b\"stsz\", &payload)\n}\n\nfn build_stco_box(chunk_offsets: &[u32]) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n\n    payload.extend_from_slice(&(chunk_offsets.len() as u32).to_be_bytes());\n    for offset in chunk_offsets {\n        payload.extend_from_slice(&offset.to_be_bytes());\n    }\n    build_box(b\"stco\", &payload)\n}\n\nfn build_stss_box(keyframes: &[u32]) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&(keyframes.len() as u32).to_be_bytes());\n    for index in keyframes {\n        payload.extend_from_slice(&index.to_be_bytes());\n    }\n    build_box(b\"stss\", &payload)\n}\n\n/// Build ctts (Composition Time to Sample) box for B-frame support.\n/// Uses version 1 which supports signed offsets (required for some B-frame patterns).\nfn build_ctts_box(cts_offsets: &[i32]) -> Vec<u8> {\n    // Run-length encode the offsets\n    let mut entries: Vec<(u32, i32)> = Vec::new();\n    for &offset in cts_offsets {\n        if let Some(last) = entries.last_mut() {\n            if last.1 == offset {\n                last.0 += 1;\n                continue;\n            }\n        }\n        entries.push((1, offset));\n    }\n\n    let mut payload = Vec::new();\n    // Version 1 (supports signed offsets), flags 0\n    payload.extend_from_slice(&0x0100_0000_u32.to_be_bytes());\n    payload.extend_from_slice(&(entries.len() as u32).to_be_bytes());\n    for (count, offset) in entries {\n        payload.extend_from_slice(&count.to_be_bytes());\n        payload.extend_from_slice(&offset.to_be_bytes());\n    }\n    build_box(b\"ctts\", &payload)\n}\n\nfn build_avc1_box(video: &Mp4VideoTrack, avc_config: &AvcConfig) -> Vec<u8> {\n    // INV-002: Width/height must fit in 16-bit for visual sample entry\n    assert_invariant!(\n        video.width <= u16::MAX as u32,\n        \"Width must fit in 16-bit\",\n        \"build_avc1_box\"\n    );\n    assert_invariant!(\n        video.height <= u16::MAX as u32,\n        \"Height must fit in 16-bit\",\n        \"build_avc1_box\"\n    );\n    \n    let mut payload = Vec::new();\n    payload.extend_from_slice(&[0u8; 6]);\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    // Width and height are 16-bit values in the visual sample entry\n    payload.extend_from_slice(&(video.width as u16).to_be_bytes());\n    payload.extend_from_slice(&(video.height as u16).to_be_bytes());\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes());\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    payload.extend_from_slice(&[0u8; 32]);\n    payload.extend_from_slice(&0x0018u16.to_be_bytes());\n    payload.extend_from_slice(&0xffffu16.to_be_bytes());\n    let avc_c_box = build_avcc_box(avc_config);\n    payload.extend_from_slice(&avc_c_box);\n    build_box(b\"avc1\", &payload)\n}\n\nfn build_avcc_box(avc_config: &AvcConfig) -> Vec<u8> {\n    let mut payload = Vec::new();\n\n    let (profile_indication, profile_compat, level_indication) = if avc_config.sps.len() >= 4 {\n        (avc_config.sps[1], avc_config.sps[2], avc_config.sps[3])\n    } else {\n        (0x42, 0x00, 0x1e)\n    };\n\n    payload.push(1);\n    payload.push(profile_indication);\n    payload.push(profile_compat);\n    payload.push(level_indication);\n    payload.push(0xff);\n    payload.push(0xe1);\n    payload.extend_from_slice(&(avc_config.sps.len() as u16).to_be_bytes());\n    payload.extend_from_slice(&avc_config.sps);\n    payload.push(1);\n    payload.extend_from_slice(&(avc_config.pps.len() as u16).to_be_bytes());\n    payload.extend_from_slice(&avc_config.pps);\n    build_box(b\"avcC\", &payload)\n}\n\n/// Build an hvc1 sample entry box for HEVC video.\nfn build_hvc1_box(video: &Mp4VideoTrack, hevc_config: &HevcConfig) -> Vec<u8> {\n    // INV-002: Width/height must fit in 16-bit for visual sample entry\n    assert_invariant!(\n        video.width <= u16::MAX as u32,\n        \"Width must fit in 16-bit\",\n        \"build_hvc1_box\"\n    );\n    assert_invariant!(\n        video.height <= u16::MAX as u32,\n        \"Height must fit in 16-bit\",\n        \"build_hvc1_box\"\n    );\n    \n    let mut payload = Vec::new();\n    // Reserved (6 bytes)\n    payload.extend_from_slice(&[0u8; 6]);\n    // Data reference index\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    // Pre-defined + reserved\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    // Width and height are 16-bit values in the visual sample entry\n    payload.extend_from_slice(&(video.width as u16).to_be_bytes());\n    payload.extend_from_slice(&(video.height as u16).to_be_bytes());\n    // Horizontal/vertical resolution (72 dpi fixed point)\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes());\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes());\n    // Reserved\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    // Frame count\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    // Compressor name (32 bytes, empty)\n    payload.extend_from_slice(&[0u8; 32]);\n    // Depth\n    payload.extend_from_slice(&0x0018u16.to_be_bytes());\n    // Pre-defined\n    payload.extend_from_slice(&0xffffu16.to_be_bytes());\n    // hvcC box\n    let hvcc_box = build_hvcc_box(hevc_config);\n    payload.extend_from_slice(&hvcc_box);\n    build_box(b\"hvc1\", &payload)\n}\n\n/// Build an hvcC configuration box for HEVC.\nfn build_hvcc_box(hevc_config: &HevcConfig) -> Vec<u8> {\n    let mut payload = Vec::new();\n\n    // Extract profile/tier/level from SPS\n    let general_profile_space = hevc_config.general_profile_space();\n    let general_tier_flag = hevc_config.general_tier_flag();\n    let general_profile_idc = hevc_config.general_profile_idc();\n    let general_level_idc = hevc_config.general_level_idc();\n\n    // configurationVersion = 1\n    payload.push(1);\n    \n    // general_profile_space (2) + general_tier_flag (1) + general_profile_idc (5)\n    let byte1 = (general_profile_space << 6) \n              | (if general_tier_flag { 0x20 } else { 0 })\n              | (general_profile_idc & 0x1f);\n    payload.push(byte1);\n    \n    // general_profile_compatibility_flags (4 bytes)\n    // For simplicity, set Main profile compatibility (bit 1)\n    payload.extend_from_slice(&[0x60, 0x00, 0x00, 0x00]);\n    \n    // general_constraint_indicator_flags (6 bytes)\n    payload.extend_from_slice(&[0x90, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    \n    // general_level_idc\n    payload.push(general_level_idc);\n    \n    // min_spatial_segmentation_idc (12 bits) with reserved (4 bits)\n    payload.extend_from_slice(&[0xf0, 0x00]);\n    \n    // parallelismType (2 bits) with reserved (6 bits)\n    payload.push(0xfc);\n    \n    // chromaFormat (2 bits) with reserved (6 bits) - assume 4:2:0\n    payload.push(0xfd);\n    \n    // bitDepthLumaMinus8 (3 bits) with reserved (5 bits) - assume 8-bit\n    payload.push(0xf8);\n    \n    // bitDepthChromaMinus8 (3 bits) with reserved (5 bits) - assume 8-bit\n    payload.push(0xf8);\n    \n    // avgFrameRate (16 bits) - 0 = unspecified\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    \n    // constantFrameRate (2) + numTemporalLayers (3) + temporalIdNested (1) + lengthSizeMinusOne (2)\n    // lengthSizeMinusOne = 3 (4-byte NAL length)\n    payload.push(0x03);\n    \n    // numOfArrays = 3 (VPS, SPS, PPS)\n    payload.push(3);\n    \n    // VPS array\n    payload.push(0x20 | 32); // array_completeness=1 + nal_unit_type=32 (VPS)\n    payload.extend_from_slice(&1u16.to_be_bytes()); // numNalus = 1\n    payload.extend_from_slice(&(hevc_config.vps.len() as u16).to_be_bytes());\n    payload.extend_from_slice(&hevc_config.vps);\n    \n    // SPS array\n    payload.push(0x20 | 33); // array_completeness=1 + nal_unit_type=33 (SPS)\n    payload.extend_from_slice(&1u16.to_be_bytes()); // numNalus = 1\n    payload.extend_from_slice(&(hevc_config.sps.len() as u16).to_be_bytes());\n    payload.extend_from_slice(&hevc_config.sps);\n    \n    // PPS array\n    payload.push(0x20 | 34); // array_completeness=1 + nal_unit_type=34 (PPS)\n    payload.extend_from_slice(&1u16.to_be_bytes()); // numNalus = 1\n    payload.extend_from_slice(&(hevc_config.pps.len() as u16).to_be_bytes());\n    payload.extend_from_slice(&hevc_config.pps);\n    \n    build_box(b\"hvcC\", &payload)\n}\n\n/// Build an av01 sample entry box for AV1 video.\nfn build_av01_box(video: &Mp4VideoTrack, av1_config: &Av1Config) -> Vec<u8> {\n    // INV-002: Width/height must fit in 16-bit for visual sample entry\n    assert_invariant!(\n        video.width <= u16::MAX as u32,\n        \"Width must fit in 16-bit\",\n        \"build_av01_box\"\n    );\n    assert_invariant!(\n        video.height <= u16::MAX as u32,\n        \"Height must fit in 16-bit\",\n        \"build_av01_box\"\n    );\n    \n    let mut payload = Vec::new();\n    // Reserved (6 bytes)\n    payload.extend_from_slice(&[0u8; 6]);\n    // Data reference index\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    // Pre-defined + reserved\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    // Width and height are 16-bit values in the visual sample entry\n    payload.extend_from_slice(&(video.width as u16).to_be_bytes());\n    payload.extend_from_slice(&(video.height as u16).to_be_bytes());\n    // Horizontal/vertical resolution (72 dpi fixed point)\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes());\n    payload.extend_from_slice(&0x0048_0000_u32.to_be_bytes());\n    // Reserved\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    // Frame count\n    payload.extend_from_slice(&1u16.to_be_bytes());\n    // Compressor name (32 bytes, empty)\n    payload.extend_from_slice(&[0u8; 32]);\n    // Depth (24-bit)\n    payload.extend_from_slice(&0x0018u16.to_be_bytes());\n    // Pre-defined (-1)\n    payload.extend_from_slice(&0xffffu16.to_be_bytes());\n    // av1C box\n    let av1c_box = build_av1c_box(av1_config);\n    payload.extend_from_slice(&av1c_box);\n    build_box(b\"av01\", &payload)\n}\n\n/// Build an av1C configuration box for AV1.\n///\n/// ISO/IEC 14496-12:2022 and AV1 Codec ISO Media File Format Binding spec.\nfn build_av1c_box(av1_config: &Av1Config) -> Vec<u8> {\n    let mut payload = Vec::new();\n\n    // Byte 0: marker (1) + version (7) = 0x81\n    payload.push(0x81);\n    \n    // Byte 1: seq_profile (3) + seq_level_idx_0 (5)\n    let byte1 = ((av1_config.seq_profile & 0x07) << 5) \n              | (av1_config.seq_level_idx & 0x1f);\n    payload.push(byte1);\n    \n    // Byte 2: seq_tier_0 (1) + high_bitdepth (1) + twelve_bit (1) + monochrome (1) \n    //       + chroma_subsampling_x (1) + chroma_subsampling_y (1) + chroma_sample_position (2)\n    let byte2 = ((av1_config.seq_tier & 0x01) << 7)\n              | (if av1_config.high_bitdepth { 0x40 } else { 0 })\n              | (if av1_config.twelve_bit { 0x20 } else { 0 })\n              | (if av1_config.monochrome { 0x10 } else { 0 })\n              | (if av1_config.chroma_subsampling_x { 0x08 } else { 0 })\n              | (if av1_config.chroma_subsampling_y { 0x04 } else { 0 })\n              | (av1_config.chroma_sample_position & 0x03);\n    payload.push(byte2);\n    \n    // Byte 3: reserved (1) + initial_presentation_delay_present (1) + reserved (4) OR initial_presentation_delay_minus_one (4)\n    // Set to 0 (no initial presentation delay)\n    payload.push(0x00);\n    \n    // configOBUs: Append the Sequence Header OBU\n    payload.extend_from_slice(&av1_config.sequence_header);\n    \n    build_box(b\"av1C\", &payload)\n}\n\nfn build_vmhd_box() -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    build_box(b\"vmhd\", &payload)\n}\n\nfn build_dinf_box() -> Vec<u8> {\n    let dref_box = build_dref_box();\n    build_box(b\"dinf\", &dref_box)\n}\n\nfn build_dref_box() -> Vec<u8> {\n    let url_box = build_url_box();\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    payload.extend_from_slice(&url_box);\n    build_box(b\"dref\", &payload)\n}\n\nfn build_url_box() -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&1u32.to_be_bytes());\n    build_box(b\"url \", &payload)\n}\n\nfn build_mdhd_box() -> Vec<u8> {\n    build_mdhd_box_with_timescale_and_duration(MEDIA_TIMESCALE, 0)\n}\n\nfn build_mdhd_box_with_timescale(timescale: u32, duration: u64) -> Vec<u8> {\n    build_mdhd_box_with_timescale_and_duration(timescale, duration)\n}\n\nfn build_mdhd_box_with_timescale_and_duration(timescale: u32, duration: u64) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());  // version + flags\n    payload.extend_from_slice(&0u32.to_be_bytes());  // creation_time\n    payload.extend_from_slice(&0u32.to_be_bytes());  // modification_time\n    payload.extend_from_slice(&timescale.to_be_bytes());\n    payload.extend_from_slice(&(duration as u32).to_be_bytes());  // duration\n    payload.extend_from_slice(&0x55c4u16.to_be_bytes());  // language (und)\n    payload.extend_from_slice(&0u16.to_be_bytes());  // pre_defined\n    build_box(b\"mdhd\", &payload)\n}\n\nfn build_hdlr_box() -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(b\"vide\");\n    payload.extend_from_slice(&[0u8; 12]);\n    payload.extend_from_slice(b\"VideoHandler\");\n    payload.push(0);\n    build_box(b\"hdlr\", &payload)\n}\n\nfn build_sound_hdlr_box() -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(b\"soun\");\n    payload.extend_from_slice(&[0u8; 12]);\n    payload.extend_from_slice(b\"SoundHandler\");\n    payload.push(0);\n    build_box(b\"hdlr\", &payload)\n}\n\nfn build_smhd_box() -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    build_box(b\"smhd\", &payload)\n}\n\nfn build_tkhd_box(video: &Mp4VideoTrack) -> Vec<u8> {\n    build_tkhd_box_with_id(1, 0, video.width, video.height)\n}\n\nfn build_tkhd_box_with_id(track_id: u32, volume: u16, width: u32, height: u32) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&track_id.to_be_bytes());\n    payload.extend_from_slice(&0u32.to_be_bytes());\n    payload.extend_from_slice(&0u64.to_be_bytes());\n    payload.extend_from_slice(&0u64.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    payload.extend_from_slice(&volume.to_be_bytes());\n    payload.extend_from_slice(&0u16.to_be_bytes());\n    let matrix = [\n        0x0001_0000_u32,\n        0,\n        0,\n        0,\n        0x0001_0000_u32,\n        0,\n        0,\n        0,\n        0x4000_0000_u32,\n    ];\n    for value in matrix {\n        payload.extend_from_slice(&value.to_be_bytes());\n    }\n    let width_fixed = (width << 16) as u32;\n    let height_fixed = (height << 16) as u32;\n    payload.extend_from_slice(&width_fixed.to_be_bytes());\n    payload.extend_from_slice(&height_fixed.to_be_bytes());\n    build_box(b\"tkhd\", &payload)\n}\n\nfn build_ftyp_box() -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(b\"isom\");\n    payload.extend_from_slice(&0x200_u32.to_be_bytes());\n    payload.extend_from_slice(b\"isommp41\");\n    build_box(b\"ftyp\", &payload)\n}\n\nfn build_mvhd_payload(duration_ms: u32) -> Vec<u8> {\n    let mut payload = Vec::new();\n    payload.extend_from_slice(&0u32.to_be_bytes());  // version + flags\n    payload.extend_from_slice(&0u32.to_be_bytes());  // creation_time\n    payload.extend_from_slice(&0u32.to_be_bytes());  // modification_time\n    payload.extend_from_slice(&MOVIE_TIMESCALE.to_be_bytes());  // timescale (1000 = ms)\n    payload.extend_from_slice(&duration_ms.to_be_bytes());  // duration in ms\n    payload.extend_from_slice(&0x0001_0000_u32.to_be_bytes());  // rate (1.0)\n    payload.extend_from_slice(&0x0100u16.to_be_bytes());  // volume (1.0)\n    payload.extend_from_slice(&0u16.to_be_bytes());  // reserved\n    payload.extend_from_slice(&0u64.to_be_bytes());  // reserved\n    let matrix = [\n        0x0001_0000_u32,\n        0,\n        0,\n        0,\n        0x0001_0000_u32,\n        0,\n        0,\n        0,\n        0x4000_0000_u32,\n    ];\n    for value in matrix {\n        payload.extend_from_slice(&value.to_be_bytes());\n    }\n    for _ in 0..6 {\n        payload.extend_from_slice(&0u32.to_be_bytes());  // pre_defined\n    }\n    payload.extend_from_slice(&2u32.to_be_bytes());  // next_track_ID\n    payload\n}\n\nfn build_box(typ: &[u8; 4], payload: &[u8]) -> Vec<u8> {\n    let length = (8 + payload.len()) as u32;\n    let mut buffer = Vec::with_capacity(payload.len() + 8);\n    buffer.extend_from_slice(&length.to_be_bytes());\n    buffer.extend_from_slice(typ);\n    buffer.extend_from_slice(payload);\n    \n    // INV-001: Box size must equal header (8) + payload length\n    assert_invariant!(\n        buffer.len() == 8 + payload.len(),\n        \"Box size must equal header + payload\",\n        \"build_box\"\n    );\n    \n    buffer\n}\n\n// ============================================================================\n// Metadata (udta/meta/ilst) box building\n// ============================================================================\n\nfn build_udta_box(metadata: &Metadata) -> Vec<u8> {\n    let mut ilst_payload = Vec::new();\n    \n    if let Some(title) = &metadata.title {\n        ilst_payload.extend_from_slice(&build_ilst_string_item(b\"\\xa9nam\", title));\n    }\n    \n    if let Some(creation_time) = metadata.creation_time {\n        // Format as ISO 8601: \"YYYY-MM-DDTHH:MM:SSZ\"\n        let date_str = format_unix_timestamp(creation_time);\n        ilst_payload.extend_from_slice(&build_ilst_string_item(b\"\\xa9day\", &date_str));\n    }\n    \n    if ilst_payload.is_empty() {\n        return Vec::new();  // No metadata, skip udta entirely\n    }\n    \n    let ilst_box = build_box(b\"ilst\", &ilst_payload);\n    \n    // meta box requires hdlr\n    let hdlr_box = build_meta_hdlr_box();\n    \n    // meta is a full box (version + flags)\n    let mut meta_payload = vec![0u8; 4];  // version=0, flags=0\n    meta_payload.extend_from_slice(&hdlr_box);\n    meta_payload.extend_from_slice(&ilst_box);\n    let meta_box = build_box(b\"meta\", &meta_payload);\n    \n    build_box(b\"udta\", &meta_box)\n}\n\nfn build_ilst_string_item(atom_type: &[u8; 4], value: &str) -> Vec<u8> {\n    // data box: type indicator (1 = UTF-8) + locale (0) + string\n    let mut data_payload = Vec::new();\n    data_payload.extend_from_slice(&[0, 0, 0, 1]);  // type = UTF-8\n    data_payload.extend_from_slice(&[0, 0, 0, 0]);  // locale = 0\n    data_payload.extend_from_slice(value.as_bytes());\n    \n    let data_box = build_box(b\"data\", &data_payload);\n    build_box(atom_type, &data_box)\n}\n\nfn build_meta_hdlr_box() -> Vec<u8> {\n    let mut payload = vec![0u8; 4];  // version + flags\n    payload.extend_from_slice(&[0, 0, 0, 0]);  // pre_defined\n    payload.extend_from_slice(b\"mdir\");  // handler_type (metadata directory)\n    payload.extend_from_slice(b\"appl\");  // manufacturer\n    payload.extend_from_slice(&[0, 0, 0, 0]);  // reserved\n    payload.extend_from_slice(&[0, 0, 0, 0]);  // reserved\n    payload.push(0);  // name (empty, null-terminated)\n    build_box(b\"hdlr\", &payload)\n}\n\nfn format_unix_timestamp(unix_secs: u64) -> String {\n    // Simple conversion - days since epoch calculation\n    // This is approximate but good enough for metadata\n    const SECS_PER_MIN: u64 = 60;\n    const SECS_PER_HOUR: u64 = 3600;\n    const SECS_PER_DAY: u64 = 86400;\n    \n    let days_since_epoch = unix_secs / SECS_PER_DAY;\n    let remaining_secs = unix_secs % SECS_PER_DAY;\n    \n    let hours = remaining_secs / SECS_PER_HOUR;\n    let minutes = (remaining_secs % SECS_PER_HOUR) / SECS_PER_MIN;\n    let seconds = remaining_secs % SECS_PER_MIN;\n    \n    // Calculate year, month, day from days since 1970-01-01\n    // Using a simplified algorithm\n    let (year, month, day) = days_to_ymd(days_since_epoch);\n    \n    format!(\"{:04}-{:02}-{:02}T{:02}:{:02}:{:02}Z\", year, month, day, hours, minutes, seconds)\n}\n\nfn days_to_ymd(days: u64) -> (u32, u32, u32) {\n    // Simplified algorithm - works for dates from 1970 to ~2100\n    let mut remaining_days = days as i64;\n    let mut year = 1970u32;\n    \n    loop {\n        let days_in_year = if is_leap_year(year) { 366 } else { 365 };\n        if remaining_days < days_in_year {\n            break;\n        }\n        remaining_days -= days_in_year;\n        year += 1;\n    }\n    \n    let days_in_months: [i64; 12] = if is_leap_year(year) {\n        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    } else {\n        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    \n    let mut month = 1u32;\n    for &days_in_month in &days_in_months {\n        if remaining_days < days_in_month {\n            break;\n        }\n        remaining_days -= days_in_month;\n        month += 1;\n    }\n    \n    let day = (remaining_days + 1) as u32;\n    (year, month, day)\n}\n\nfn is_leap_year(year: u32) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}\n","traces":[{"line":75,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":81,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":82,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":83,"address":[],"length":0,"stats":{"Line":16357073846609641500}},{"line":84,"address":[],"length":0,"stats":{"Line":15564440312192434218}},{"line":85,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":86,"address":[],"length":0,"stats":{"Line":9655717601082343452}},{"line":88,"address":[],"length":0,"stats":{"Line":18446744073709551602}},{"line":91,"address":[],"length":0,"stats":{"Line":10736581511651262506}},{"line":93,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":95,"address":[],"length":0,"stats":{"Line":6124895493223874588}},{"line":97,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":100,"address":[],"length":0,"stats":{"Line":14843864371813155031}},{"line":101,"address":[],"length":0,"stats":{"Line":9727775195120271575}},{"line":102,"address":[],"length":0,"stats":{"Line":4107282860161892567}},{"line":104,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":110,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":111,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":113,"address":[],"length":0,"stats":{"Line":14843864371813154830}},{"line":114,"address":[],"length":0,"stats":{"Line":1008806316530991132}},{"line":115,"address":[],"length":0,"stats":{"Line":10160120759347839205}},{"line":116,"address":[],"length":0,"stats":{"Line":432345564227567831}},{"line":118,"address":[],"length":0,"stats":{"Line":9727775195120271374}},{"line":122,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":135,"address":[],"length":0,"stats":{"Line":9511602413006487781}},{"line":136,"address":[],"length":0,"stats":{"Line":9367487224930632367}},{"line":164,"address":[],"length":0,"stats":{"Line":28}},{"line":165,"address":[],"length":0,"stats":{"Line":28}},{"line":166,"address":[],"length":0,"stats":{"Line":84}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":193,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":198,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":206,"address":[],"length":0,"stats":{"Line":2233785415175766023}},{"line":207,"address":[],"length":0,"stats":{"Line":2233785415175766023}},{"line":210,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":211,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":214,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":215,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":218,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":219,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":220,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":221,"address":[],"length":0,"stats":{"Line":7349874591868649430}},{"line":224,"address":[],"length":0,"stats":{"Line":8935141660703064064}},{"line":225,"address":[],"length":0,"stats":{"Line":8935141660703064064}},{"line":227,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":228,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":229,"address":[],"length":0,"stats":{"Line":3458764513820540914}},{"line":230,"address":[],"length":0,"stats":{"Line":14}},{"line":231,"address":[],"length":0,"stats":{"Line":144115188075855865}},{"line":235,"address":[],"length":0,"stats":{"Line":13835058055282163719}},{"line":236,"address":[],"length":0,"stats":{"Line":4611686018427387925}},{"line":237,"address":[],"length":0,"stats":{"Line":4611686018427387925}},{"line":240,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":241,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":246,"address":[],"length":0,"stats":{"Line":5404319552844595207}},{"line":252,"address":[],"length":0,"stats":{"Line":13979173243358019626}},{"line":258,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":265,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":266,"address":[],"length":0,"stats":{"Line":108}},{"line":269,"address":[],"length":0,"stats":{"Line":7998392938210000680}},{"line":270,"address":[],"length":0,"stats":{"Line":2161727821137837972}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":4323455642275675944}},{"line":274,"address":[],"length":0,"stats":{"Line":2161727821137837972}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":4323455642275675944}},{"line":278,"address":[],"length":0,"stats":{"Line":6485183463413513916}},{"line":279,"address":[],"length":0,"stats":{"Line":2161727821137837972}},{"line":281,"address":[],"length":0,"stats":{"Line":2161727821137837972}},{"line":283,"address":[],"length":0,"stats":{"Line":3674937295934324736}},{"line":284,"address":[],"length":0,"stats":{"Line":288230376151711736}},{"line":287,"address":[],"length":0,"stats":{"Line":6773413839565226000}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":432345564227567640}},{"line":298,"address":[],"length":0,"stats":{"Line":6773413839565226000}},{"line":299,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":301,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":304,"address":[],"length":0,"stats":{"Line":6052837899185946640}},{"line":309,"address":[],"length":0,"stats":{"Line":10376293541461622584}},{"line":310,"address":[],"length":0,"stats":{"Line":9943947977234054968}},{"line":311,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":312,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":314,"address":[],"length":0,"stats":{"Line":10376293541461622584}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":15564440312192433876}},{"line":319,"address":[],"length":0,"stats":{"Line":10376293541461622584}},{"line":320,"address":[],"length":0,"stats":{"Line":10376293541461622584}},{"line":321,"address":[],"length":0,"stats":{"Line":10376293541461622584}},{"line":322,"address":[],"length":0,"stats":{"Line":5188146770730811292}},{"line":323,"address":[],"length":0,"stats":{"Line":5188146770730811292}},{"line":325,"address":[],"length":0,"stats":{"Line":5188146770730811292}},{"line":326,"address":[],"length":0,"stats":{"Line":5188146770730811292}},{"line":329,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":330,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":335,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":336,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":340,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":344,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":345,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":347,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":351,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":354,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":3026418949592973312}},{"line":374,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":375,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":376,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":377,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":378,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":380,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":381,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":385,"address":[],"length":0,"stats":{"Line":2233785415175766024}},{"line":386,"address":[],"length":0,"stats":{"Line":2233785415175766024}},{"line":387,"address":[],"length":0,"stats":{"Line":7}},{"line":388,"address":[],"length":0,"stats":{"Line":7}},{"line":389,"address":[],"length":0,"stats":{"Line":7}},{"line":392,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":394,"address":[],"length":0,"stats":{"Line":4467570830351532034}},{"line":395,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":397,"address":[],"length":0,"stats":{"Line":2377900603251621889}},{"line":398,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":400,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":401,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":411,"address":[],"length":0,"stats":{"Line":2233785415175766017}},{"line":412,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":414,"address":[],"length":0,"stats":{"Line":360287970189639685}},{"line":418,"address":[],"length":0,"stats":{"Line":72057594037928072}},{"line":419,"address":[],"length":0,"stats":{"Line":144115188075856144}},{"line":420,"address":[],"length":0,"stats":{"Line":144115188075856144}},{"line":421,"address":[],"length":0,"stats":{"Line":288230376151712288}},{"line":423,"address":[],"length":0,"stats":{"Line":216172782113784216}},{"line":425,"address":[],"length":0,"stats":{"Line":72057594037928072}},{"line":426,"address":[],"length":0,"stats":{"Line":144115188075856008}},{"line":427,"address":[],"length":0,"stats":{"Line":216172782113784216}},{"line":428,"address":[],"length":0,"stats":{"Line":288230376151711472}},{"line":429,"address":[],"length":0,"stats":{"Line":72057594037927800}},{"line":432,"address":[],"length":0,"stats":{"Line":144115188075856144}},{"line":433,"address":[],"length":0,"stats":{"Line":288230376151712288}},{"line":434,"address":[],"length":0,"stats":{"Line":288230376151712288}},{"line":435,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":436,"address":[],"length":0,"stats":{"Line":288230376151711880}},{"line":438,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":444,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":450,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":451,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":452,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":454,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":455,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":2161727821137838188}},{"line":521,"address":[],"length":0,"stats":{"Line":4323455642275676376}},{"line":522,"address":[],"length":0,"stats":{"Line":4323455642275676376}},{"line":525,"address":[],"length":0,"stats":{"Line":6485183463413514564}},{"line":526,"address":[],"length":0,"stats":{"Line":14051230837395947325}},{"line":527,"address":[],"length":0,"stats":{"Line":3963167672086036379}},{"line":529,"address":[],"length":0,"stats":{"Line":4755801206503243902}},{"line":530,"address":[],"length":0,"stats":{"Line":864691128455135238}},{"line":532,"address":[],"length":0,"stats":{"Line":4323455642275676376}},{"line":533,"address":[],"length":0,"stats":{"Line":4323455642275676376}},{"line":535,"address":[],"length":0,"stats":{"Line":6485183463413514564}},{"line":538,"address":[],"length":0,"stats":{"Line":6485183463413514564}},{"line":541,"address":[],"length":0,"stats":{"Line":1080863910568919061}},{"line":544,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":545,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":546,"address":[],"length":0,"stats":{"Line":720575940379279374}},{"line":547,"address":[],"length":0,"stats":{"Line":3674937295934324729}},{"line":548,"address":[],"length":0,"stats":{"Line":1657324662872342521}},{"line":549,"address":[],"length":0,"stats":{"Line":792633534417207289}},{"line":550,"address":[],"length":0,"stats":{"Line":2377900603251621867}},{"line":551,"address":[],"length":0,"stats":{"Line":792633534417207289}},{"line":553,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":554,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":555,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":560,"address":[],"length":0,"stats":{"Line":1801439850948198435}},{"line":561,"address":[],"length":0,"stats":{"Line":1801439850948198435}},{"line":562,"address":[],"length":0,"stats":{"Line":360287970189639687}},{"line":565,"address":[],"length":0,"stats":{"Line":5404319552844595503}},{"line":566,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":568,"address":[],"length":0,"stats":{"Line":1657324662872342629}},{"line":570,"address":[],"length":0,"stats":{"Line":7205759403792794004}},{"line":572,"address":[],"length":0,"stats":{"Line":1801439850948198501}},{"line":573,"address":[],"length":0,"stats":{"Line":1801439850948198501}},{"line":574,"address":[],"length":0,"stats":{"Line":1801439850948198501}},{"line":575,"address":[],"length":0,"stats":{"Line":1801439850948198501}},{"line":577,"address":[],"length":0,"stats":{"Line":1801439850948198501}},{"line":580,"address":[],"length":0,"stats":{"Line":4683743612465316164}},{"line":581,"address":[],"length":0,"stats":{"Line":1441151880758559152}},{"line":582,"address":[],"length":0,"stats":{"Line":2161727821137838728}},{"line":584,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":586,"address":[],"length":0,"stats":{"Line":4323455642275676376}},{"line":589,"address":[],"length":0,"stats":{"Line":4323455642275676376}},{"line":592,"address":[],"length":0,"stats":{"Line":6485183463413514564}},{"line":593,"address":[],"length":0,"stats":{"Line":1080863910568919061}},{"line":595,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":596,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":597,"address":[],"length":0,"stats":{"Line":720575940379279374}},{"line":599,"address":[],"length":0,"stats":{"Line":5332261958806667250}},{"line":600,"address":[],"length":0,"stats":{"Line":1657324662872342521}},{"line":601,"address":[],"length":0,"stats":{"Line":792633534417207289}},{"line":602,"address":[],"length":0,"stats":{"Line":3170534137668829156}},{"line":603,"address":[],"length":0,"stats":{"Line":792633534417207289}},{"line":605,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":606,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":607,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":612,"address":[],"length":0,"stats":{"Line":1801439850948198435}},{"line":613,"address":[],"length":0,"stats":{"Line":1801439850948198435}},{"line":614,"address":[],"length":0,"stats":{"Line":360287970189639687}},{"line":617,"address":[],"length":0,"stats":{"Line":5404319552844595503}},{"line":618,"address":[],"length":0,"stats":{"Line":144115188075855979}},{"line":620,"address":[],"length":0,"stats":{"Line":3314649325744685044}},{"line":622,"address":[],"length":0,"stats":{"Line":7205759403792794004}},{"line":623,"address":[],"length":0,"stats":{"Line":10808639105689191006}},{"line":624,"address":[],"length":0,"stats":{"Line":1801439850948198501}},{"line":627,"address":[],"length":0,"stats":{"Line":4683743612465316164}},{"line":628,"address":[],"length":0,"stats":{"Line":1441151880758559152}},{"line":629,"address":[],"length":0,"stats":{"Line":2161727821137838728}},{"line":631,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":635,"address":[],"length":0,"stats":{"Line":8646911284551352759}},{"line":636,"address":[],"length":0,"stats":{"Line":8646911284551352724}},{"line":637,"address":[],"length":0,"stats":{"Line":8646911284551352724}},{"line":638,"address":[],"length":0,"stats":{"Line":8646911284551352724}},{"line":641,"address":[],"length":0,"stats":{"Line":2161727821137838181}},{"line":642,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":643,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":644,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":654,"address":[],"length":0,"stats":{"Line":8142508126285856882}},{"line":655,"address":[],"length":0,"stats":{"Line":12682136550675317407}},{"line":659,"address":[],"length":0,"stats":{"Line":2161727821137837966}},{"line":662,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":663,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":664,"address":[],"length":0,"stats":{"Line":9295429630892703744}},{"line":665,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":667,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":668,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":670,"address":[],"length":0,"stats":{"Line":16429131440647569411}},{"line":671,"address":[],"length":0,"stats":{"Line":10088063165309911046}},{"line":672,"address":[],"length":0,"stats":{"Line":7566047373982433283}},{"line":673,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":675,"address":[],"length":0,"stats":{"Line":10088063165309911046}},{"line":677,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":687,"address":[],"length":0,"stats":{"Line":936748722493063175}},{"line":688,"address":[],"length":0,"stats":{"Line":936748722493063175}},{"line":689,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":693,"address":[],"length":0,"stats":{"Line":1585267068834414606}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":1585267068834414606}},{"line":698,"address":[],"length":0,"stats":{"Line":2377900603251621909}},{"line":699,"address":[],"length":0,"stats":{"Line":1585267068834414606}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":2377900603251621909}},{"line":705,"address":[],"length":0,"stats":{"Line":792633534417207303}},{"line":706,"address":[],"length":0,"stats":{"Line":792633534417207303}},{"line":708,"address":[],"length":0,"stats":{"Line":2377900603251621909}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":1585267068834414606}},{"line":715,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":723,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":724,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":726,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":727,"address":[],"length":0,"stats":{"Line":17582052945254416384}},{"line":728,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":730,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":731,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":732,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":733,"address":[],"length":0,"stats":{"Line":6557241057451442134}},{"line":734,"address":[],"length":0,"stats":{"Line":3602879701896396730}},{"line":735,"address":[],"length":0,"stats":{"Line":1441151880758558692}},{"line":739,"address":[],"length":0,"stats":{"Line":4539628424389459954}},{"line":740,"address":[],"length":0,"stats":{"Line":432345564227567574}},{"line":741,"address":[],"length":0,"stats":{"Line":288230376151711702}},{"line":742,"address":[],"length":0,"stats":{"Line":288230376151711688}},{"line":746,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":749,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":750,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":751,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":753,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":754,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":755,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":756,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":759,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":760,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":763,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":764,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":765,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":766,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":767,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":769,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":770,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":771,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":772,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":773,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":776,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":777,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":778,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":779,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":781,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":782,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":783,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":784,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":785,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":788,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":789,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":790,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":791,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":792,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":793,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":795,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":796,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":797,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":798,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":799,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":800,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":801,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":804,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":805,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":806,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":807,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":812,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":813,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":814,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":815,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":818,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":819,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":820,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":821,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":822,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":823,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":824,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":825,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":826,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":827,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":828,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":829,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":830,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":831,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":832,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":835,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":836,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":838,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":839,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":840,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":841,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":843,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":844,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":845,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":846,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":847,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":848,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":849,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":851,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":852,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":853,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":854,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":856,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":858,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":859,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":860,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":861,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":862,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":864,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":865,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":866,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":867,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":869,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":870,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":871,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":872,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":875,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":876,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":893,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":894,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":895,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":896,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":900,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":901,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":903,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":905,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":907,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":908,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":910,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":912,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":914,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":916,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":918,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":919,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":922,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":923,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":925,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":941,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":942,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":943,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":945,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":947,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":949,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":951,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":953,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":955,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":957,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":960,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":976,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":977,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":978,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":980,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":981,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":982,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":983,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":986,"address":[],"length":0,"stats":{"Line":4395513236313604110}},{"line":987,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":988,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":989,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":990,"address":[],"length":0,"stats":{"Line":3530822107858468934}},{"line":992,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":993,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":994,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":995,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":996,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":999,"address":[],"length":0,"stats":{"Line":4395513236313604110}},{"line":1000,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":1001,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":1002,"address":[],"length":0,"stats":{"Line":3530822107858468934}},{"line":1004,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":1005,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1006,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1007,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1008,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1011,"address":[],"length":0,"stats":{"Line":4395513236313604110}},{"line":1012,"address":[],"length":0,"stats":{"Line":17582052945254416440}},{"line":1013,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1014,"address":[],"length":0,"stats":{"Line":17582052945254416440}},{"line":1015,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1016,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1018,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":1019,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1020,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1022,"address":[],"length":0,"stats":{"Line":4539628424389459996}},{"line":1023,"address":[],"length":0,"stats":{"Line":576460752303423544}},{"line":1024,"address":[],"length":0,"stats":{"Line":288230376151711772}},{"line":1026,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1027,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1028,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1029,"address":[],"length":0,"stats":{"Line":8502796096475496476}},{"line":1030,"address":[],"length":0,"stats":{"Line":16429131440647569464}},{"line":1031,"address":[],"length":0,"stats":{"Line":8214565720323784732}},{"line":1033,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1036,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":1037,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":1038,"address":[],"length":0,"stats":{"Line":16429131440647569352}},{"line":1039,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":1040,"address":[],"length":0,"stats":{"Line":576460752303423544}},{"line":1043,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":1044,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1045,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1046,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1047,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1050,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":1051,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1052,"address":[],"length":0,"stats":{"Line":6124895493223874588}},{"line":1053,"address":[],"length":0,"stats":{"Line":14627691589699370807}},{"line":1054,"address":[],"length":0,"stats":{"Line":4899916394579099433}},{"line":1055,"address":[],"length":0,"stats":{"Line":4899916394579099419}},{"line":1056,"address":[],"length":0,"stats":{"Line":4899916394579099419}},{"line":1059,"address":[],"length":0,"stats":{"Line":14483576401623515865}},{"line":1062,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":1063,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1064,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1065,"address":[],"length":0,"stats":{"Line":5980780305148018688}},{"line":1066,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":1067,"address":[],"length":0,"stats":{"Line":14483576401623515136}},{"line":1069,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1072,"address":[],"length":0,"stats":{"Line":5116089176692883484}},{"line":1073,"address":[],"length":0,"stats":{"Line":10232178353385766968}},{"line":1074,"address":[],"length":0,"stats":{"Line":15348267530078650452}},{"line":1076,"address":[],"length":0,"stats":{"Line":9943947977234055210}},{"line":1077,"address":[],"length":0,"stats":{"Line":864691128455135274}},{"line":1078,"address":[],"length":0,"stats":{"Line":864691128455135274}},{"line":1081,"address":[],"length":0,"stats":{"Line":14483576401623515178}},{"line":1082,"address":[],"length":0,"stats":{"Line":14483576401623515178}},{"line":1083,"address":[],"length":0,"stats":{"Line":14483576401623515178}},{"line":1084,"address":[],"length":0,"stats":{"Line":14483576401623515178}},{"line":1085,"address":[],"length":0,"stats":{"Line":14483576401623515178}},{"line":1088,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":1090,"address":[],"length":0,"stats":{"Line":7638104968020361258}},{"line":1091,"address":[],"length":0,"stats":{"Line":1008806316530991132}},{"line":1092,"address":[],"length":0,"stats":{"Line":1008806316530991132}},{"line":1093,"address":[],"length":0,"stats":{"Line":1008806316530991132}},{"line":1094,"address":[],"length":0,"stats":{"Line":9727775195120271374}},{"line":1098,"address":[],"length":0,"stats":{"Line":10232178353385766912}},{"line":1099,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1100,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1101,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1102,"address":[],"length":0,"stats":{"Line":15852670688344146607}},{"line":1103,"address":[],"length":0,"stats":{"Line":10736581511651263151}},{"line":1105,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":1108,"address":[],"length":0,"stats":{"Line":5116089176692883685}},{"line":1109,"address":[],"length":0,"stats":{"Line":10232178353385767370}},{"line":1110,"address":[],"length":0,"stats":{"Line":15348267530078651055}},{"line":1112,"address":[],"length":0,"stats":{"Line":15348267530078651055}},{"line":1113,"address":[],"length":0,"stats":{"Line":6773413839565225568}},{"line":1114,"address":[],"length":0,"stats":{"Line":1657324662872341883}},{"line":1116,"address":[],"length":0,"stats":{"Line":15348267530078651055}},{"line":1119,"address":[],"length":0,"stats":{"Line":4107282860161892380}},{"line":1120,"address":[],"length":0,"stats":{"Line":8214565720323784760}},{"line":1121,"address":[],"length":0,"stats":{"Line":12321848580485677140}},{"line":1122,"address":[],"length":0,"stats":{"Line":12321848580485677140}},{"line":1123,"address":[],"length":0,"stats":{"Line":16429131440647569394}},{"line":1124,"address":[],"length":0,"stats":{"Line":12321848580485677014}},{"line":1126,"address":[],"length":0,"stats":{"Line":12321848580485677140}},{"line":1131,"address":[],"length":0,"stats":{"Line":144115188075855900}},{"line":1133,"address":[],"length":0,"stats":{"Line":432345564227567700}},{"line":1134,"address":[],"length":0,"stats":{"Line":1297036692682702820}},{"line":1135,"address":[],"length":0,"stats":{"Line":1008806316530991048}},{"line":1136,"address":[],"length":0,"stats":{"Line":432345564227567588}},{"line":1137,"address":[],"length":0,"stats":{"Line":144115188075855844}},{"line":1138,"address":[],"length":0,"stats":{"Line":144115188075855844}},{"line":1141,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":1144,"address":[],"length":0,"stats":{"Line":288230376151711800}},{"line":1146,"address":[],"length":0,"stats":{"Line":432345564227567700}},{"line":1147,"address":[],"length":0,"stats":{"Line":432345564227567700}},{"line":1148,"address":[],"length":0,"stats":{"Line":1873497444986126252}},{"line":1149,"address":[],"length":0,"stats":{"Line":1729382256910270352}},{"line":1150,"address":[],"length":0,"stats":{"Line":1297036692682702764}},{"line":1152,"address":[],"length":0,"stats":{"Line":432345564227567700}},{"line":1155,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1157,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1158,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1159,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1160,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1162,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1163,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1164,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1165,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":1168,"address":[],"length":0,"stats":{"Line":8214565720323784704}},{"line":1169,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1170,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1171,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1172,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1173,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1174,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1175,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1177,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1178,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1179,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1180,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1181,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1182,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1183,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1184,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1185,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1186,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1187,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1188,"address":[],"length":0,"stats":{"Line":12321848580485677056}},{"line":1191,"address":[],"length":0,"stats":{"Line":4107282860161892366}},{"line":1192,"address":[],"length":0,"stats":{"Line":8214565720323784732}},{"line":1194,"address":[],"length":0,"stats":{"Line":16429131440647569464}},{"line":1195,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":8214565720323784732}},{"line":1201,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1202,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1203,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1204,"address":[],"length":0,"stats":{"Line":8214565720323784732}},{"line":1205,"address":[],"length":0,"stats":{"Line":8214565720323784732}},{"line":1206,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1207,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1208,"address":[],"length":0,"stats":{"Line":8214565720323784732}},{"line":1209,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1210,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1211,"address":[],"length":0,"stats":{"Line":12321848580485677098}},{"line":1215,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1217,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1218,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1219,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1220,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1222,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1223,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1224,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1225,"address":[],"length":0,"stats":{"Line":144115188075855886}},{"line":1228,"address":[],"length":0,"stats":{"Line":288230376151711772}},{"line":1230,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1232,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1234,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1235,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1236,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1237,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1238,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1240,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1241,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1243,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1244,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1246,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1248,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1250,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1252,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1254,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1256,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1257,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1258,"address":[],"length":0,"stats":{"Line":432345564227567658}},{"line":1262,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1263,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1266,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1267,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1268,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1269,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1272,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1275,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1276,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1277,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1278,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1282,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1285,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1288,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1291,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1294,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1297,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1300,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1303,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1306,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1310,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1313,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1316,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1317,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1318,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1319,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1322,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1323,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1324,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1325,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1328,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1329,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1330,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1331,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1333,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1337,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1339,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1340,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1341,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1342,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1344,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1345,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1346,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1347,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1350,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1352,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1354,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1356,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1357,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1358,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1359,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1360,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1362,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1363,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1365,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1366,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1368,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1370,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1372,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1374,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1376,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1378,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1379,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1380,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1386,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1387,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1390,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1393,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1394,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1395,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1399,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1400,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1401,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1402,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1403,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1404,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1405,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1406,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1410,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1413,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1415,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1418,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":1419,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":1420,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1421,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1422,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1423,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1424,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1425,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1428,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1429,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1430,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1433,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1434,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1435,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1436,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1437,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1438,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1439,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1442,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1443,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1444,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1445,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1448,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1452,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1453,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1456,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1457,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1458,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1459,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1460,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1461,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1462,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1463,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1464,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1465,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1468,"address":[],"length":0,"stats":{"Line":4395513236313604110}},{"line":1469,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":1470,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1471,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1472,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1473,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1474,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1475,"address":[],"length":0,"stats":{"Line":8791026472627208220}},{"line":1476,"address":[],"length":0,"stats":{"Line":13186539708940812330}},{"line":1479,"address":[],"length":0,"stats":{"Line":720575940379279374}},{"line":1480,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":1481,"address":[],"length":0,"stats":{"Line":2161727821137838122}},{"line":1482,"address":[],"length":0,"stats":{"Line":2161727821137838122}},{"line":1483,"address":[],"length":0,"stats":{"Line":2161727821137838122}},{"line":1484,"address":[],"length":0,"stats":{"Line":2161727821137838122}},{"line":1485,"address":[],"length":0,"stats":{"Line":2161727821137838122}},{"line":1486,"address":[],"length":0,"stats":{"Line":1441151880758558748}},{"line":1487,"address":[],"length":0,"stats":{"Line":2161727821137838122}},{"line":1490,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":1491,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":1492,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":1493,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":1494,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":1495,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":1498,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":1499,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":1502,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1503,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1504,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1505,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1506,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1507,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1508,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1509,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1510,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1511,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1512,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1513,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1514,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1515,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1516,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1517,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1518,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1519,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1520,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1521,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1522,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1523,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1524,"address":[],"length":0,"stats":{"Line":5116089176692883470}},{"line":1526,"address":[],"length":0,"stats":{"Line":14123288431433875470}},{"line":1527,"address":[],"length":0,"stats":{"Line":9007199254740992000}},{"line":1529,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1530,"address":[],"length":0,"stats":{"Line":10232178353385766940}},{"line":1531,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1532,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1533,"address":[],"length":0,"stats":{"Line":15348267530078650410}},{"line":1536,"address":[],"length":0,"stats":{"Line":2233785415175766156}},{"line":1537,"address":[],"length":0,"stats":{"Line":4467570830351532312}},{"line":1538,"address":[],"length":0,"stats":{"Line":6701356245527298468}},{"line":1539,"address":[],"length":0,"stats":{"Line":6701356245527298468}},{"line":1540,"address":[],"length":0,"stats":{"Line":6701356245527298468}},{"line":1541,"address":[],"length":0,"stats":{"Line":6701356245527298468}},{"line":1544,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1545,"address":[],"length":0,"stats":{"Line":8791026472627208206}},{"line":1546,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1547,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1548,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1549,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1550,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1551,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1552,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1553,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1554,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1555,"address":[],"length":0,"stats":{"Line":8791026472627208206}},{"line":1556,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1557,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1558,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1559,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1560,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1561,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1562,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1563,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1564,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1566,"address":[],"length":0,"stats":{"Line":12393906174523605020}},{"line":1567,"address":[],"length":0,"stats":{"Line":7998392938210000917}},{"line":1569,"address":[],"length":0,"stats":{"Line":2377900603251622028}},{"line":1570,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":1572,"address":[],"length":0,"stats":{"Line":13186539708940812309}},{"line":1573,"address":[],"length":0,"stats":{"Line":4395513236313604103}},{"line":1576,"address":[],"length":0,"stats":{"Line":16285016252571713634}},{"line":1577,"address":[],"length":0,"stats":{"Line":14123288431433875652}},{"line":1578,"address":[],"length":0,"stats":{"Line":11961560610296037670}},{"line":1579,"address":[],"length":0,"stats":{"Line":11961560610296037670}},{"line":1580,"address":[],"length":0,"stats":{"Line":11961560610296037670}},{"line":1581,"address":[],"length":0,"stats":{"Line":11961560610296037670}},{"line":1584,"address":[],"length":0,"stats":{"Line":16285016252571713634}},{"line":1585,"address":[],"length":0,"stats":{"Line":11961560610296037670}},{"line":1586,"address":[],"length":0,"stats":{"Line":16285016252571713634}},{"line":1587,"address":[],"length":0,"stats":{"Line":16285016252571713634}},{"line":1590,"address":[],"length":0,"stats":{"Line":16285016252571713634}},{"line":1597,"address":[],"length":0,"stats":{"Line":144115188075856174}},{"line":1598,"address":[],"length":0,"stats":{"Line":288230376151712348}},{"line":1600,"address":[],"length":0,"stats":{"Line":432345564227568522}},{"line":1601,"address":[],"length":0,"stats":{"Line":576460752303424696}},{"line":1604,"address":[],"length":0,"stats":{"Line":432345564227568522}},{"line":1606,"address":[],"length":0,"stats":{"Line":576460752303424696}},{"line":1607,"address":[],"length":0,"stats":{"Line":576460752303424696}},{"line":1610,"address":[],"length":0,"stats":{"Line":288230376151712348}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1614,"address":[],"length":0,"stats":{"Line":576460752303424696}},{"line":1617,"address":[],"length":0,"stats":{"Line":288230376151712348}},{"line":1620,"address":[],"length":0,"stats":{"Line":288230376151712348}},{"line":1621,"address":[],"length":0,"stats":{"Line":432345564227568522}},{"line":1622,"address":[],"length":0,"stats":{"Line":432345564227568522}},{"line":1623,"address":[],"length":0,"stats":{"Line":576460752303424696}},{"line":1625,"address":[],"length":0,"stats":{"Line":432345564227568522}},{"line":1628,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1630,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":1631,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":1632,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":1633,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":1635,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":1636,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":1639,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1640,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1641,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1642,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1643,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1644,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1645,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1646,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1647,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":1650,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1657,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1658,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1660,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1661,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1662,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1666,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":1668,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1671,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1673,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1674,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1677,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":1678,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1679,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1681,"address":[],"length":0,"stats":{"Line":0}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":1685,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":1686,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1691,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1692,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1693,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1694,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":1696,"address":[],"length":0,"stats":{"Line":0}},{"line":1697,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1701,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1704,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":1705,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":876,"coverable":977},{"path":["C:","\\","Users","micha","repos","muxide","tests","audio_samples.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{AudioCodec, MuxerBuilder, VideoCodec};\r\nuse std::{fs, path::Path};\r\nuse support::{parse_boxes, Mp4Box, SharedBuffer};\r\n\r\nfn read_hex_fixture(dir: &str, name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(dir)\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\nfn find_box<'a>(haystack: &'a [u8], typ: [u8; 4]) -> Mp4Box {\r\n    *parse_boxes(haystack)\r\n        .iter()\r\n        .find(|b| b.typ == typ)\r\n        .unwrap_or_else(|| panic!(\"missing box {:?}\", std::str::from_utf8(&typ).unwrap()))\r\n}\r\n\r\nfn be_u32(bytes: &[u8]) -> u32 {\r\n    u32::from_be_bytes(bytes.try_into().unwrap())\r\n}\r\n\r\nfn handler_type_from_trak(trak_payload: &[u8]) -> [u8; 4] {\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n    let hdlr = find_box(mdia_payload, *b\"hdlr\");\r\n    let hdlr_payload = hdlr.payload(mdia_payload);\r\n    hdlr_payload[8..12].try_into().unwrap()\r\n}\r\n\r\n#[test]\r\nfn audio_samples_writes_second_track_and_tables() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let frame1 = read_hex_fixture(\"video_samples\", \"frame1_p.264\");\r\n    let frame2 = read_hex_fixture(\"video_samples\", \"frame2_p.264\");\r\n\r\n    let a0 = read_hex_fixture(\"audio_samples\", \"frame0.aac.adts\");\r\n    let a1 = read_hex_fixture(\"audio_samples\", \"frame1.aac.adts\");\r\n    let a2 = read_hex_fixture(\"audio_samples\", \"frame2.aac.adts\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48_000, 2)\r\n        .build()?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.write_audio(0.0, &a0)?;\r\n    muxer.write_audio(0.021, &a1)?;\r\n    muxer.write_video(0.033, &frame1, false)?;\r\n    muxer.write_audio(0.042, &a2)?;\r\n    muxer.write_video(0.066, &frame2, false)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    assert_eq!(top[0].typ, *b\"ftyp\");\r\n    // fast_start=true (default) puts moov before mdat\r\n    assert_eq!(top[1].typ, *b\"moov\");\r\n    assert_eq!(top[2].typ, *b\"mdat\");\r\n\r\n    let mdat = top[2];\r\n    let mdat_payload_start = (mdat.offset + 8) as u32;\r\n    let mdat_end = (mdat.offset + mdat.size) as u32;\r\n\r\n    let moov_payload = top[1].payload(&produced);\r\n    let traks: Vec<Mp4Box> = parse_boxes(moov_payload)\r\n        .into_iter()\r\n        .filter(|b| b.typ == *b\"trak\")\r\n        .collect();\r\n    assert_eq!(traks.len(), 2);\r\n\r\n    let mut video_trak = None;\r\n    let mut audio_trak = None;\r\n    for trak in traks {\r\n        let trak_payload = trak.payload(moov_payload);\r\n        match handler_type_from_trak(trak_payload) {\r\n            t if t == *b\"vide\" => video_trak = Some(trak_payload),\r\n            t if t == *b\"soun\" => audio_trak = Some(trak_payload),\r\n            other => panic!(\"unexpected handler type {other:?}\"),\r\n        }\r\n    }\r\n\r\n    let video_trak = video_trak.expect(\"missing vide trak\");\r\n    let audio_trak = audio_trak.expect(\"missing soun trak\");\r\n\r\n    // Video stsd contains an avc1 entry.\r\n    let v_mdia = find_box(video_trak, *b\"mdia\");\r\n    let v_mdia_payload = v_mdia.payload(video_trak);\r\n    let v_minf = find_box(v_mdia_payload, *b\"minf\");\r\n    let v_minf_payload = v_minf.payload(v_mdia_payload);\r\n    let v_stbl = find_box(v_minf_payload, *b\"stbl\");\r\n    let v_stbl_payload = v_stbl.payload(v_minf_payload);\r\n    let v_stsd = find_box(v_stbl_payload, *b\"stsd\");\r\n    let v_stsd_payload = v_stsd.payload(v_stbl_payload);\r\n    let v_entries = parse_boxes(&v_stsd_payload[8..]);\r\n    assert_eq!(v_entries[0].typ, *b\"avc1\");\r\n\r\n    // Audio stsd contains an mp4a entry.\r\n    let a_mdia = find_box(audio_trak, *b\"mdia\");\r\n    let a_mdia_payload = a_mdia.payload(audio_trak);\r\n    let a_minf = find_box(a_mdia_payload, *b\"minf\");\r\n    let a_minf_payload = a_minf.payload(a_mdia_payload);\r\n    let a_stbl = find_box(a_minf_payload, *b\"stbl\");\r\n    let a_stbl_payload = a_stbl.payload(a_minf_payload);\r\n    let a_stsd = find_box(a_stbl_payload, *b\"stsd\");\r\n    let a_stsd_payload = a_stsd.payload(a_stbl_payload);\r\n    let a_entries = parse_boxes(&a_stsd_payload[8..]);\r\n    assert_eq!(a_entries[0].typ, *b\"mp4a\");\r\n\r\n    // Audio stts: single entry with count=3, delta=1890 (90kHz * 0.021s).\r\n    let stts = find_box(a_stbl_payload, *b\"stts\");\r\n    let stts_payload = stts.payload(a_stbl_payload);\r\n    assert_eq!(be_u32(&stts_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stts_payload[8..12]), 3);\r\n    assert_eq!(be_u32(&stts_payload[12..16]), 1890);\r\n\r\n    // Audio stsz: 3 samples, each 2 bytes (ADTS headers stripped).\r\n    let stsz = find_box(a_stbl_payload, *b\"stsz\");\r\n    let stsz_payload = stsz.payload(a_stbl_payload);\r\n    assert_eq!(be_u32(&stsz_payload[8..12]), 3);\r\n    assert_eq!(be_u32(&stsz_payload[12..16]), 2);\r\n    assert_eq!(be_u32(&stsz_payload[16..20]), 2);\r\n    assert_eq!(be_u32(&stsz_payload[20..24]), 2);\r\n\r\n    // Audio stco: 3 chunk offsets within the mdat payload.\r\n    let stco = find_box(a_stbl_payload, *b\"stco\");\r\n    let stco_payload = stco.payload(a_stbl_payload);\r\n    assert_eq!(be_u32(&stco_payload[4..8]), 3);\r\n    for i in 0..3 {\r\n        let off = be_u32(&stco_payload[8 + i * 4..12 + i * 4]);\r\n        assert!(off >= mdat_payload_start);\r\n        assert!(off < mdat_end);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","av1_muxing.rs"],"content":"//! Integration tests for AV1 muxing.\r\n//!\r\n//! These tests verify that AV1 video produces:\r\n//! - av01 sample entry box\r\n//! - av1C configuration box with Sequence Header OBU\r\n\r\nmod support;\r\n\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\nuse support::SharedBuffer;\r\n\r\n/// Build a minimal AV1 keyframe with Sequence Header OBU.\r\n///\r\n/// This is a synthetic OBU stream with:\r\n/// - OBU_SEQUENCE_HEADER (type 1) with minimal valid content\r\n/// - OBU_FRAME (type 6) with KEY_FRAME indicator\r\nfn build_av1_keyframe() -> Vec<u8> {\r\n    let mut data = Vec::new();\r\n    \r\n    // OBU 1: Sequence Header (type 1)\r\n    // OBU header: type=1, has_size=1\r\n    // 0b0_0001_0_1_0 = 0x0A (type=1, has_extension=0, has_size=1)\r\n    data.push(0x0A);\r\n    \r\n    // Size of sequence header payload in LEB128 (let's use 12 bytes)\r\n    data.push(12);\r\n    \r\n    // Minimal sequence header content (12 bytes)\r\n    // seq_profile=0, frame_width_bits_minus_1=10, frame_height_bits_minus_1=10, etc.\r\n    // This is a simplified synthetic sequence header\r\n    data.extend_from_slice(&[\r\n        0x00, // seq_profile=0, still_picture=0, reduced_still_picture_header=0\r\n        0x00, 0x00, // operating_points\r\n        0x10, // frame_width_bits=11, frame_height_bits=11\r\n        0x07, 0x80, // max_frame_width = 1920\r\n        0x04, 0x38, // max_frame_height = 1080\r\n        0x00, // frame_id_numbers_present_flag=0\r\n        0x00, // use_128x128_superblock=0\r\n        0x00, 0x00, // other flags\r\n    ]);\r\n    \r\n    // OBU 2: Frame OBU (type 6) with keyframe\r\n    // OBU header: type=6, has_size=1\r\n    // 0b0_0110_0_1_0 = 0x32 (type=6, has_extension=0, has_size=1)\r\n    data.push(0x32);\r\n    \r\n    // Size of frame payload\r\n    data.push(4);\r\n    \r\n    // Minimal frame header indicating keyframe\r\n    // show_existing_frame=0, frame_type=KEY_FRAME(0)\r\n    data.extend_from_slice(&[0x10, 0x00, 0x00, 0x00]);\r\n    \r\n    data\r\n}\r\n\r\n/// Build an AV1 frame without Sequence Header (for error testing).\r\nfn build_av1_frame_no_seq_header() -> Vec<u8> {\r\n    let mut data = Vec::new();\r\n    \r\n    // Only a Frame OBU, no Sequence Header\r\n    // OBU header: type=6, has_size=1\r\n    data.push(0x32);\r\n    data.push(4);\r\n    data.extend_from_slice(&[0x10, 0x00, 0x00, 0x00]);\r\n    \r\n    data\r\n}\r\n\r\n/// Recursively search for a 4CC in an MP4 container by pattern matching\r\nfn contains_box(data: &[u8], fourcc: &[u8; 4]) -> bool {\r\n    data.windows(4).any(|window| window == fourcc)\r\n}\r\n\r\n#[test]\r\nfn av1_muxer_produces_av01_sample_entry() {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::Av1, 1920, 1080, 30.0)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Write a keyframe with Sequence Header\r\n    let keyframe = build_av1_keyframe();\r\n    muxer.write_video(0.0, &keyframe, true).expect(\"write_video should succeed\");\r\n    \r\n    muxer.finish().expect(\"finish should succeed\");\r\n    \r\n    let produced = buffer.lock().unwrap();\r\n    \r\n    // Find the av01 box\r\n    assert!(contains_box(&produced, b\"av01\"), \"Output should contain av01 sample entry\");\r\n    \r\n    // Find the av1C box\r\n    assert!(contains_box(&produced, b\"av1C\"), \"Output should contain av1C configuration box\");\r\n}\r\n\r\n#[test]\r\nfn av1_first_frame_must_be_keyframe() {\r\n    let (writer, _buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::Av1, 1920, 1080, 30.0)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Build a frame without marking it as keyframe\r\n    let frame = build_av1_keyframe();\r\n    \r\n    // First frame as non-keyframe should fail\r\n    let result = muxer.write_video(0.0, &frame, false);\r\n    assert!(result.is_err(), \"first frame must be keyframe\");\r\n    \r\n    let err = result.unwrap_err();\r\n    assert!(\r\n        format!(\"{}\", err).contains(\"keyframe\"),\r\n        \"error message should mention keyframe: {}\", err\r\n    );\r\n}\r\n\r\n#[test]\r\nfn av1_keyframe_must_have_sequence_header() {\r\n    let (writer, _buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::Av1, 1920, 1080, 30.0)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Keyframe without Sequence Header should fail\r\n    let frame_no_seq = build_av1_frame_no_seq_header();\r\n    let result = muxer.write_video(0.0, &frame_no_seq, true);\r\n    assert!(result.is_err(), \"keyframe without Sequence Header should fail\");\r\n    \r\n    let err = result.unwrap_err();\r\n    assert!(\r\n        format!(\"{}\", err).contains(\"Sequence Header\"),\r\n        \"error message should mention Sequence Header: {}\", err\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","avcc_dynamic.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\nuse std::{fs, path::Path};\r\nuse support::{parse_boxes, Mp4Box, SharedBuffer};\r\n\r\nfn read_hex_fixture(name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(\"video_samples\")\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\nfn find_box<'a>(haystack: &'a [u8], typ: [u8; 4]) -> Mp4Box {\r\n    *parse_boxes(haystack)\r\n        .iter()\r\n        .find(|b| b.typ == typ)\r\n        .unwrap_or_else(|| panic!(\"missing box {:?}\", std::str::from_utf8(&typ).unwrap()))\r\n}\r\n\r\nfn extract_avcc_payload(produced: &[u8]) -> Vec<u8> {\r\n    let top = parse_boxes(produced);\r\n    let moov = top.iter().find(|b| b.typ == *b\"moov\").expect(\"moov\");\r\n    let moov_payload = moov.payload(produced);\r\n\r\n    let trak = find_box(moov_payload, *b\"trak\");\r\n    let trak_payload = trak.payload(moov_payload);\r\n\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n\r\n    let minf = find_box(mdia_payload, *b\"minf\");\r\n    let minf_payload = minf.payload(mdia_payload);\r\n\r\n    let stbl = find_box(minf_payload, *b\"stbl\");\r\n    let stbl_payload = stbl.payload(minf_payload);\r\n\r\n    let stsd = find_box(stbl_payload, *b\"stsd\");\r\n    let stsd_payload = stsd.payload(stbl_payload);\r\n\r\n    // Skip full box header + entry count.\r\n    let entries_payload = &stsd_payload[8..];\r\n    let avc1_boxes = parse_boxes(entries_payload);\r\n    let avc1 = avc1_boxes.iter().find(|b| b.typ == *b\"avc1\").expect(\"avc1\");\r\n    let avc1_payload = avc1.payload(entries_payload);\r\n\r\n    let avc_c_index = avc1_payload\r\n        .windows(4)\r\n        .position(|window| window == b\"avcC\")\r\n        .expect(\"avcC box must exist in avc1\");\r\n    let size_start = avc_c_index - 4;\r\n    let avc_c_size = u32::from_be_bytes(avc1_payload[size_start..size_start + 4].try_into().unwrap()) as usize;\r\n    avc1_payload[size_start + 8..size_start + avc_c_size].to_vec()\r\n}\r\n\r\n#[test]\r\nfn avcc_uses_sps_pps_from_first_keyframe() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"frame0_key_alt.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let avcc_payload = extract_avcc_payload(&produced);\r\n\r\n    // Our alt SPS begins with: 67 4d 00 28 ...\r\n    let expected_profile = 0x4d;\r\n    let expected_compat = 0x00;\r\n    let expected_level = 0x28;\r\n\r\n    assert!(avcc_payload.windows(6).any(|w| w == [0x67, 0x4d, 0x00, 0x28, 0xaa, 0xbb]));\r\n    assert!(avcc_payload.windows(4).any(|w| w == [0x68, 0xee, 0x06, 0xf2]));\r\n\r\n    // avcC header bytes must match SPS profile/compat/level.\r\n    assert!(avcc_payload.len() >= 4);\r\n    assert_eq!(avcc_payload[0], 1);\r\n    assert_eq!(avcc_payload[1], expected_profile);\r\n    assert_eq!(avcc_payload[2], expected_compat);\r\n    assert_eq!(avcc_payload[3], expected_level);\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","bframe_ctts.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\nuse support::{parse_boxes, Mp4Box, SharedBuffer};\r\n\r\nfn find_box(haystack: &[u8], typ: [u8; 4]) -> Mp4Box {\r\n    *parse_boxes(haystack)\r\n        .iter()\r\n        .find(|b| b.typ == typ)\r\n        .unwrap_or_else(|| panic!(\"missing box {:?}\", std::str::from_utf8(&typ).unwrap()))\r\n}\r\n\r\nfn try_find_box(haystack: &[u8], typ: [u8; 4]) -> Option<Mp4Box> {\r\n    parse_boxes(haystack)\r\n        .into_iter()\r\n        .find(|b| b.typ == typ)\r\n}\r\n\r\nfn be_u32(bytes: &[u8]) -> u32 {\r\n    u32::from_be_bytes(bytes.try_into().unwrap())\r\n}\r\n\r\nfn be_i32(bytes: &[u8]) -> i32 {\r\n    i32::from_be_bytes(bytes.try_into().unwrap())\r\n}\r\n\r\n/// Test that B-frame video produces a ctts box with correct composition time offsets.\r\n#[test]\r\nfn bframe_video_produces_ctts_box() -> Result<(), Box<dyn std::error::Error>> {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    // Simulated GOP with B-frames: I P B B (decode order)\r\n    // Display order would be: I B B P\r\n    // \r\n    // Frame   DTS     PTS     CTS (pts-dts)\r\n    // I       0       0       0\r\n    // P       3000    9000    6000    (P displayed after 2 B-frames)\r\n    // B       6000    3000    -3000   (B at display pos 1)\r\n    // B       9000    6000    -3000   (B at display pos 2)\r\n\r\n    // SPS+PPS+IDR keyframe\r\n    let frame_i = vec![\r\n        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11,\r\n        0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x38, 0x80,\r\n        0x00, 0x00, 0x00, 0x01, 0x65, 0xaa, 0xbb, 0xcc, 0xdd,\r\n    ];\r\n    // P-frame (non-IDR)\r\n    let frame_p = vec![0x00, 0x00, 0x00, 0x01, 0x41, 0xaa, 0xbb, 0xcc];\r\n    // B-frames\r\n    let frame_b1 = vec![0x00, 0x00, 0x00, 0x01, 0x01, 0x11, 0x22, 0x33];\r\n    let frame_b2 = vec![0x00, 0x00, 0x00, 0x01, 0x01, 0x44, 0x55, 0x66];\r\n\r\n    // At 30fps, frame duration is 1/30 sec = 3000 timescale units (90kHz)\r\n    let frame_dur = 1.0 / 30.0;\r\n\r\n    // Write frames in decode order with explicit DTS\r\n    // I-frame: pts=0, dts=0\r\n    muxer.write_video_with_dts(0.0, 0.0, &frame_i, true)?;\r\n    // P-frame: pts=3*frame_dur (displayed 4th), dts=frame_dur (decoded 2nd)\r\n    muxer.write_video_with_dts(3.0 * frame_dur, 1.0 * frame_dur, &frame_p, false)?;\r\n    // B-frame 1: pts=1*frame_dur (displayed 2nd), dts=2*frame_dur (decoded 3rd)\r\n    muxer.write_video_with_dts(1.0 * frame_dur, 2.0 * frame_dur, &frame_b1, false)?;\r\n    // B-frame 2: pts=2*frame_dur (displayed 3rd), dts=3*frame_dur (decoded 4th)\r\n    muxer.write_video_with_dts(2.0 * frame_dur, 3.0 * frame_dur, &frame_b2, false)?;\r\n\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n\r\n    // Navigate to stbl\r\n    let moov = find_box(&produced, *b\"moov\");\r\n    let moov_payload = moov.payload(&produced);\r\n    let trak = find_box(moov_payload, *b\"trak\");\r\n    let trak_payload = trak.payload(moov_payload);\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n    let minf = find_box(mdia_payload, *b\"minf\");\r\n    let minf_payload = minf.payload(mdia_payload);\r\n    let stbl = find_box(minf_payload, *b\"stbl\");\r\n    let stbl_payload = stbl.payload(minf_payload);\r\n\r\n    // Verify ctts box exists (only when B-frames present)\r\n    let ctts = try_find_box(stbl_payload, *b\"ctts\");\r\n    assert!(ctts.is_some(), \"ctts box should be present for B-frame video\");\r\n    \r\n    let ctts = ctts.unwrap();\r\n    let ctts_payload = ctts.payload(stbl_payload);\r\n\r\n    // ctts header: version(1)+flags(3) = 4 bytes, entry_count = 4 bytes\r\n    let version = ctts_payload[0];\r\n    assert_eq!(version, 1, \"ctts should use version 1 for signed offsets\");\r\n    \r\n    let entry_count = be_u32(&ctts_payload[4..8]);\r\n    // We have 4 samples, but run-length encoding may compress them\r\n    assert!(entry_count >= 1, \"ctts should have at least one entry\");\r\n\r\n    // Verify the CTS offsets are correct\r\n    // For this test we wrote:\r\n    // I: pts=0, dts=0 -> cts=0\r\n    // P: pts=9000, dts=3000 -> cts=6000\r\n    // B1: pts=3000, dts=6000 -> cts=-3000\r\n    // B2: pts=6000, dts=9000 -> cts=-3000\r\n\r\n    // Read all entries\r\n    let mut offset = 8;\r\n    let mut all_cts: Vec<i32> = Vec::new();\r\n    for _ in 0..entry_count {\r\n        let count = be_u32(&ctts_payload[offset..offset+4]) as usize;\r\n        let cts = be_i32(&ctts_payload[offset+4..offset+8]);\r\n        for _ in 0..count {\r\n            all_cts.push(cts);\r\n        }\r\n        offset += 8;\r\n    }\r\n\r\n    assert_eq!(all_cts.len(), 4, \"Should have 4 CTS values for 4 samples\");\r\n    assert_eq!(all_cts[0], 0, \"I-frame: cts should be 0\");\r\n    assert_eq!(all_cts[1], 6000, \"P-frame: cts should be 6000 (pts=9000, dts=3000)\");\r\n    assert_eq!(all_cts[2], -3000, \"B1: cts should be -3000 (pts=3000, dts=6000)\");\r\n    assert_eq!(all_cts[3], -3000, \"B2: cts should be -3000 (pts=6000, dts=9000)\");\r\n\r\n    Ok(())\r\n}\r\n\r\n/// Test that video without B-frames does NOT produce a ctts box.\r\n#[test]\r\nfn non_bframe_video_has_no_ctts_box() -> Result<(), Box<dyn std::error::Error>> {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    // Regular I-P-P video (no B-frames)\r\n    let frame_i = vec![\r\n        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11,\r\n        0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x38, 0x80,\r\n        0x00, 0x00, 0x00, 0x01, 0x65, 0xaa, 0xbb, 0xcc, 0xdd,\r\n    ];\r\n    let frame_p1 = vec![0x00, 0x00, 0x00, 0x01, 0x41, 0xaa, 0xbb, 0xcc];\r\n    let frame_p2 = vec![0x00, 0x00, 0x00, 0x01, 0x41, 0xdd, 0xee, 0xff];\r\n\r\n    let frame_dur = 1.0 / 30.0;\r\n    muxer.write_video(0.0, &frame_i, true)?;\r\n    muxer.write_video(frame_dur, &frame_p1, false)?;\r\n    muxer.write_video(2.0 * frame_dur, &frame_p2, false)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n\r\n    // Navigate to stbl\r\n    let moov = find_box(&produced, *b\"moov\");\r\n    let moov_payload = moov.payload(&produced);\r\n    let trak = find_box(moov_payload, *b\"trak\");\r\n    let trak_payload = trak.payload(moov_payload);\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n    let minf = find_box(mdia_payload, *b\"minf\");\r\n    let minf_payload = minf.payload(mdia_payload);\r\n    let stbl = find_box(minf_payload, *b\"stbl\");\r\n    let stbl_payload = stbl.payload(minf_payload);\r\n\r\n    // ctts should NOT be present\r\n    let ctts = try_find_box(stbl_payload, *b\"ctts\");\r\n    assert!(ctts.is_none(), \"ctts box should NOT be present for non-B-frame video\");\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","error_handling.rs"],"content":"use muxide::api::{AudioCodec, MuxerBuilder, MuxerError, VideoCodec};\r\nuse std::{fs, path::Path};\r\n\r\nmod support;\r\nuse support::SharedBuffer;\r\n\r\nfn read_hex_fixture(dir: &str, name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(dir)\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\n#[test]\r\nfn errors_are_specific_and_descriptive() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let non_sps_pps = read_hex_fixture(\"video_samples\", \"frame1_p.264\");\r\n\r\n    // Video pts must be non-negative.\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .build()?;\r\n        let err = muxer.write_video(-0.001, &frame0, true).unwrap_err();\r\n        assert!(matches!(err, MuxerError::NegativeVideoPts { .. }));\r\n        let msg = err.to_string();\r\n        assert!(msg.contains(\"negative\"), \"error should mention negative: {}\", msg);\r\n        assert!(msg.contains(\"frame 0\"), \"error should include frame index: {}\", msg);\r\n    }\r\n\r\n    // First frame must be a keyframe.\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .build()?;\r\n        let err = muxer.write_video(0.0, &frame0, false).unwrap_err();\r\n        assert!(matches!(err, MuxerError::FirstVideoFrameMustBeKeyframe));\r\n        assert!(err.to_string().contains(\"keyframe\"));\r\n    }\r\n\r\n    // First keyframe must contain SPS/PPS.\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .build()?;\r\n        let err = muxer.write_video(0.0, &non_sps_pps, true).unwrap_err();\r\n        assert!(matches!(err, MuxerError::FirstVideoFrameMissingSpsPps));\r\n        assert!(err.to_string().contains(\"SPS\"));\r\n    }\r\n\r\n    // Video pts must be strictly increasing.\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .build()?;\r\n        muxer.write_video(0.0, &frame0, true)?;\r\n        let err = muxer.write_video(0.0, &frame0, false).unwrap_err();\r\n        assert!(matches!(err, MuxerError::NonIncreasingVideoPts { .. }));\r\n        let msg = err.to_string();\r\n        assert!(msg.contains(\"frame 1\"), \"error should include frame index: {}\", msg);\r\n        assert!(msg.contains(\"increase\"), \"error should mention increasing: {}\", msg);\r\n    }\r\n\r\n    // Audio must not arrive before first video frame.\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .audio(AudioCodec::Aac, 48_000, 2)\r\n            .build()?;\r\n        let err = muxer.write_audio(0.0, &[0xff, 0xf1, 0x4c, 0x80, 0x01, 0x3f, 0xfc]).unwrap_err();\r\n        assert!(matches!(err, MuxerError::AudioBeforeFirstVideo { .. }));\r\n        assert!(err.to_string().contains(\"video\"));\r\n    }\r\n\r\n    // Invalid ADTS should surface as InvalidAdts.\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .audio(AudioCodec::Aac, 48_000, 2)\r\n            .build()?;\r\n        muxer.write_video(0.0, &frame0, true)?;\r\n        let err = muxer.write_audio(0.0, &[0, 1, 2, 3]).unwrap_err();\r\n        assert!(matches!(err, MuxerError::InvalidAdts { .. }));\r\n        assert!(err.to_string().contains(\"ADTS\"));\r\n    }\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","finalisation.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{AudioCodec, MuxerBuilder, VideoCodec};\r\nuse std::{fs, path::Path};\r\nuse support::SharedBuffer;\r\n\r\nfn read_hex_fixture(dir: &str, name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(dir)\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\n#[test]\r\nfn finish_in_place_errors_on_double_finish_and_blocks_writes() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.finish_in_place()?;\r\n\r\n    assert!(muxer.finish_in_place().is_err());\r\n    assert!(muxer.write_video(0.033, &frame0, false).is_err());\r\n\r\n    drop(muxer);\r\n    assert!(!buffer.lock().unwrap().is_empty());\r\n    Ok(())\r\n}\r\n\r\n#[test]\r\nfn finish_is_deterministic_for_same_inputs() -> Result<(), Box<dyn std::error::Error>> {\r\n    let v0 = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let v1 = read_hex_fixture(\"video_samples\", \"frame1_p.264\");\r\n    let v2 = read_hex_fixture(\"video_samples\", \"frame2_p.264\");\r\n\r\n    let a0 = read_hex_fixture(\"audio_samples\", \"frame0.aac.adts\");\r\n    let a1 = read_hex_fixture(\"audio_samples\", \"frame1.aac.adts\");\r\n    let a2 = read_hex_fixture(\"audio_samples\", \"frame2.aac.adts\");\r\n\r\n    let (w1, b1) = SharedBuffer::new();\r\n    let mut m1 = MuxerBuilder::new(w1)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48_000, 2)\r\n        .build()?;\r\n\r\n    m1.write_video(0.0, &v0, true)?;\r\n    m1.write_audio(0.0, &a0)?;\r\n    m1.write_audio(0.021, &a1)?;\r\n    m1.write_video(0.033, &v1, false)?;\r\n    m1.write_audio(0.042, &a2)?;\r\n    m1.write_video(0.066, &v2, false)?;\r\n    m1.finish()?;\r\n\r\n    let (w2, b2) = SharedBuffer::new();\r\n    let mut m2 = MuxerBuilder::new(w2)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48_000, 2)\r\n        .build()?;\r\n\r\n    m2.write_video(0.0, &v0, true)?;\r\n    m2.write_audio(0.0, &a0)?;\r\n    m2.write_audio(0.021, &a1)?;\r\n    m2.write_video(0.033, &v1, false)?;\r\n    m2.write_audio(0.042, &a2)?;\r\n    m2.write_video(0.066, &v2, false)?;\r\n    m2.finish()?;\r\n\r\n    assert_eq!(*b1.lock().unwrap(), *b2.lock().unwrap());\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","golden.rs"],"content":"mod support;\r\n\r\nuse std::{fs, path::Path};\r\nuse support::parse_boxes;\r\n\r\n#[test]\r\nfn golden_minimal_contains_expected_boxes() -> Result<(), Box<dyn std::error::Error>> {\r\n    let fixture = Path::new(env!(\"CARGO_MANIFEST_DIR\")).join(\"fixtures/minimal.mp4\");\r\n    let data = fs::read(fixture)?;\r\n    let boxes = parse_boxes(&data);\r\n\r\n    assert!(boxes.len() >= 2, \"expected at least two top-level boxes\");\r\n    assert_eq!(boxes[0].typ, *b\"ftyp\");\r\n    assert_eq!(boxes[1].typ, *b\"moov\");\r\n\r\n    let moov = boxes.iter().find(|b| b.typ == *b\"moov\").unwrap();\r\n    let moov_payload = moov.payload(&data);\r\n    let child_boxes = parse_boxes(moov_payload);\r\n    assert!(child_boxes.iter().any(|b| b.typ == *b\"mvhd\"));\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","hevc_muxing.rs"],"content":"//! Integration tests for HEVC (H.265) video muxing.\r\n\r\nmod support;\r\n\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\nuse support::SharedBuffer;\r\n\r\n/// Helper to build a minimal HEVC keyframe with VPS, SPS, PPS, and IDR slice.\r\nfn build_hevc_keyframe() -> Vec<u8> {\r\n    let mut data = Vec::new();\r\n    \r\n    // VPS NAL (type 32) - 0x40 = (32 << 1)\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01]); // Start code\r\n    data.extend_from_slice(&[0x40, 0x01, 0x0c, 0x01, 0xff, 0xff, 0x01, 0x60,\r\n                            0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03,\r\n                            0x00, 0x00, 0x03, 0x00, 0x5d, 0x95, 0x98, 0x09]);\r\n    \r\n    // SPS NAL (type 33) - 0x42 = (33 << 1)\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01]); // Start code\r\n    data.extend_from_slice(&[0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03,\r\n                            0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,\r\n                            0x00, 0x5d, 0xa0, 0x02, 0x80, 0x80, 0x2d, 0x16,\r\n                            0x59, 0x59, 0xa4, 0x93, 0x24, 0xb8]);\r\n    \r\n    // PPS NAL (type 34) - 0x44 = (34 << 1)\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01]); // Start code\r\n    data.extend_from_slice(&[0x44, 0x01, 0xc0, 0x73, 0xc0, 0x4c, 0x90]);\r\n    \r\n    // IDR slice NAL (type 19 = IDR_W_RADL) - 0x26 = (19 << 1)\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01]); // Start code\r\n    data.extend_from_slice(&[0x26, 0x01, 0xaf, 0x06, 0xb8, 0x63, 0xef, 0x3e, \r\n                            0xb6, 0xb4, 0x8e, 0x19]);\r\n    \r\n    data\r\n}\r\n\r\n/// Helper to build a minimal HEVC P-frame (non-keyframe).\r\nfn build_hevc_p_frame() -> Vec<u8> {\r\n    let mut data = Vec::new();\r\n    \r\n    // TRAIL_R slice NAL (type 1) - 0x02 = (1 << 1)\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01]); // Start code\r\n    data.extend_from_slice(&[0x02, 0x01, 0xd0, 0x10, 0xf3, 0x95, 0x27, 0x41,\r\n                            0xfe, 0xfc]);\r\n    \r\n    data\r\n}\r\n\r\n/// Recursively search for a 4CC in an MP4 container by pattern matching\r\nfn contains_box(data: &[u8], fourcc: &[u8; 4]) -> bool {\r\n    // Simple pattern search - look for the fourcc anywhere in the data\r\n    data.windows(4).any(|window| window == fourcc)\r\n}\r\n\r\n#[test]\r\nfn hevc_muxer_produces_hvc1_sample_entry() {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H265, 1920, 1080, 30.0)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Write a keyframe\r\n    let keyframe = build_hevc_keyframe();\r\n    muxer.write_video(0.0, &keyframe, true).expect(\"write_video should succeed\");\r\n    \r\n    // Write a P-frame\r\n    let p_frame = build_hevc_p_frame();\r\n    muxer.write_video(1.0 / 30.0, &p_frame, false).expect(\"write_video should succeed\");\r\n    \r\n    muxer.finish().expect(\"finish should succeed\");\r\n    \r\n    let produced = buffer.lock().unwrap();\r\n    \r\n    // Find the hvc1 box\r\n    assert!(contains_box(&produced, b\"hvc1\"), \"Output should contain hvc1 sample entry\");\r\n    \r\n    // Find the hvcC box\r\n    assert!(contains_box(&produced, b\"hvcC\"), \"Output should contain hvcC configuration box\");\r\n}\r\n\r\n#[test]\r\nfn hevc_first_frame_must_be_keyframe() {\r\n    let (writer, _buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H265, 1920, 1080, 30.0)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Try to write a P-frame first (should fail)\r\n    let p_frame = build_hevc_p_frame();\r\n    let result = muxer.write_video(0.0, &p_frame, false);\r\n    \r\n    assert!(result.is_err(), \"First frame must be a keyframe\");\r\n}\r\n\r\n#[test]\r\nfn hevc_keyframe_must_have_vps_sps_pps() {\r\n    let (writer, _buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H265, 1920, 1080, 30.0)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Try to write a keyframe with only IDR slice (no VPS/SPS/PPS)\r\n    let bad_keyframe = vec![\r\n        0x00, 0x00, 0x00, 0x01, 0x26, 0x01, 0xaf, 0x06,  // IDR only\r\n    ];\r\n    let result = muxer.write_video(0.0, &bad_keyframe, true);\r\n    \r\n    assert!(result.is_err(), \"Keyframe must contain VPS, SPS, and PPS\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","input_contract.rs"],"content":"//! Slice 1: Input contract enforcement tests\r\n//! \r\n//! These tests verify that Muxide rejects invalid input with descriptive errors\r\n//! rather than producing corrupt output or panicking.\r\n\r\nmod support;\r\n\r\nuse muxide::api::{AudioCodec, MuxerBuilder, MuxerError, VideoCodec};\r\nuse support::SharedBuffer;\r\nuse std::{fs, path::Path};\r\n\r\nfn read_hex_fixture(dir: &str, name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(dir)\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\n/// Valid ADTS frame for testing (7 byte header + minimal payload)\r\nfn valid_adts_frame() -> Vec<u8> {\r\n    vec![0xff, 0xf1, 0x4c, 0x80, 0x01, 0x3f, 0xfc, 0xaa, 0xbb]\r\n}\r\n\r\n// =============================================================================\r\n// Video PTS contract tests\r\n// =============================================================================\r\n\r\n#[test]\r\nfn video_pts_negative_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    let err = muxer.write_video(-0.001, &frame, true).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::NegativeVideoPts { pts, frame_index } \r\n        if pts < 0.0 && frame_index == 0));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"-0.001\") || msg.contains(\"negative\"), \r\n            \"Error should mention the negative value: {}\", msg);\r\n    assert!(msg.contains(\"frame 0\"), \r\n            \"Error should include frame index: {}\", msg);\r\n}\r\n\r\n#[test]\r\nfn video_pts_non_increasing_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    muxer.write_video(0.0, &frame, true).unwrap();\r\n    muxer.write_video(0.033, &frame, false).unwrap();\r\n    \r\n    // Same timestamp as previous\r\n    let err = muxer.write_video(0.033, &frame, false).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::NonIncreasingVideoPts { prev_pts, curr_pts, frame_index }\r\n        if (prev_pts - 0.033).abs() < 0.001 && (curr_pts - 0.033).abs() < 0.001 && frame_index == 2));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"frame 2\"), \"Error should include frame index: {}\", msg);\r\n    assert!(msg.contains(\"increase\") || msg.contains(\"greater\"), \r\n            \"Error should explain timestamps must increase: {}\", msg);\r\n}\r\n\r\n#[test]\r\nfn video_pts_decreasing_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    muxer.write_video(0.0, &frame, true).unwrap();\r\n    muxer.write_video(0.066, &frame, false).unwrap();\r\n    \r\n    // Decreasing timestamp\r\n    let err = muxer.write_video(0.033, &frame, false).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::NonIncreasingVideoPts { .. }));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"0.033\") || msg.contains(\"0.066\"), \r\n            \"Error should show the timestamp values: {}\", msg);\r\n}\r\n\r\n// =============================================================================\r\n// DTS contract tests (B-frames)\r\n// =============================================================================\r\n\r\n#[test]\r\nfn dts_non_increasing_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    // I-frame at DTS=0\r\n    muxer.write_video_with_dts(0.0, 0.0, &frame, true).unwrap();\r\n    // P-frame at DTS=0.033\r\n    muxer.write_video_with_dts(0.1, 0.033, &frame, false).unwrap();\r\n    \r\n    // Try to write with DTS <= previous DTS\r\n    let err = muxer.write_video_with_dts(0.066, 0.033, &frame, false).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::NonIncreasingDts { .. }));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"DTS\"), \"Error should mention DTS: {}\", msg);\r\n    assert!(msg.contains(\"increase\"), \"Error should explain DTS must increase: {}\", msg);\r\n}\r\n\r\n#[test]\r\nfn dts_negative_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    let err = muxer.write_video_with_dts(0.0, -0.001, &frame, true).unwrap_err();\r\n    \r\n    // Negative DTS treated as negative PTS error\r\n    assert!(matches!(err, MuxerError::NegativeVideoPts { .. }));\r\n}\r\n\r\n// =============================================================================\r\n// Audio contract tests\r\n// =============================================================================\r\n\r\n#[test]\r\nfn audio_pts_negative_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48000, 2)\r\n        .build()\r\n        .unwrap();\r\n\r\n    muxer.write_video(0.0, &frame, true).unwrap();\r\n    \r\n    let err = muxer.write_audio(-0.001, &valid_adts_frame()).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::NegativeAudioPts { pts, frame_index }\r\n        if pts < 0.0 && frame_index == 0));\r\n}\r\n\r\n#[test]\r\nfn audio_pts_decreasing_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48000, 2)\r\n        .build()\r\n        .unwrap();\r\n\r\n    muxer.write_video(0.0, &frame, true).unwrap();\r\n    muxer.write_audio(0.0, &valid_adts_frame()).unwrap();\r\n    muxer.write_audio(0.023, &valid_adts_frame()).unwrap();\r\n    \r\n    // Decreasing audio timestamp\r\n    let err = muxer.write_audio(0.010, &valid_adts_frame()).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::DecreasingAudioPts { prev_pts, curr_pts, frame_index }\r\n        if (prev_pts - 0.023).abs() < 0.001 && (curr_pts - 0.010).abs() < 0.001 && frame_index == 2));\r\n}\r\n\r\n#[test]\r\nfn audio_before_first_video_is_rejected() {\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48000, 2)\r\n        .build()\r\n        .unwrap();\r\n\r\n    // No video written yet\r\n    let err = muxer.write_audio(0.0, &valid_adts_frame()).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::AudioBeforeFirstVideo { first_video_pts: None, .. }));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"video\"), \"Error should mention video: {}\", msg);\r\n}\r\n\r\n#[test]\r\nfn audio_pts_before_first_video_pts_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48000, 2)\r\n        .build()\r\n        .unwrap();\r\n\r\n    // Video starts at 1.0 second\r\n    muxer.write_video(1.0, &frame, true).unwrap();\r\n    \r\n    // Audio at 0.5 seconds (before video)\r\n    let err = muxer.write_audio(0.5, &valid_adts_frame()).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::AudioBeforeFirstVideo { \r\n        audio_pts, first_video_pts: Some(video_pts) \r\n    } if (audio_pts - 0.5).abs() < 0.001 && (video_pts - 1.0).abs() < 0.001));\r\n}\r\n\r\n#[test]\r\nfn audio_empty_frame_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48000, 2)\r\n        .build()\r\n        .unwrap();\r\n\r\n    muxer.write_video(0.0, &frame, true).unwrap();\r\n    \r\n    let err = muxer.write_audio(0.0, &[]).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::EmptyAudioFrame { frame_index: 0 }));\r\n}\r\n\r\n#[test]\r\nfn audio_invalid_adts_is_rejected() {\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .audio(AudioCodec::Aac, 48000, 2)\r\n        .build()\r\n        .unwrap();\r\n\r\n    muxer.write_video(0.0, &frame, true).unwrap();\r\n    \r\n    // Invalid data (doesn't start with 0xFFF sync word)\r\n    let err = muxer.write_audio(0.0, &[0x00, 0x01, 0x02, 0x03]).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::InvalidAdts { frame_index: 0 }));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"ADTS\") || msg.contains(\"sync\"), \r\n            \"Error should mention ADTS format: {}\", msg);\r\n}\r\n\r\n// =============================================================================\r\n// First frame contract tests\r\n// =============================================================================\r\n\r\n#[test]\r\nfn first_video_frame_must_be_keyframe() {\r\n    let p_frame = read_hex_fixture(\"video_samples\", \"frame1_p.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    let err = muxer.write_video(0.0, &p_frame, false).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::FirstVideoFrameMustBeKeyframe));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"keyframe\") || msg.contains(\"IDR\"), \r\n            \"Error should explain first frame must be keyframe: {}\", msg);\r\n}\r\n\r\n#[test]\r\nfn first_keyframe_must_contain_sps_pps() {\r\n    // A frame marked as keyframe but without SPS/PPS\r\n    let p_frame = read_hex_fixture(\"video_samples\", \"frame1_p.264\");\r\n    let (writer, _) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()\r\n        .unwrap();\r\n\r\n    let err = muxer.write_video(0.0, &p_frame, true).unwrap_err();\r\n    \r\n    assert!(matches!(err, MuxerError::FirstVideoFrameMissingSpsPps));\r\n    \r\n    let msg = err.to_string();\r\n    assert!(msg.contains(\"SPS\") && msg.contains(\"PPS\"), \r\n            \"Error should mention SPS and PPS: {}\", msg);\r\n}\r\n\r\n// =============================================================================\r\n// Error message quality tests\r\n// =============================================================================\r\n\r\n#[test]\r\nfn error_messages_are_educational() {\r\n    // All error messages should contain guidance on how to fix the issue\r\n    let frame = read_hex_fixture(\"video_samples\", \"frame0_key.264\");\r\n    \r\n    // Test NonIncreasingVideoPts suggests write_video_with_dts for B-frames\r\n    {\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .build()\r\n            .unwrap();\r\n        muxer.write_video(0.0, &frame, true).unwrap();\r\n        let err = muxer.write_video(0.0, &frame, false).unwrap_err();\r\n        let msg = err.to_string();\r\n        assert!(msg.contains(\"write_video_with_dts\"), \r\n                \"NonIncreasingVideoPts should suggest write_video_with_dts: {}\", msg);\r\n    }\r\n    \r\n    // Test FirstVideoFrameMissingSpsPps explains what to do\r\n    {\r\n        let p_frame = read_hex_fixture(\"video_samples\", \"frame1_p.264\");\r\n        let (writer, _) = SharedBuffer::new();\r\n        let mut muxer = MuxerBuilder::new(writer)\r\n            .video(VideoCodec::H264, 640, 480, 30.0)\r\n            .build()\r\n            .unwrap();\r\n        let err = muxer.write_video(0.0, &p_frame, true).unwrap_err();\r\n        let msg = err.to_string();\r\n        assert!(msg.contains(\"prepend\") || msg.contains(\"NAL type\"), \r\n                \"FirstVideoFrameMissingSpsPps should explain how to fix: {}\", msg);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","metadata_fast_start.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{Metadata, MuxerBuilder, VideoCodec};\r\nuse support::{parse_boxes, Mp4Box, SharedBuffer};\r\n\r\nfn be_u32(data: &[u8]) -> u32 {\r\n    u32::from_be_bytes([data[0], data[1], data[2], data[3]])\r\n}\r\n\r\nfn find_box(haystack: &[u8], typ: [u8; 4]) -> Mp4Box {\r\n    *parse_boxes(haystack)\r\n        .iter()\r\n        .find(|b| b.typ == typ)\r\n        .unwrap_or_else(|| panic!(\"missing box {:?}\", std::str::from_utf8(&typ).unwrap()))\r\n}\r\n\r\n#[test]\r\nfn metadata_title_appears_in_udta_box() -> Result<(), Box<dyn std::error::Error>> {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n\r\n    let metadata = Metadata {\r\n        title: Some(\"Test Video Title\".to_string()),\r\n        creation_time: Some(3600), // 1 hour since 1904\r\n    };\r\n\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .with_metadata(metadata)\r\n        .build()?;\r\n\r\n    // Write a single keyframe\r\n    let frame0 = vec![\r\n        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11,\r\n        0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x38, 0x80,\r\n        0x00, 0x00, 0x00, 0x01, 0x65, 0xaa, 0xbb, 0xcc, 0xdd,\r\n    ];\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    \r\n    // Fast-start: ftyp, moov, mdat\r\n    assert_eq!(top[0].typ, *b\"ftyp\");\r\n    assert_eq!(top[1].typ, *b\"moov\");\r\n    assert_eq!(top[2].typ, *b\"mdat\");\r\n\r\n    let moov_payload = top[1].payload(&produced);\r\n    \r\n    // Look for udta box in moov\r\n    let udta = find_box(moov_payload, *b\"udta\");\r\n    assert!(udta.size > 8, \"udta box should contain metadata\");\r\n    \r\n    let udta_payload = udta.payload(moov_payload);\r\n    \r\n    // udta should contain a meta box\r\n    let meta = find_box(udta_payload, *b\"meta\");\r\n    assert!(meta.size > 8, \"meta box should contain data\");\r\n    \r\n    // Verify the title string appears somewhere in the metadata\r\n    let title_bytes = b\"Test Video Title\";\r\n    let produced_slice = &produced[..];\r\n    let contains_title = produced_slice\r\n        .windows(title_bytes.len())\r\n        .any(|w| w == title_bytes);\r\n    assert!(contains_title, \"Title string should appear in the output\");\r\n\r\n    Ok(())\r\n}\r\n\r\n#[test]\r\nfn fast_start_puts_moov_before_mdat() -> Result<(), Box<dyn std::error::Error>> {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n\r\n    // fast_start is true by default\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    let frame0 = vec![\r\n        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11,\r\n        0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x38, 0x80,\r\n        0x00, 0x00, 0x00, 0x01, 0x65, 0xaa, 0xbb, 0xcc, 0xdd,\r\n    ];\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    \r\n    assert_eq!(top[0].typ, *b\"ftyp\", \"First box should be ftyp\");\r\n    assert_eq!(top[1].typ, *b\"moov\", \"Second box should be moov (fast-start)\");\r\n    assert_eq!(top[2].typ, *b\"mdat\", \"Third box should be mdat\");\r\n\r\n    // Verify moov comes BEFORE mdat in the byte stream\r\n    let moov_offset = top[1].offset;\r\n    let mdat_offset = top[2].offset;\r\n    assert!(moov_offset < mdat_offset, \"moov should come before mdat for fast start\");\r\n\r\n    Ok(())\r\n}\r\n\r\n#[test]\r\nfn fast_start_false_puts_mdat_before_moov() -> Result<(), Box<dyn std::error::Error>> {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .with_fast_start(false)  // Disable fast-start\r\n        .build()?;\r\n\r\n    let frame0 = vec![\r\n        0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e, 0xda, 0x02, 0x80, 0x2d, 0x8b, 0x11,\r\n        0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x38, 0x80,\r\n        0x00, 0x00, 0x00, 0x01, 0x65, 0xaa, 0xbb, 0xcc, 0xdd,\r\n    ];\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    \r\n    assert_eq!(top[0].typ, *b\"ftyp\", \"First box should be ftyp\");\r\n    assert_eq!(top[1].typ, *b\"mdat\", \"Second box should be mdat (standard mode)\");\r\n    assert_eq!(top[2].typ, *b\"moov\", \"Third box should be moov\");\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","minimal.rs"],"content":"mod support;\n\nuse muxide::api::{MuxerBuilder, VideoCodec};\nuse std::{fs, path::Path};\nuse support::SharedBuffer;\n\n#[test]\nfn minimal_writer_matches_fixture() -> Result<(), Box<dyn std::error::Error>> {\n    let (writer, buffer) = SharedBuffer::new();\n\n    let muxer = MuxerBuilder::new(writer)\n        .video(VideoCodec::H264, 640, 480, 30.0)\n        .build()?;\n\n    muxer.finish()?;\n\n    let produced = buffer.lock().unwrap().clone();\n    let fixture = fs::read(Path::new(env!(\"CARGO_MANIFEST_DIR\")).join(\"fixtures/minimal.mp4\"))?;\n    assert_eq!(\n        produced, fixture,\n        \"build output must match the golden minimal file\"\n    );\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","opus_muxing.rs"],"content":"//! Integration tests for Opus audio muxing.\r\n\r\nmod support;\r\n\r\nuse muxide::api::{AudioCodec, MuxerBuilder, VideoCodec};\r\nuse support::SharedBuffer;\r\n\r\n/// Build a minimal H.264 keyframe for video track setup.\r\nfn build_h264_keyframe() -> Vec<u8> {\r\n    let mut data = Vec::new();\r\n    // SPS\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01, 0x67, 0x42, 0x00, 0x1e, 0xab, 0x40, 0xf0, 0x28, 0xd0]);\r\n    // PPS\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01, 0x68, 0xce, 0x38, 0x80]);\r\n    // IDR slice\r\n    data.extend_from_slice(&[0x00, 0x00, 0x00, 0x01, 0x65, 0x88, 0x84, 0x00, 0x10]);\r\n    data\r\n}\r\n\r\n/// Build a minimal Opus packet (SILK 20ms, stereo, 1 frame).\r\nfn build_opus_packet() -> Vec<u8> {\r\n    // TOC: config=4 (SILK 20ms), s=1 (stereo), c=0 (1 frame)\r\n    // Binary: 0b00100_1_00 = 0x24\r\n    vec![0x24, 0xc0, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05]\r\n}\r\n\r\n/// Recursively search for a 4CC in an MP4 container by pattern matching\r\nfn contains_box(data: &[u8], fourcc: &[u8; 4]) -> bool {\r\n    data.windows(4).any(|window| window == fourcc)\r\n}\r\n\r\n#[test]\r\nfn opus_muxer_produces_opus_sample_entry() {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n        .audio(AudioCodec::Opus, 48000, 2)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Write video keyframe first (required)\r\n    let keyframe = build_h264_keyframe();\r\n    muxer.write_video(0.0, &keyframe, true).expect(\"write_video should succeed\");\r\n    \r\n    // Write Opus audio packet\r\n    let audio = build_opus_packet();\r\n    muxer.write_audio(0.0, &audio).expect(\"write_audio should succeed\");\r\n    muxer.write_audio(0.02, &audio).expect(\"write_audio should succeed\");\r\n    \r\n    muxer.finish().expect(\"finish should succeed\");\r\n    \r\n    let produced = buffer.lock().unwrap();\r\n    \r\n    // Find the Opus sample entry box\r\n    assert!(contains_box(&produced, b\"Opus\"), \"Output should contain Opus sample entry\");\r\n    \r\n    // Find the dOps (Opus decoder config) box\r\n    assert!(contains_box(&produced, b\"dOps\"), \"Output should contain dOps configuration box\");\r\n}\r\n\r\n#[test]\r\nfn opus_invalid_packet_rejected() {\r\n    let (writer, _buffer) = SharedBuffer::new();\r\n    \r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n        .audio(AudioCodec::Opus, 48000, 2)\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    // Write video keyframe first\r\n    let keyframe = build_h264_keyframe();\r\n    muxer.write_video(0.0, &keyframe, true).expect(\"write_video should succeed\");\r\n    \r\n    // Try to write an empty Opus packet (should fail)\r\n    let result = muxer.write_audio(0.0, &[]);\r\n    assert!(result.is_err(), \"Empty Opus packet should be rejected\");\r\n}\r\n\r\n#[test]\r\nfn opus_sample_rate_forced_to_48khz() {\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    \r\n    // Even though we specify 44100, Opus internally uses 48kHz\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n        .audio(AudioCodec::Opus, 44100, 2) // User says 44.1kHz but Opus ignores this\r\n        .build()\r\n        .expect(\"build should succeed\");\r\n    \r\n    let keyframe = build_h264_keyframe();\r\n    muxer.write_video(0.0, &keyframe, true).expect(\"write_video should succeed\");\r\n    \r\n    let audio = build_opus_packet();\r\n    muxer.write_audio(0.0, &audio).expect(\"write_audio should succeed\");\r\n    \r\n    muxer.finish().expect(\"finish should succeed\");\r\n    \r\n    let produced = buffer.lock().unwrap();\r\n    \r\n    // Output should still have Opus boxes (rate is internally 48kHz)\r\n    assert!(contains_box(&produced, b\"Opus\"), \"Output should contain Opus sample entry\");\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","property_tests.rs"],"content":"//! Property-Based Tests for Muxide\r\n//!\r\n//! These tests verify invariants hold across a wide range of inputs using proptest.\r\n//! They catch edge cases that unit tests might miss.\r\n\r\nuse proptest::prelude::*;\r\nuse std::io::Cursor;\r\n\r\n// Import the muxide crate\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\n\r\n/// Helper to create a valid H.264 keyframe with SPS/PPS\r\nfn make_h264_keyframe() -> Vec<u8> {\r\n    // Minimal valid Annex B H.264 stream with SPS, PPS, and IDR slice\r\n    let mut data = Vec::new();\r\n    // SPS (NAL type 7)\r\n    data.extend_from_slice(&[0, 0, 0, 1, 0x67, 0x42, 0x00, 0x1e, 0x95, 0xa8, 0x28, 0x28, 0x28]);\r\n    // PPS (NAL type 8)\r\n    data.extend_from_slice(&[0, 0, 0, 1, 0x68, 0xce, 0x3c, 0x80]);\r\n    // IDR slice (NAL type 5)\r\n    data.extend_from_slice(&[0, 0, 0, 1, 0x65, 0x88, 0x84, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03]);\r\n    data\r\n}\r\n\r\n/// Helper to create a valid H.264 P-frame\r\nfn make_h264_pframe() -> Vec<u8> {\r\n    // Non-IDR slice (NAL type 1)\r\n    let mut data = Vec::new();\r\n    data.extend_from_slice(&[0, 0, 0, 1, 0x41, 0x9a, 0x24, 0x6c, 0x42, 0xff, 0xff]);\r\n    data\r\n}\r\n\r\nproptest! {\r\n    /// Property: Output size must be at least header size (ftyp + moov + mdat headers)\r\n    #[test]\r\n    fn prop_output_always_has_minimum_size(frames in 1..10usize) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Write first keyframe at t=0.0\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        \r\n        // Write P-frames at 30fps intervals\r\n        for i in 1..frames {\r\n            let pts = i as f64 / 30.0; // seconds\r\n            muxer.write_video(pts, &make_h264_pframe(), false).unwrap();\r\n        }\r\n        \r\n        muxer.finish().unwrap();\r\n        \r\n        let output = buffer.into_inner();\r\n        // Minimum: ftyp(24) + mdat header(8) + moov(varies, but at least 500)\r\n        prop_assert!(output.len() >= 500, \"Output {} bytes is too small\", output.len());\r\n    }\r\n\r\n    /// Property: Width and height in config are preserved in output\r\n    #[test]\r\n    fn prop_dimensions_preserved(\r\n        width in 64u32..4096,\r\n        height in 64u32..2160\r\n    ) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, width, height, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        muxer.finish().unwrap();\r\n        \r\n        let output = buffer.into_inner();\r\n        \r\n        // Find avc1 box (contains width/height in visual sample entry)\r\n        // Search for the bytes \"avc1\" in the output\r\n        let avc1_pos = output.windows(4)\r\n            .position(|w| w == b\"avc1\");\r\n        prop_assert!(avc1_pos.is_some(), \"avc1 box not found in output\");\r\n        \r\n        // Just verify the file was produced and has reasonable structure\r\n        prop_assert!(output.len() >= 500, \"Output too small\");\r\n        \r\n        // Verify moov box exists\r\n        let moov_pos = output.windows(4)\r\n            .position(|w| w == b\"moov\");\r\n        prop_assert!(moov_pos.is_some(), \"moov box not found\");\r\n    }\r\n\r\n    /// Property: PTS values must be monotonically increasing\r\n    #[test]\r\n    fn prop_pts_must_increase(frame_count in 2..20usize) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // First keyframe at pts=0.0\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        \r\n        // Subsequent frames with increasing PTS\r\n        for i in 1..frame_count {\r\n            let pts = i as f64 / 30.0;\r\n            muxer.write_video(pts, &make_h264_pframe(), false).unwrap();\r\n        }\r\n        \r\n        // This should succeed (monotonic PTS)\r\n        let result = muxer.finish();\r\n        prop_assert!(result.is_ok());\r\n    }\r\n\r\n    /// Property: Non-monotonic PTS must be rejected\r\n    #[test]\r\n    fn prop_non_monotonic_pts_rejected(\r\n        first_pts in 0.1f64..1.0,\r\n        second_pts in 0.0f64..0.05\r\n    ) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // First keyframe\r\n        muxer.write_video(first_pts, &make_h264_keyframe(), true).unwrap();\r\n        \r\n        // Second frame with earlier PTS - should fail\r\n        let result = muxer.write_video(second_pts, &make_h264_pframe(), false);\r\n        prop_assert!(result.is_err(), \"Non-monotonic PTS should be rejected\");\r\n    }\r\n\r\n    /// Property: Frame count in stats must match written frames\r\n    #[test]\r\n    fn prop_frame_count_accurate(frame_count in 1..50usize) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // First keyframe\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        \r\n        // Additional frames\r\n        for i in 1..frame_count {\r\n            let pts = i as f64 / 30.0;\r\n            muxer.write_video(pts, &make_h264_pframe(), false).unwrap();\r\n        }\r\n        \r\n        let stats = muxer.finish_with_stats().unwrap();\r\n        prop_assert_eq!(\r\n            stats.video_frames as usize, \r\n            frame_count,\r\n            \"Stats frame count should match written frames\"\r\n        );\r\n    }\r\n\r\n    /// Property: Duration must be approximately frame_count / fps\r\n    #[test]\r\n    fn prop_duration_reasonable(frame_count in 2..100usize) {\r\n        let fps = 30.0;\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, fps)\r\n            .build()\r\n            .unwrap();\r\n\r\n        // Write frames at consistent intervals\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        for i in 1..frame_count {\r\n            let pts = i as f64 / fps; // seconds\r\n            muxer.write_video(pts, &make_h264_pframe(), false).unwrap();\r\n        }\r\n        \r\n        let stats = muxer.finish_with_stats().unwrap();\r\n        \r\n        // Duration should be approximately (frames - 1) * frame_duration\r\n        // (frames - 1 because last frame has no next frame to calculate duration)\r\n        let expected_duration_secs = (frame_count - 1) as f64 / fps;\r\n        \r\n        // Allow 20% tolerance for rounding\r\n        let min_duration = expected_duration_secs * 0.8;\r\n        let max_duration = expected_duration_secs * 1.2 + 0.1; // +0.1s for rounding\r\n        \r\n        prop_assert!(\r\n            stats.duration_secs >= min_duration && stats.duration_secs <= max_duration,\r\n            \"Duration {}s outside expected range {}..{}s for {} frames at {}fps\",\r\n            stats.duration_secs, min_duration, max_duration, frame_count, fps\r\n        );\r\n    }\r\n\r\n    /// Property: Output must start with ftyp box\r\n    #[test]\r\n    fn prop_output_starts_with_ftyp(frame_count in 1..10usize) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        for i in 1..frame_count {\r\n            muxer.write_video(i as f64 / 30.0, &make_h264_pframe(), false).unwrap();\r\n        }\r\n        muxer.finish().unwrap();\r\n        \r\n        let output = buffer.into_inner();\r\n        \r\n        // ftyp box starts at offset 0, box type at offset 4\r\n        prop_assert!(output.len() >= 8, \"Output too small for ftyp\");\r\n        prop_assert_eq!(&output[4..8], b\"ftyp\", \"First box must be ftyp\");\r\n    }\r\n\r\n    /// Property: Bytes written in stats must match actual output size\r\n    #[test]\r\n    fn prop_bytes_written_accurate(frame_count in 1..20usize) {\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        for i in 1..frame_count {\r\n            muxer.write_video(i as f64 / 30.0, &make_h264_pframe(), false).unwrap();\r\n        }\r\n        \r\n        let stats = muxer.finish_with_stats().unwrap();\r\n        let output = buffer.into_inner();\r\n        \r\n        prop_assert_eq!(\r\n            stats.bytes_written as usize,\r\n            output.len(),\r\n            \"Stats bytes_written should match actual output size\"\r\n        );\r\n    }\r\n}\r\n\r\n/// Find the position of a box with the given type in the MP4 data\r\nfn find_box(data: &[u8], box_type: &[u8; 4]) -> Option<usize> {\r\n    let mut pos = 0;\r\n    while pos + 8 <= data.len() {\r\n        let size = u32::from_be_bytes([data[pos], data[pos+1], data[pos+2], data[pos+3]]) as usize;\r\n        if &data[pos+4..pos+8] == box_type {\r\n            return Some(pos);\r\n        }\r\n        if size == 0 || size > data.len() - pos {\r\n            break;\r\n        }\r\n        pos += size;\r\n    }\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod contract_tests {\r\n    use super::*;\r\n    use muxide::invariant_ppt::{clear_invariant_log, contract_test};\r\n\r\n    /// Contract test: Box building must check size invariant\r\n    #[test]\r\n    fn contract_box_size_invariant() {\r\n        clear_invariant_log();\r\n        \r\n        // Trigger box building by creating an MP4\r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        muxer.finish().unwrap();\r\n        \r\n        // Verify the box size invariant was checked\r\n        contract_test(\"box building\", &[\r\n            \"Box size must equal header + payload\",\r\n        ]);\r\n    }\r\n\r\n    /// Contract test: Video sample entry must check width/height invariants\r\n    #[test]\r\n    fn contract_width_height_invariants() {\r\n        clear_invariant_log();\r\n        \r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        muxer.finish().unwrap();\r\n        \r\n        // Verify width/height invariants were checked\r\n        contract_test(\"avc1 box building\", &[\r\n            \"Width must fit in 16-bit\",\r\n            \"Height must fit in 16-bit\",\r\n        ]);\r\n    }\r\n\r\n    /// Contract test: Sample sizes must be non-zero\r\n    #[test]\r\n    fn contract_sample_sizes_invariant() {\r\n        clear_invariant_log();\r\n        \r\n        let mut buffer = Cursor::new(Vec::new());\r\n        let mut muxer = MuxerBuilder::new(&mut buffer)\r\n            .video(VideoCodec::H264, 1920, 1080, 30.0)\r\n            .build()\r\n            .unwrap();\r\n\r\n        muxer.write_video(0.0, &make_h264_keyframe(), true).unwrap();\r\n        muxer.write_video(1.0 / 30.0, &make_h264_pframe(), false).unwrap();\r\n        muxer.finish().unwrap();\r\n        \r\n        // Verify the stsz invariant was checked\r\n        contract_test(\"stsz box building\", &[\r\n            \"No empty samples in stsz\",\r\n        ]);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","stats.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{Muxer, MuxerConfig, MuxerBuilder, MuxerStats, VideoCodec};\r\nuse std::{fs, path::Path};\r\nuse support::SharedBuffer;\r\n\r\nfn read_hex_fixture(name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(\"video_samples\")\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\n#[test]\r\nfn finish_with_stats_reports_frames_duration_and_bytes() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"frame0_key.264\");\r\n    let frame1 = read_hex_fixture(\"frame1_p.264\");\r\n    let frame2 = read_hex_fixture(\"frame2_p.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.write_video(1.0 / 30.0, &frame1, false)?;\r\n    muxer.write_video(2.0 / 30.0, &frame2, false)?;\r\n\r\n    let stats: MuxerStats = muxer.finish_with_stats()?;\r\n\r\n    let produced_len = buffer.lock().unwrap().len() as u64;\r\n    assert_eq!(stats.video_frames, 3);\r\n    assert_eq!(stats.bytes_written, produced_len);\r\n\r\n    // 3 frames at 30fps => end time is (2/30 + 1/30) = 0.1s.\r\n    let expected = 0.1_f64;\r\n    assert!((stats.duration_secs - expected).abs() < 1e-9);\r\n\r\n    Ok(())\r\n}\r\n\r\n#[test]\r\nfn muxer_new_from_config_is_equivalent_to_builder_for_video_only() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"frame0_key.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let config = MuxerConfig::new(640, 480, 30.0);\r\n    let mut muxer: Muxer<_> = Muxer::new(writer, config)?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    let _stats = muxer.finish_with_stats()?;\r\n\r\n    assert!(!buffer.lock().unwrap().is_empty());\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","support.rs"],"content":"use std::io::Write;\nuse std::sync::{Arc, Mutex};\n\n/// Thread-safe buffer that captures all writes for reuse in tests.\n#[allow(dead_code)]\npub struct SharedBuffer {\n    inner: Arc<Mutex<Vec<u8>>>,\n}\n\nimpl SharedBuffer {\n    /// Creates a new shared buffer and returns it along with a handle to the\n    /// stored bytes.\n    #[allow(dead_code)]\n    pub fn new() -> (Self, Arc<Mutex<Vec<u8>>>) {\n        let inner = Arc::new(Mutex::new(Vec::new()));\n        (\n            Self {\n                inner: inner.clone(),\n            },\n            inner,\n        )\n    }\n}\n\nimpl Clone for SharedBuffer {\n    fn clone(&self) -> Self {\n        Self {\n            inner: self.inner.clone(),\n        }\n    }\n}\n\nimpl Write for SharedBuffer {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        let mut guard = self.inner.lock().unwrap();\n        guard.extend_from_slice(buf);\n        Ok(buf.len())\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        Ok(())\n    }\n}\n\n/// Light-weight representation of an MP4 box used for parsing tests.\n#[allow(dead_code)]\n#[derive(Debug, Clone, Copy)]\npub struct Mp4Box {\n    pub typ: [u8; 4],\n    pub size: usize,\n    pub offset: usize,\n}\n\nimpl Mp4Box {\n    /// Return the payload that immediately follows the box header.\n    #[allow(dead_code)]\n    pub fn payload<'a>(&self, data: &'a [u8]) -> &'a [u8] {\n        &data[self.offset + 8..self.offset + self.size]\n    }\n}\n\n/// Parses top-level boxes from the provided MP4 data.\n#[allow(dead_code)]\npub fn parse_boxes(data: &[u8]) -> Vec<Mp4Box> {\n    let mut boxes = Vec::new();\n    let mut cursor = 0;\n\n    while cursor + 8 <= data.len() {\n        let size = u32::from_be_bytes(data[cursor..cursor + 4].try_into().unwrap()) as usize;\n        if size < 8 || cursor + size > data.len() {\n            break;\n        }\n        let typ = data[cursor + 4..cursor + 8].try_into().unwrap();\n        boxes.push(Mp4Box {\n            typ,\n            size,\n            offset: cursor,\n        });\n        cursor += size;\n    }\n\n    boxes\n}\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","timebase.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\nuse std::{fs, path::Path};\r\nuse support::{parse_boxes, Mp4Box, SharedBuffer};\r\n\r\nfn read_hex_fixture(name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(\"video_samples\")\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\nfn find_box<'a>(haystack: &'a [u8], typ: [u8; 4]) -> Mp4Box {\r\n    *parse_boxes(haystack)\r\n        .iter()\r\n        .find(|b| b.typ == typ)\r\n        .unwrap_or_else(|| panic!(\"missing box {:?}\", std::str::from_utf8(&typ).unwrap()))\r\n}\r\n\r\nfn be_u32(bytes: &[u8]) -> u32 {\r\n    u32::from_be_bytes(bytes.try_into().unwrap())\r\n}\r\n\r\n#[test]\r\nfn timebase_30fps_has_exact_3000_tick_delta() -> Result<(), Box<dyn std::error::Error>> {\r\n    let key = read_hex_fixture(\"frame0_key.264\");\r\n    let p = read_hex_fixture(\"frame1_p.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    // Use the CrabCamera convention: pts = frame_number / framerate.\r\n    muxer.write_video(0.0, &key, true)?;\r\n    muxer.write_video(1.0 / 30.0, &p, false)?;\r\n    muxer.write_video(2.0 / 30.0, &p, false)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    let moov = top.iter().find(|b| b.typ == *b\"moov\").unwrap();\r\n\r\n    // Navigate to stts.\r\n    let moov_payload = moov.payload(&produced);\r\n    let trak = find_box(moov_payload, *b\"trak\");\r\n    let trak_payload = trak.payload(moov_payload);\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n    let minf = find_box(mdia_payload, *b\"minf\");\r\n    let minf_payload = minf.payload(mdia_payload);\r\n    let stbl = find_box(minf_payload, *b\"stbl\");\r\n    let stbl_payload = stbl.payload(minf_payload);\r\n\r\n    let stts = find_box(stbl_payload, *b\"stts\");\r\n    let stts_payload = stts.payload(stbl_payload);\r\n\r\n    // Single entry: count=3, delta=3000 (90kHz/30fps).\r\n    assert_eq!(be_u32(&stts_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stts_payload[8..12]), 3);\r\n    assert_eq!(be_u32(&stts_payload[12..16]), 3000);\r\n\r\n    Ok(())\r\n}\r\n\r\n#[test]\r\nfn timebase_long_run_does_not_drift_at_30fps() -> Result<(), Box<dyn std::error::Error>> {\r\n    let key = read_hex_fixture(\"frame0_key.264\");\r\n    let p = read_hex_fixture(\"frame1_p.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    let frames = 300u32; // 10 seconds at 30fps\r\n    for i in 0..frames {\r\n        let pts = (i as f64) / 30.0;\r\n        let is_key = i == 0;\r\n        let data = if is_key { &key } else { &p };\r\n        muxer.write_video(pts, data, is_key)?;\r\n    }\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    let moov = top.iter().find(|b| b.typ == *b\"moov\").unwrap();\r\n\r\n    let moov_payload = moov.payload(&produced);\r\n    let trak = find_box(moov_payload, *b\"trak\");\r\n    let trak_payload = trak.payload(moov_payload);\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n    let minf = find_box(mdia_payload, *b\"minf\");\r\n    let minf_payload = minf.payload(mdia_payload);\r\n    let stbl = find_box(minf_payload, *b\"stbl\");\r\n    let stbl_payload = stbl.payload(minf_payload);\r\n\r\n    let stts = find_box(stbl_payload, *b\"stts\");\r\n    let stts_payload = stts.payload(stbl_payload);\r\n\r\n    // Should collapse to one entry: count=300, delta=3000.\r\n    assert_eq!(be_u32(&stts_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stts_payload[8..12]), frames);\r\n    assert_eq!(be_u32(&stts_payload[12..16]), 3000);\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","video_samples.rs"],"content":"mod support;\r\n\r\nuse muxide::api::{MuxerBuilder, VideoCodec};\r\nuse std::{fs, path::Path};\r\nuse support::{parse_boxes, Mp4Box, SharedBuffer};\r\n\r\nfn read_hex_fixture(name: &str) -> Vec<u8> {\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\"))\r\n        .join(\"fixtures\")\r\n        .join(\"video_samples\")\r\n        .join(name);\r\n    let contents = fs::read_to_string(path).expect(\"fixture must be readable\");\r\n    let hex: String = contents.chars().filter(|c| !c.is_whitespace()).collect();\r\n    assert!(hex.len() % 2 == 0, \"hex fixtures must have even length\");\r\n\r\n    let mut out = Vec::with_capacity(hex.len() / 2);\r\n    for i in (0..hex.len()).step_by(2) {\r\n        let byte = u8::from_str_radix(&hex[i..i + 2], 16).expect(\"valid hex\");\r\n        out.push(byte);\r\n    }\r\n    out\r\n}\r\n\r\nfn find_box<'a>(haystack: &'a [u8], typ: [u8; 4]) -> Mp4Box {\r\n    *parse_boxes(haystack)\r\n        .iter()\r\n        .find(|b| b.typ == typ)\r\n        .unwrap_or_else(|| panic!(\"missing box {:?}\", std::str::from_utf8(&typ).unwrap()))\r\n}\r\n\r\nfn be_u32(bytes: &[u8]) -> u32 {\r\n    u32::from_be_bytes(bytes.try_into().unwrap())\r\n}\r\n\r\n#[test]\r\nfn video_samples_writes_mdat_and_tables() -> Result<(), Box<dyn std::error::Error>> {\r\n    let frame0 = read_hex_fixture(\"frame0_key.264\");\r\n    let frame1 = read_hex_fixture(\"frame1_p.264\");\r\n    let frame2 = read_hex_fixture(\"frame2_p.264\");\r\n\r\n    let (writer, buffer) = SharedBuffer::new();\r\n    let mut muxer = MuxerBuilder::new(writer)\r\n        .video(VideoCodec::H264, 640, 480, 30.0)\r\n        .build()?;\r\n\r\n    muxer.write_video(0.0, &frame0, true)?;\r\n    muxer.write_video(1.0 / 30.0, &frame1, false)?;\r\n    muxer.write_video(2.0 / 30.0, &frame2, false)?;\r\n    muxer.finish()?;\r\n\r\n    let produced = buffer.lock().unwrap();\r\n    let top = parse_boxes(&produced);\r\n    assert_eq!(top[0].typ, *b\"ftyp\");\r\n    // Fast-start is enabled by default: moov comes before mdat\r\n    assert_eq!(top[1].typ, *b\"moov\");\r\n    assert_eq!(top[2].typ, *b\"mdat\");\r\n\r\n    let ftyp = top[0];\r\n    let moov = top[1];\r\n    let mdat = top[2];\r\n\r\n    // stco should point to the first byte of mdat payload (after moov).\r\n    let expected_chunk_offset = (ftyp.size + moov.size + 8) as u32;\r\n\r\n    // Verify mdat begins with a 4-byte NAL length (AVCC format).\r\n    let mdat_payload = mdat.payload(&produced);\r\n    assert!(mdat_payload.len() >= 4);\r\n    let first_nal_len = be_u32(&mdat_payload[0..4]) as usize;\r\n    assert!(first_nal_len > 0);\r\n    assert!(mdat_payload.len() >= 4 + first_nal_len);\r\n\r\n    // Navigate to stbl.\r\n    let moov_payload = moov.payload(&produced);\r\n    let trak = find_box(moov_payload, *b\"trak\");\r\n    let trak_payload = trak.payload(moov_payload);\r\n    let mdia = find_box(trak_payload, *b\"mdia\");\r\n    let mdia_payload = mdia.payload(trak_payload);\r\n    let minf = find_box(mdia_payload, *b\"minf\");\r\n    let minf_payload = minf.payload(mdia_payload);\r\n    let stbl = find_box(minf_payload, *b\"stbl\");\r\n    let stbl_payload = stbl.payload(minf_payload);\r\n\r\n    // stts: single entry with count=3, delta=3000 (90kHz / 30fps).\r\n    let stts = find_box(stbl_payload, *b\"stts\");\r\n    let stts_payload = stts.payload(stbl_payload);\r\n    assert_eq!(be_u32(&stts_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stts_payload[8..12]), 3);\r\n    assert_eq!(be_u32(&stts_payload[12..16]), 3000);\r\n\r\n    // stsc: one chunk containing all 3 samples.\r\n    let stsc = find_box(stbl_payload, *b\"stsc\");\r\n    let stsc_payload = stsc.payload(stbl_payload);\r\n    assert_eq!(be_u32(&stsc_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stsc_payload[8..12]), 1);\r\n    assert_eq!(be_u32(&stsc_payload[12..16]), 3);\r\n    assert_eq!(be_u32(&stsc_payload[16..20]), 1);\r\n\r\n    // stsz: sample sizes match AVCC conversion (length prefixes included).\r\n    let stsz = find_box(stbl_payload, *b\"stsz\");\r\n    let stsz_payload = stsz.payload(stbl_payload);\r\n    assert_eq!(be_u32(&stsz_payload[4..8]), 0);\r\n    assert_eq!(be_u32(&stsz_payload[8..12]), 3);\r\n\r\n    // Frame0 contains 3 NALs (SPS, PPS, IDR), each length-prefixed.\r\n    let expected_size0 = (4 + 10) + (4 + 4) + (4 + 5); // based on fixture bytes\r\n    let expected_size1 = 4 + (frame1.len() - 4); // start code removed, 4-byte length added\r\n    let expected_size2 = 4 + (frame2.len() - 4);\r\n\r\n    assert_eq!(be_u32(&stsz_payload[12..16]) as usize, expected_size0);\r\n    assert_eq!(be_u32(&stsz_payload[16..20]) as usize, expected_size1);\r\n    assert_eq!(be_u32(&stsz_payload[20..24]) as usize, expected_size2);\r\n\r\n    // stco: one chunk offset.\r\n    let stco = find_box(stbl_payload, *b\"stco\");\r\n    let stco_payload = stco.payload(stbl_payload);\r\n    assert_eq!(be_u32(&stco_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stco_payload[8..12]), expected_chunk_offset);\r\n\r\n    // stss: only the first sample is a sync sample.\r\n    let stss = find_box(stbl_payload, *b\"stss\");\r\n    let stss_payload = stss.payload(stbl_payload);\r\n    assert_eq!(be_u32(&stss_payload[4..8]), 1);\r\n    assert_eq!(be_u32(&stss_payload[8..12]), 1);\r\n\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","micha","repos","muxide","tests","video_setup.rs"],"content":"mod support;\n\nuse muxide::api::{MuxerBuilder, VideoCodec};\nuse support::{parse_boxes, SharedBuffer};\n\n#[test]\nfn video_track_structure_contains_expected_boxes() -> Result<(), Box<dyn std::error::Error>> {\n    let (writer, buffer) = SharedBuffer::new();\n\n    let muxer = MuxerBuilder::new(writer)\n        .video(VideoCodec::H264, 1920, 1080, 30.0)\n        .build()?;\n    muxer.finish()?;\n\n    let produced = buffer.lock().unwrap();\n    let top_boxes = parse_boxes(&produced);\n    let moov = top_boxes\n        .iter()\n        .find(|b| b.typ == *b\"moov\")\n        .expect(\"moov box must exist\");\n\n    let moov_payload = moov.payload(&produced);\n    let moov_children = parse_boxes(moov_payload);\n    assert!(\n        moov_children.iter().any(|b| b.typ == *b\"trak\"),\n        \"trak missing\"\n    );\n    let trak = moov_children.iter().find(|b| b.typ == *b\"trak\").unwrap();\n\n    let trak_payload = trak.payload(moov_payload);\n    let mdia_boxes = parse_boxes(trak_payload);\n    let mdia = mdia_boxes.iter().find(|b| b.typ == *b\"mdia\").unwrap();\n\n    let mdia_payload = mdia.payload(trak_payload);\n    let minf_boxes = parse_boxes(mdia_payload);\n    let minf = minf_boxes.iter().find(|b| b.typ == *b\"minf\").unwrap();\n\n    let minf_payload = minf.payload(mdia_payload);\n    let stbl_boxes = parse_boxes(minf_payload);\n    let stbl = stbl_boxes.iter().find(|b| b.typ == *b\"stbl\").unwrap();\n\n    let stbl_payload = stbl.payload(minf_payload);\n    let stsd_boxes = parse_boxes(stbl_payload);\n    let stsd = stsd_boxes.iter().find(|b| b.typ == *b\"stsd\").unwrap();\n\n    let stsd_payload = stsd.payload(stbl_payload);\n    let entries_payload = &stsd_payload[8..];\n    let avc1_boxes = parse_boxes(entries_payload);\n    let avc1 = avc1_boxes.iter().find(|b| b.typ == *b\"avc1\").unwrap();\n\n    let avc1_payload = avc1.payload(entries_payload);\n    let avc_c_index = avc1_payload\n        .windows(4)\n        .position(|window| window == b\"avcC\")\n        .expect(\"avcC box must exist in avc1\");\n    let size_start = avc_c_index - 4;\n    let avc_c_size =\n        u32::from_be_bytes(avc1_payload[size_start..size_start + 4].try_into().unwrap()) as usize;\n    let avc_c_payload = &avc1_payload[size_start + 8..size_start + avc_c_size];\n    assert!(\n        avc_c_payload.windows(1).any(|w| w[0] == 0x67),\n        \"SPS missing in avcC\"\n    );\n    assert!(\n        avc_c_payload.windows(1).any(|w| w[0] == 0x68),\n        \"PPS missing in avcC\"\n    );\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0}],"coverage":86.20342396777441,"covered":1712,"coverable":1986}